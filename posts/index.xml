<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on shyの考研日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/</link>
        <description>Recent content in Posts on shyの考研日志</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Sat, 11 Oct 2025 23:17:48 +0800</lastBuildDate><atom:link href="https://auroraemiya.github.io/npee_learning_log.github.io/posts/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>1011学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/1011/</link>
        <pubDate>Sat, 11 Oct 2025 23:17:48 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/1011/</guid>
        <description>&lt;h2 id=&#34;数学-概率论&#34;&gt;数学-概率论
&lt;/h2&gt;&lt;h3 id=&#34;多维随机变量及其分布&#34;&gt;多维随机变量及其分布
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;n维随机变量及其分布函数&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;n维随机变量的概念&lt;/li&gt;
&lt;li&gt;n维随机变量的分布函数的概念和性质
&lt;ol&gt;
&lt;li&gt;概念&lt;/li&gt;
&lt;li&gt;性质
&lt;ol&gt;
&lt;li&gt;单调性&lt;/li&gt;
&lt;li&gt;右连续性&lt;/li&gt;
&lt;li&gt;有界性&lt;/li&gt;
&lt;li&gt;非负性&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;边缘分布函数&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常见的两类二维随机变量&amp;ndash;离散型随机变量与连续型随机变量&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;二维离散型随机变量的概率分布、边缘分布和条件分布&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;概率分布
&lt;/p&gt;
$$
         p_y = P\{X=x_i,Y=y_i\},i,j = 1,2,...
         $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;联合分布函数、边缘分布、条件分布&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;联合分布函数
&lt;/p&gt;
$$
            F(x,y)=P\{X\leq x,Y\leq y\} = \sum\limits_{x_i\leq x}\sum\limits_{y_i\leq y}p_{ij}
            $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;边缘分布
&lt;/p&gt;
$$
            p_{i\cdot} = P\{X=x_i\}=\sum_{j=1}^{\infty}P\{X=x_i,Y=y_j\}=\sum\limits_{j=1}^{\infty}p_{ij}(i=1,2,...)
            $$$$
            p_{\cdot j} = P\{Y=y_i\}=\sum_{i=1}^{\infty}P\{X=x_i,Y=y_j\}=\sum\limits_{i=1}^{\infty}p_{ij}(i=1,2,...)
            $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;条件分布
&lt;/p&gt;
$$
            P\{X=x_i|Y=y_j\}=\frac{P\{X=x_i,Y=y_j\}}{P\{Y=y_j\}}=\frac{p_{ij}}{p_{\cdot j}}
            $$$$
            P\{Y=y_j|X=x_i\}=\frac{P\{X=x_i,Y=y_j\}}{P\{X=x_i\}}=\frac{p_{ij}}{p_{i\cdot }}
            $$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二维连续型随机变量的概率密度、边缘概率密度和条件概率密度&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;概率密度&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;概念
&lt;/p&gt;
$$
            F(x,y)=\int_{-\infty}^{y}dv\int_{-\infty}^{x}f(u,v)du,(x,y)\in\mathbf{R}^2
            $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二元函数$f(x,y)$是概率密度的充分必要条件为
&lt;/p&gt;
$$
            f(x,y)\geq 0,\int_{-\infty}^{+\infty}dy\int_{-\infty}^{+\infty}f(x,y)dx = 1
            $$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;联合分布函数与概率密度、边缘概率密度、条件概率密度&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;联合分布函数与概率密度&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$F(x,y)$为$(x,y)$的二元连续函数，且
&lt;/p&gt;
$$
               F(x,y) = P\{X\leq x,Y\leq y\} = \int_{-\infty}^{y}dv\int_{-\infty}^{x}f(u,v)du
               $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设G为平面上某个区域，则
&lt;/p&gt;
$$
               P\{(x,y)\in G\} = \iint\limits_{G}f(x,y)dxdy
               $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若$f(x,y)$在点$(x,y)$处连续，则$\dfrac{\partial^2F(x,y)}{\partial x \partial y}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若$F(x,y)$连续且可导，则$(X,Y)$是连续型随机变量，且$\dfrac{\partial^2F(x,y)}{\partial x \partial y}$是它的概率密度&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;边缘概率密度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;条件概率密度
&lt;/p&gt;
$$
            f_{Y|X}(y|x) = \frac{f(x,y)}{f_X(x)}
            $$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常见的二维分布&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;二维均匀分布&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二维正态分布&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;若$(X_1,X_2)\sim N(\mu_1,\mu_2;\sigma_1^2,\sigma_2^2;\rho)$,则
&lt;/p&gt;
$$
               X_1\sim N(\mu_1,\sigma_1^2),X_2\sim N(\mu_2,\sigma_2^2)
               $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若$X_1\sim N(\mu_1,\sigma_1^2),X_2\sim N(\mu_2,\sigma_2^2)$,且$X_1,X_2$相互独立，则
&lt;/p&gt;
$$
               (X_1,X_2)\sim N(\mu_1,\mu_2;\sigma_1^2,\sigma_2^2;0)
               $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$(X_1,X_2)\sim N\Rightarrow k_1X_1+ k_2X_2 \sim N(k_1 , k_2\text{不全为零})$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随机变量的相互独立性&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;概念&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设二维随机变量$(X,Y)$的分布函数$F(x,y)$，边缘分布函数分别为$F_X(x),F_Y(y)$，如果对任意的实数$x,y$,都有
&lt;/p&gt;
$$
         F(x,y)=F_X(x)\cdot F_Y(y)
         $$&lt;p&gt;
则称$X$与$Y$相互独立，否则不相互独立&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果$n$维随机变量$(X_1,X_2,\cdots,X_n)$的分布函数等于边缘分布函数的乘积，即
&lt;/p&gt;
$$
         F(x_1,x_2,\cdots,x_n) = F_1(x_1)F_2(x_2)\cdots F_n(x_n)
         $$&lt;p&gt;
则称$X_1,X_2,\cdots,X_n$相互独立&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相互独立的充要条件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相互独立的性质&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$X$与$Y$不独立的判断与证明&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0926学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0926/</link>
        <pubDate>Fri, 26 Sep 2025 21:45:15 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0926/</guid>
        <description>&lt;h2 id=&#34;数学-无穷级数&#34;&gt;数学-无穷级数
&lt;/h2&gt;&lt;p&gt;听得我脑子膨胀说是。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;常数项级数的概念与性质
&lt;ol&gt;
&lt;li&gt;引例&lt;/li&gt;
&lt;li&gt;概念及其敛散性&lt;/li&gt;
&lt;li&gt;性质
&lt;ol&gt;
&lt;li&gt;收敛级数的线性组合仍然收敛&lt;/li&gt;
&lt;li&gt;改变级数的有限项，不会改变敛散性&lt;/li&gt;
&lt;li&gt;收敛级数的项任意加括号后所得的新级数仍收敛，且其和不变&lt;/li&gt;
&lt;li&gt;若$\sum\limits_{n=1}^{\infty}u_n$收敛，则$\lim\limits_{n\to\infty}u_n=0$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;级数敛散性的判别方法
&lt;ol&gt;
&lt;li&gt;正项级数及其敛散性判别
&lt;ol&gt;
&lt;li&gt;收敛原则&lt;/li&gt;
&lt;li&gt;比较判别法&lt;/li&gt;
&lt;li&gt;比较判别法的极限形式（无穷小比阶）&lt;/li&gt;
&lt;li&gt;比值判别法（达朗贝尔判别法）&lt;/li&gt;
&lt;li&gt;根值判别法（柯西判别法）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;交错级数及其敛散性判别
&lt;ul&gt;
&lt;li&gt;莱布尼茨判别法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;任意项级数及其敛散性判别（绝对值判别法）
&lt;ol&gt;
&lt;li&gt;绝对收敛&lt;/li&gt;
&lt;li&gt;条件收敛&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;幂级数及其收敛域
&lt;ol&gt;
&lt;li&gt;概念
&lt;ol&gt;
&lt;li&gt;函数项级数&lt;/li&gt;
&lt;li&gt;幂级数&lt;/li&gt;
&lt;li&gt;收敛点域发散点&lt;/li&gt;
&lt;li&gt;收敛域&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;阿贝尔定理&lt;/li&gt;
&lt;li&gt;收敛半径&lt;/li&gt;
&lt;li&gt;收敛域的求法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;幂级数求和
&lt;ol&gt;
&lt;li&gt;概念&lt;/li&gt;
&lt;li&gt;运算法则&lt;/li&gt;
&lt;li&gt;恒等变形方式&lt;/li&gt;
&lt;li&gt;性质&lt;/li&gt;
&lt;li&gt;重要展开式&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0925学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0925/</link>
        <pubDate>Thu, 25 Sep 2025 22:39:01 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0925/</guid>
        <description>&lt;h2 id=&#34;前言&#34;&gt;前言
&lt;/h2&gt;&lt;p&gt;鉴于本人发现更新一次日志甚至需要一个多小时，使得一个作为日记性质的log变成了一项”艰巨“的任务，实在是本末倒置，不过，既然开了这个栏目，为了记录自己的学习过程，当然还是要如实记录，前面的就慢慢更新，总之先把今天的更新了。&lt;/p&gt;
&lt;h2 id=&#34;数学-微分方程&#34;&gt;数学-微分方程
&lt;/h2&gt;&lt;p&gt;数学其实已经学完了多元微分、二重（多重）积分以及微分方程的解法。就今天来说，今天完成了如下学习&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;数学（领域）&lt;/th&gt;
          &lt;th&gt;内容&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;微分方程&lt;/td&gt;
          &lt;td&gt;一阶、高阶微分方程的求解&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;线性代数&lt;/td&gt;
          &lt;td&gt;矩阵的各种性质&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;看起来挺轻描淡写的，不过内容展开还是很多的，详细的内容我还是会放在学习笔记里阐述，比如微分方程的各种解法，矩阵如逆矩阵，伴随矩阵等的性质一并专开一个专栏进行阐述，不然日志显得过于冗长，变成了流水账。&lt;/p&gt;
&lt;h3 id=&#34;微分方程&#34;&gt;微分方程
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;微分方程的概念
&lt;ol&gt;
&lt;li&gt;微分方程及其阶&lt;/li&gt;
&lt;li&gt;常微分方程（一元）&lt;/li&gt;
&lt;li&gt;线性微分方程&lt;/li&gt;
&lt;li&gt;微分方程的解&lt;/li&gt;
&lt;li&gt;微分方程的通解&lt;/li&gt;
&lt;li&gt;初始条件与特解&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;一阶微分方程的求解
&lt;ol&gt;
&lt;li&gt;可分离变量型微分方程&lt;/li&gt;
&lt;li&gt;齐次型微分方程&lt;/li&gt;
&lt;li&gt;一阶线性微分方程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;伯努利方程&lt;/strong&gt;（欠掌握）&lt;/li&gt;
&lt;li&gt;二阶可降阶微分方程&lt;/li&gt;
&lt;li&gt;全微分方程&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;高阶线性微分方程的求解
&lt;ol&gt;
&lt;li&gt;二阶常系数齐次线性微分方程&lt;/li&gt;
&lt;li&gt;二阶常系数非齐次线性微分方程
&lt;ol&gt;
&lt;li&gt;待定系数法&lt;/li&gt;
&lt;li&gt;微分算子法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;n阶常系数齐次线性微分方程&lt;/li&gt;
&lt;li&gt;欧拉方程&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;微分方程的几何应用&lt;/li&gt;
&lt;li&gt;微分方程的物理应用&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;矩阵&#34;&gt;矩阵
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;矩阵的本质&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;n维向量空间种的一个基可表达所有信息&lt;/li&gt;
&lt;li&gt;矩阵信息表达中的关系
&lt;ul&gt;
&lt;li&gt;Gram矩阵&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;矩阵的定义及其基本运算&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;矩阵的定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;矩阵的基本运算&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;相等&lt;/li&gt;
&lt;li&gt;加法&lt;/li&gt;
&lt;li&gt;数乘矩阵&lt;/li&gt;
&lt;li&gt;乘法&lt;/li&gt;
&lt;li&gt;转置矩阵&lt;/li&gt;
&lt;li&gt;方阵的幂&lt;/li&gt;
&lt;li&gt;方阵的行列式&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;矩阵的逆&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;逆矩阵的定义&lt;/li&gt;
&lt;li&gt;逆矩阵的性质与重要公式&lt;/li&gt;
&lt;li&gt;用定义法求可逆矩阵的逆矩阵&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;伴随矩阵&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;性质与重要公式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用伴随矩阵求可逆矩阵的逆矩阵
&lt;/p&gt;
$$
      A^{-1} = \frac{1}{|A|}A^*
      $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;求伴随矩阵的方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初等变换与初等矩阵&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初等变换&lt;/li&gt;
&lt;li&gt;初等矩阵的定义&lt;/li&gt;
&lt;li&gt;初等矩阵的性质与重要公式&lt;/li&gt;
&lt;li&gt;用初等变换求逆矩阵的方法&lt;/li&gt;
&lt;li&gt;行阶梯型矩阵与行最简梯形矩阵&lt;/li&gt;
&lt;li&gt;简单分块矩阵的逆&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;矩阵方程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等价矩阵和矩阵的等价标准型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;矩阵的秩&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;求法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有关秩的重要式子
&lt;/p&gt;
$$
      0\leq r(A)\leq \min\{m,n\}
      $$$$
      r(kA) = r(A)(k\neq0)
      $$$$
      r(AB)\leq\min\{r(A),r(B)\}
      $$$$
      r(A+B)\leq r(A) + r(B)
      $$&lt;p&gt;$$
r(A)=\begin{cases}
n,r(A)=n\
1,r(A)=n-1\
0,r(A)&amp;lt;n-1&lt;/p&gt;
&lt;p&gt;\end{cases}
$$&lt;/p&gt;
$$
      r(A) = r(PA) = r(AQ) = r(PAQ)
      $$&lt;p&gt;这里$P$，$Q$为可逆矩阵
&lt;/p&gt;
$$
      A_{m\times n}B_{n\times s} = O \Rightarrow r(A) + r(B) \leq n
      $$$$
      r(A) = r(A^T) = r(AA^T)=r(A^TA)
      $$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;马克思主义&#34;&gt;马克思主义
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;矛盾的同一性与斗争性及其在事物发展中的作用
&lt;ol&gt;
&lt;li&gt;含义&lt;/li&gt;
&lt;li&gt;两种基本属性
&lt;ol&gt;
&lt;li&gt;同一性&lt;/li&gt;
&lt;li&gt;斗争性&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;矛盾的同一性和斗争性的辩证关系&lt;/li&gt;
&lt;li&gt;矛盾是事物发展的动力&lt;/li&gt;
&lt;li&gt;矛盾的同一性和斗争性辩证关系原理的方法论意义&lt;/li&gt;
&lt;li&gt;运用矛盾的同一性和斗争性辩证关系原理指导实践需要把握的两个问题&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;矛盾的普遍性和特殊性及其相互关系
&lt;ol&gt;
&lt;li&gt;矛盾的普遍性和特殊性的含义&lt;/li&gt;
&lt;li&gt;矛盾的不平衡性：主要矛盾和次要矛盾、矛盾的主要方面和次要方面
&lt;ol&gt;
&lt;li&gt;含义&lt;/li&gt;
&lt;li&gt;方法论意义&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;矛盾的普遍性和特殊性的辩证统一关系&lt;/li&gt;
&lt;li&gt;矛盾的普遍性和特殊性辩证关系原理的意义&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;量变质变规律
&lt;ol&gt;
&lt;li&gt;质、量、度的含义&lt;/li&gt;
&lt;li&gt;量变和质变的含义及其辩证关系
&lt;ol&gt;
&lt;li&gt;含义&lt;/li&gt;
&lt;li&gt;辩证关系&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;量变质变规律的方法论意义&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0918学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0918/</link>
        <pubDate>Thu, 18 Sep 2025 19:43:20 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0918/</guid>
        <description>&lt;h2 id=&#34;计算机网络&#34;&gt;计算机网络
&lt;/h2&gt;&lt;h3 id=&#34;移动ip&#34;&gt;移动IP
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;移动IP的概念
&lt;ol&gt;
&lt;li&gt;移动结点&lt;/li&gt;
&lt;li&gt;本地代理&lt;/li&gt;
&lt;li&gt;外地代理&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;移动IP通信过程&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;网络层设备&#34;&gt;网络层设备
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;冲突域和广播域
&lt;ol&gt;
&lt;li&gt;冲突域&lt;/li&gt;
&lt;li&gt;广播域&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;路由器的组成和功能
&lt;ol&gt;
&lt;li&gt;路由选择（控制部分）&lt;/li&gt;
&lt;li&gt;分组转发（交换组织）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;路由表与分组转发
&lt;ol&gt;
&lt;li&gt;路由表
&lt;ul&gt;
&lt;li&gt;目的网络IP地址&lt;/li&gt;
&lt;li&gt;子网掩码&lt;/li&gt;
&lt;li&gt;下一跳IP地址&lt;/li&gt;
&lt;li&gt;接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;转发表
&lt;ul&gt;
&lt;li&gt;目的站&lt;/li&gt;
&lt;li&gt;下一跳&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0917学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0917/</link>
        <pubDate>Wed, 17 Sep 2025 23:42:21 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0917/</guid>
        <description>&lt;h2 id=&#34;计算机网络&#34;&gt;计算机网络
&lt;/h2&gt;&lt;h3 id=&#34;ipv6&#34;&gt;IPv6
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;IPv6的特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更大的地址空间&lt;/li&gt;
&lt;li&gt;扩展的地址层次结构&lt;/li&gt;
&lt;li&gt;灵活的首部格式&lt;/li&gt;
&lt;li&gt;改进的选项&lt;/li&gt;
&lt;li&gt;允许协议继续扩充&lt;/li&gt;
&lt;li&gt;支持即插即用&lt;/li&gt;
&lt;li&gt;支持资源的预分配&lt;/li&gt;
&lt;li&gt;IPv6只有源主机才能分片&lt;/li&gt;
&lt;li&gt;IPv6首部长度是固定的40B&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IPv6数据报的基本首部&lt;/p&gt;
&lt;p&gt;IPv6数据报的基本格式&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;基本首部（40B）&lt;/th&gt;
          &lt;th&gt;有效载荷&lt;/th&gt;
          &lt;th&gt;有效载荷&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;扩展首部1&amp;hellip;N&lt;/td&gt;
          &lt;td&gt;数据部分&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;IPv6基本首部的基本格式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;（0-3，4b）版本&lt;/li&gt;
&lt;li&gt;（4-11，8b）通信量类，用来区分不同的Ipv6数据报的类别和优先级&lt;/li&gt;
&lt;li&gt;（12-31，20b）流标号&lt;/li&gt;
&lt;li&gt;（32-47，16b）有效载荷长度，单位字节&lt;/li&gt;
&lt;li&gt;（48-55，8b）下一个首部，如果有扩展首部，此处标识第一个扩展首部的类型&lt;/li&gt;
&lt;li&gt;（56-63，8b）跳数限制&lt;/li&gt;
&lt;li&gt;（64-191，128b）源地址&lt;/li&gt;
&lt;li&gt;（192-320，128b）目的地址&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IPv6地址&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单播&lt;/li&gt;
&lt;li&gt;多播&lt;/li&gt;
&lt;li&gt;任播&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;地址类型&lt;/th&gt;
          &lt;th&gt;二进制前缀&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;未指明地址&lt;/td&gt;
          &lt;td&gt;::/128&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;环回地址&lt;/td&gt;
          &lt;td&gt;::1/128&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;多播地址&lt;/td&gt;
          &lt;td&gt;FF00::/8(1111 1111)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;本地链路单播地址&lt;/td&gt;
          &lt;td&gt;FE80::/10(1111 1111 10)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;全球单播地址&lt;/td&gt;
          &lt;td&gt;除上述以外的所有IPv6地址&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从IPv4到IPv6过渡&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;路由算法与路由协议&#34;&gt;路由算法与路由协议
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;路由算法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;静态路由与动态路由&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态路由算法。&lt;/li&gt;
&lt;li&gt;动态路由算法。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;距离-向量路由算法（如RIP算法）&lt;/p&gt;
&lt;p&gt;每个结点x维护下列路由信息：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从x到每个直接相连邻居v的链路信息&lt;/li&gt;
&lt;li&gt;结点x的距离向量，即x到网络中其他结点的费用。&lt;/li&gt;
&lt;li&gt;它收到的每个邻居的距离向量，即x的每个邻居到网络中其它结点的费用。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链路状态路由算法（如OSPF算法）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分层次的路由选择算法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内部网关协议IGP
&lt;ol&gt;
&lt;li&gt;RIP&lt;/li&gt;
&lt;li&gt;OSPF&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;外部网关协议EGP
&lt;ol&gt;
&lt;li&gt;BGP-4&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路由信息协议（Routing Information Protocol）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;RIP的规定&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个路由器维护&lt;strong&gt;距离向量&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;条数&lt;/strong&gt;作为距离&lt;/li&gt;
&lt;li&gt;RIP认为好的路由就是它通过的路由器数目少&lt;/li&gt;
&lt;li&gt;RIP允许一条路径最多只能包含15个路由器，因此距离等于16时表示网络不可达。&lt;/li&gt;
&lt;li&gt;每个路由表项有三个关键字段：&amp;lt;目的网络N，距离d，下一条路由器地址X&amp;gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RIP的特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仅和直接相邻的路由器交换信息&lt;/li&gt;
&lt;li&gt;交换的信息是本路由器所知道的全部信息&lt;/li&gt;
&lt;li&gt;按固定的时间间隔交换路由信息&lt;/li&gt;
&lt;li&gt;应用层协议，在传输层使用UDP&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RIP的距离向量算法&lt;/p&gt;
&lt;p&gt;对每个相邻路由器X发来的RIP报文，执行如下步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改下一跳路由器地址为X，并且把所有距离字段+1&lt;/li&gt;
&lt;li&gt;对于原表没有的目的网络表项，添加到自己的表中&lt;/li&gt;
&lt;li&gt;对于原表有的目的网络表项，且下一跳为X的，更新替换&lt;/li&gt;
&lt;li&gt;对于原表有的目的网络表项，且下一跳不为X的，选择跳数更小的&lt;/li&gt;
&lt;li&gt;若180s（RIP默认超时时间）还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达状态，距离设置为16&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RIP的优缺点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现简单，开销较小&lt;/li&gt;
&lt;li&gt;若有一个路由器发现了更短的路由，则这种消息就传播的很快&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;RIP限制了网络规模，它能使用的最大距离15&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路由器之间交换的是完整的路由表，规模越大开销越大&lt;/p&gt;
&lt;p&gt;当网络出现故障时，路由器之间需反复多次交换信息才能完成收敛，要经过较长时间才能将故障消息传送到所有路由器”坏消息传得慢“&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开放最短路径优先协议（OSPF）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基本特点
&lt;ol&gt;
&lt;li&gt;OSPF向本自治系统中的所有路由器发送信息。&lt;/li&gt;
&lt;li&gt;发送的信息是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分，&lt;/li&gt;
&lt;li&gt;只有当链路状态发生变化的时，路由器才用洪泛法向所有路由器发送此信息&lt;/li&gt;
&lt;li&gt;OSPF是网络层协议，直接使用IP数据报传送&lt;/li&gt;
&lt;li&gt;OSPF允许对每条路由器设置成不同的代价。&lt;/li&gt;
&lt;li&gt;若同一个目的网络有多条相同代价的路径，则可将通信量分配给这几条路径&lt;/li&gt;
&lt;li&gt;OSPF分组具有鉴别的功能，从而保证仅在可信赖的路由器之间交换链路状态信息。&lt;/li&gt;
&lt;li&gt;OSPF支持可变长度的子网划分和无分类编址CIDR&lt;/li&gt;
&lt;li&gt;每个链路状态都带上一个32位的序号，序号越大状态越新&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;基本工作原理&lt;/li&gt;
&lt;li&gt;OSPF的五种分组类型
&lt;ol&gt;
&lt;li&gt;问候分组，用来发现和维持邻站的可达性&lt;/li&gt;
&lt;li&gt;数据库描述分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息&lt;/li&gt;
&lt;li&gt;链路状态请求分组，向对方请求发送某些链路状态项目的详细信息。&lt;/li&gt;
&lt;li&gt;链路状态更新分组，用洪泛法对全网更新链路状态&lt;/li&gt;
&lt;li&gt;链路状态确认分组，对链路更新分组进行确认&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;边界网关协议（BGP）（TCP协议）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置BGP时。每个AS的管理员要选择至少一个路由器，作为该AS的”BGP发言人“，BGP发言人往往就是BGP边界路由器&lt;/li&gt;
&lt;li&gt;一个BGP发言人与其他AS中的BGP发言人要交换路由信息，就要先建立TCP连接，然后在此连接上交换BGP报文以建立BGP会话，再利用BGP会话交换路由信息。&lt;/li&gt;
&lt;li&gt;BGP所交换的网络可达性的信息，就是要到达某个网络所经过的一系列自治系统。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;BGP-4一共使用4种报文、&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开（Open）报文。建立关系，通信初始化。&lt;/li&gt;
&lt;li&gt;更新（Update）报文。用来通知某一路由的信息，以及列出要撤销的多条路由&lt;/li&gt;
&lt;li&gt;保活（Keepalive）报文。用来周期性地证实邻站的连通性。&lt;/li&gt;
&lt;li&gt;通知（Notification）报文。用来发送检测到的差错。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;ip多播&#34;&gt;IP多播
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;多播的概念&lt;/li&gt;
&lt;li&gt;IP多播地址&lt;/li&gt;
&lt;li&gt;在局域网上进行硬件多播&lt;/li&gt;
&lt;li&gt;IGMP与多播路由协议&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0916学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0916/</link>
        <pubDate>Tue, 16 Sep 2025 23:42:18 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0916/</guid>
        <description>&lt;h2 id=&#34;计算机网络-网络层&#34;&gt;计算机网络-网络层
&lt;/h2&gt;&lt;h3 id=&#34;网络层的功能&#34;&gt;网络层的功能
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;异构网络直连&lt;/li&gt;
&lt;li&gt;路由与转发
&lt;ol&gt;
&lt;li&gt;路由选择&lt;/li&gt;
&lt;li&gt;分组转发&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;网络层提供的两种服务
&lt;ol&gt;
&lt;li&gt;虚电路&lt;/li&gt;
&lt;li&gt;数据报&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;SDN（软件定义网络）&lt;/li&gt;
&lt;li&gt;拥塞控制&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;ipv4&#34;&gt;IPv4
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;IPv4分组&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;格式
&lt;ol&gt;
&lt;li&gt;（0-3，4b）版本&lt;/li&gt;
&lt;li&gt;（4-7，4b）首部长度：4B为单位&lt;/li&gt;
&lt;li&gt;（8-15，8b）区分服务&lt;/li&gt;
&lt;li&gt;（16-31，16b）总长度&lt;/li&gt;
&lt;li&gt;（32-47，16b）标识&lt;/li&gt;
&lt;li&gt;（48-51，4b）标志&lt;/li&gt;
&lt;li&gt;（52-63，12b）片位移：8B为单位&lt;/li&gt;
&lt;li&gt;（64-71，8b）生存时间TTL&lt;/li&gt;
&lt;li&gt;（72-79，8b）协议&lt;/li&gt;
&lt;li&gt;（80-95，16b）首部校验和&lt;/li&gt;
&lt;li&gt;（96-127，4B）源IP地址&lt;/li&gt;
&lt;li&gt;（128-159，4B）目的IP地址&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;IP数据报分片&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IPv4地址与NAT&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;IPv4地址&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A类
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;网络号&lt;/th&gt;
          &lt;th&gt;主机号&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;8bit(0xxx xxxx, 01H - FEH)&lt;/td&gt;
          &lt;td&gt;24bit(00 00 01H-FF FF FEH,00 00 00H为网络地址,FF FF FF为广播地址)&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;B类
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;网络号&lt;/th&gt;
          &lt;th&gt;主机号&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;16bit(10xx xxxx xxxx xxxx,8000H-BFFFH)&lt;/td&gt;
          &lt;td&gt;16bit(00 01H-FF FEH)&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;C类
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;网络号&lt;/th&gt;
          &lt;th&gt;主机号&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;24bit(110x xxxx xxxx xxxx xxxx xxxx,C0 00 00H-DF FF FFH)&lt;/td&gt;
          &lt;td&gt;8bit(01H-FEH)&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;D类
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;1110&lt;/th&gt;
          &lt;th&gt;多播地址&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;E类
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;1111&lt;/th&gt;
          &lt;th&gt;保留为今后使用&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网络地址转换NAT&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;划分子网与路由聚合&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;划分子网&lt;/li&gt;
&lt;li&gt;子网掩码和默认网关&lt;/li&gt;
&lt;li&gt;无分类编址CIDR&lt;/li&gt;
&lt;li&gt;路由聚合&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网络层转发分组过程&lt;/p&gt;
&lt;p&gt;（目的网络地址，下一跳地址）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首部提取目的IP&lt;/li&gt;
&lt;li&gt;特定主机路由查询，命中转发否则继续执行3&lt;/li&gt;
&lt;li&gt;最长子网掩码匹配，命中转发否则继续执行4&lt;/li&gt;
&lt;li&gt;若存在默认路由，则转发至默认路由；否则，报告转发分组出错&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注：自始至终不会修改IP地址，而是修改MAC地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地址解析协议ARP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态主机配置协议DHCP（应用层协议）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DHCP客户广播”DHCP发现“消息，寻找网络中的DHCP服务器&lt;/li&gt;
&lt;li&gt;DHCP服务器收到”DHCP发现“，广播”DHCP提供“消息&lt;/li&gt;
&lt;li&gt;DHCP客户收到”DHCP提供“消息，若接受，广播”DHCP请求“&lt;/li&gt;
&lt;li&gt;DHCP服务器广播”DHCP确认“消息，将IP地址分配给DHCP客户&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网际控制报文协议ICMP&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;ICMP差错报告报文&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;终点不可达&lt;/li&gt;
&lt;li&gt;源点抑制&lt;/li&gt;
&lt;li&gt;时间超过&lt;/li&gt;
&lt;li&gt;参数问题&lt;/li&gt;
&lt;li&gt;改变路由&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以下情况不发送差错报告报文&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对ICMP差错报告报文&lt;/li&gt;
&lt;li&gt;对第一个分片的数据报片的所有后续数据报片&lt;/li&gt;
&lt;li&gt;对就有多播地址的数据报&lt;/li&gt;
&lt;li&gt;特殊地址&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0915学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0915/</link>
        <pubDate>Mon, 15 Sep 2025 23:42:14 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0915/</guid>
        <description>&lt;h2 id=&#34;计算机网络&#34;&gt;计算机网络
&lt;/h2&gt;&lt;h3 id=&#34;局域网&#34;&gt;局域网
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;局域网的基本概念和体系结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要特点：
&lt;ol&gt;
&lt;li&gt;为一个单位所拥有，其地理范围和站点数量均有限&lt;/li&gt;
&lt;li&gt;所有站点共享较高的总带宽&lt;/li&gt;
&lt;li&gt;较低的时延和较低的误码率&lt;/li&gt;
&lt;li&gt;各站点为平等关系而非主从关系&lt;/li&gt;
&lt;li&gt;能进行广播和多播&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;三种特殊的局域网拓扑
&lt;ol&gt;
&lt;li&gt;以太网&lt;/li&gt;
&lt;li&gt;令牌环(Token Ring)&lt;/li&gt;
&lt;li&gt;FDDI：逻辑拓扑环形结构，物理拓扑是双环结构&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以太网与IEEE 802.3&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DIX Ethernet V2&lt;/li&gt;
&lt;li&gt;IEEE 802.3&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;以太网的传输介质与网卡&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;标准名称&lt;/th&gt;
          &lt;th&gt;10BASE5&lt;/th&gt;
          &lt;th&gt;10BASE2&lt;/th&gt;
          &lt;th&gt;10BASE-T&lt;/th&gt;
          &lt;th&gt;10BASE-F&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;传输介质&lt;/td&gt;
          &lt;td&gt;同轴电缆（粗缆）&lt;/td&gt;
          &lt;td&gt;同轴电缆（细缆）&lt;/td&gt;
          &lt;td&gt;非屏蔽双绞线&lt;/td&gt;
          &lt;td&gt;光线对（850mm）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;编码&lt;/td&gt;
          &lt;td&gt;曼彻斯特编码&lt;/td&gt;
          &lt;td&gt;曼彻斯特编码&lt;/td&gt;
          &lt;td&gt;曼彻斯特编码&lt;/td&gt;
          &lt;td&gt;曼彻斯特编码&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;拓扑结构&lt;/td&gt;
          &lt;td&gt;总线型&lt;/td&gt;
          &lt;td&gt;总线型&lt;/td&gt;
          &lt;td&gt;星形&lt;/td&gt;
          &lt;td&gt;点对点&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;最大段长&lt;/td&gt;
          &lt;td&gt;500m&lt;/td&gt;
          &lt;td&gt;185m&lt;/td&gt;
          &lt;td&gt;100m&lt;/td&gt;
          &lt;td&gt;2000m&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;最多节点数目&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
          &lt;td&gt;30&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以太网的MAC地址：6字节，具体分配方式如下表&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;厂商代码&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;自行分配的适配器编号&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;高24位&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;低24位&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;单播帧&lt;/li&gt;
&lt;li&gt;广播帧&lt;/li&gt;
&lt;li&gt;多播帧&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MAC帧的首部：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;（6字节）目的MAC地址&lt;/li&gt;
&lt;li&gt;（6字节）源MAC地址&lt;/li&gt;
&lt;li&gt;（2字节）类型：交付上层协议&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;MAC帧的尾部：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;（四字节）FCS：校验码&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IEEE 802.11 无线局域网&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;无线局域网的组成&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有固定基础设施无线局域网&lt;/li&gt;
&lt;li&gt;无固定基础设施无线局域网：自组网络（ad hoc network）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;802.11 局域网的MAC帧&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;（30字节）MAC首部&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;MAC首部组成部分（按序）&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;字节数&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;帧控制&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;持续期&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;地址1 （接收地址）&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;6&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;地址2 （发送地址）&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;6&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;地址3  （视情况而定）&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;6&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;序号控制&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;地址4&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;6&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;帧控制组成部分&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;bit位数&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;协议版本&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;类型&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;子类型&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;3&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;去往AP&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;来自AP&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;更多分片&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;重试&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;功率管理&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;更多数据&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;WEP&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;顺序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;去往AP&lt;/th&gt;
          &lt;th&gt;来自AP&lt;/th&gt;
          &lt;th&gt;地址1&lt;/th&gt;
          &lt;th&gt;地址2&lt;/th&gt;
          &lt;th&gt;地址3&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;接收地址=AP地址&lt;/td&gt;
          &lt;td&gt;发送地址=源地址&lt;/td&gt;
          &lt;td&gt;目的地址&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;接收地址=目的地址&lt;/td&gt;
          &lt;td&gt;发送地址=AP地址&lt;/td&gt;
          &lt;td&gt;源地址&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;帧主体&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（4字节）FCS帧校验序列&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VLAN基本概念与基本原理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;802.1Q帧
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;目的地址&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;源地址&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;VLAN标签&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;类型&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;数据&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;FCS&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;6B&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;6B&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;4B&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2B&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;46B-1500B&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;4B&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;广域网&#34;&gt;广域网
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本概念&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PPP协议（点对点链路控制协议）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户需要连接到某个ISP&lt;/li&gt;
&lt;li&gt;广域网路由器之间的专用线路&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;LCP：链路控制协议&lt;/li&gt;
&lt;li&gt;NCP：网络控制协议&lt;/li&gt;
&lt;li&gt;一种将IP数据报封装到串行链路的方法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数据链路层设备&#34;&gt;数据链路层设备
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;网桥&lt;/li&gt;
&lt;li&gt;以太网交换机
&lt;ol&gt;
&lt;li&gt;原理和特点&lt;/li&gt;
&lt;li&gt;自学习功能&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;共享式以太网和交换式以太网的对比
&lt;ul&gt;
&lt;li&gt;集线器不隔离广播域、冲突域&lt;/li&gt;
&lt;li&gt;交换机不隔离广播域、隔离冲突域&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​   &lt;br&gt;
​&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0914学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0914/</link>
        <pubDate>Sun, 14 Sep 2025 23:42:11 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0914/</guid>
        <description>&lt;h2 id=&#34;计算机网络-数据链路层&#34;&gt;计算机网络-数据链路层
&lt;/h2&gt;&lt;h3 id=&#34;数据链路层的功能&#34;&gt;数据链路层的功能
&lt;/h3&gt;&lt;p&gt;基本问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;封装成帧&lt;/li&gt;
&lt;li&gt;透明传输&lt;/li&gt;
&lt;li&gt;差错检测&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;信道：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点对点信道&lt;/li&gt;
&lt;li&gt;广播信道&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;数据链路层所处的地位&lt;/li&gt;
&lt;li&gt;基本概念
&lt;ol&gt;
&lt;li&gt;链路&lt;/li&gt;
&lt;li&gt;数据链路&lt;/li&gt;
&lt;li&gt;帧&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;为网络层提供服务&lt;/li&gt;
&lt;li&gt;链路管理&lt;/li&gt;
&lt;li&gt;封装成帧与透明传输&lt;/li&gt;
&lt;li&gt;流量控制&lt;/li&gt;
&lt;li&gt;差错检测
&lt;ul&gt;
&lt;li&gt;位错&lt;/li&gt;
&lt;li&gt;帧错&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;组帧&#34;&gt;组帧
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;字符计数法 首部添加字节数&lt;/li&gt;
&lt;li&gt;字节填充法
&lt;ul&gt;
&lt;li&gt;SOH 最前面&lt;/li&gt;
&lt;li&gt;EOT 帧结束&lt;/li&gt;
&lt;li&gt;特殊字符 使用ESC 转义字符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;零比特填充法&lt;/li&gt;
&lt;li&gt;违规编码法&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;差错控制&#34;&gt;差错控制
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;检错编码
&lt;ol&gt;
&lt;li&gt;奇偶校验&lt;/li&gt;
&lt;li&gt;循环冗余码CRC&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;纠错编码
&lt;ul&gt;
&lt;li&gt;海明码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;流量控制与可靠传输机制&#34;&gt;流量控制与可靠传输机制
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;流量控制与滑动窗口机制&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;停止-等待流量控制基本原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;滑动窗口流量控制基本原理&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;协议&lt;/th&gt;
          &lt;th&gt;发送窗口$W_T$&lt;/th&gt;
          &lt;th&gt;接收窗口$W_R$&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;停止-等待协议&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;后退N帧协议&lt;/td&gt;
          &lt;td&gt;$&amp;gt;1$&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;选择重传协议&lt;/td&gt;
          &lt;td&gt;$&amp;gt;1$&lt;/td&gt;
          &lt;td&gt;$&amp;gt;1$&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;若采用n比特对帧编号，则后两种滑动窗口协议还需满足$W_T+W_R\leq 2^n$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可靠传输机制&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;单帧滑动窗口与停止-等待协议(S-W)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多帧滑动窗口与后退N帧协议(GBN)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多帧滑动窗口与选择重传协议(SR)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信道利用率分析&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;停止等待（$T_D$分组发送时延，$T_A$确认发送时延）
&lt;/p&gt;
$$
         U=\frac{T_D}{T_D+ RTT+T_A}
         $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连续ARQ协议的新年到利用率&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$nT_D&amp;lt;T_D+RTT+R_A$:
&lt;/p&gt;
$$
            U=\frac{nT_D}{T_D+ RTT+T_A}
            $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;否则：
&lt;/p&gt;
$$
            1
            $$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;介质访问控制&#34;&gt;介质访问控制
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;信道划分介质访问控制&lt;/li&gt;
&lt;li&gt;频分复用FDM&lt;/li&gt;
&lt;li&gt;时分复用TDM&lt;/li&gt;
&lt;li&gt;波分复用WDM&lt;/li&gt;
&lt;li&gt;码分复用CDM&lt;/li&gt;
&lt;li&gt;随机访问介质访问控制
&lt;ol&gt;
&lt;li&gt;ALOHA协议
&lt;ol&gt;
&lt;li&gt;纯ALOHA协议&lt;/li&gt;
&lt;li&gt;时隙ALOHA&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;CSMA协议（载波监听多路访问）
&lt;ol&gt;
&lt;li&gt;1-坚持CSMA&lt;/li&gt;
&lt;li&gt;非坚持CSMA&lt;/li&gt;
&lt;li&gt;p-坚持CSMA&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;CSMA/DA协议（载波监听多路访问/冲突检测）&lt;/li&gt;
&lt;li&gt;CSMA/CA协议&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;轮询访问：令牌传递协议&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0912 学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0912/</link>
        <pubDate>Sun, 14 Sep 2025 00:40:32 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0912/</guid>
        <description>&lt;h2 id=&#34;计算机网络&#34;&gt;计算机网络
&lt;/h2&gt;&lt;h3 id=&#34;计算机网络体系结构&#34;&gt;计算机网络体系结构
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;计算机网络的概念&lt;/li&gt;
&lt;li&gt;计算机网络的组成&lt;/li&gt;
&lt;li&gt;计算机网络的功能
&lt;ol&gt;
&lt;li&gt;数据通信&lt;/li&gt;
&lt;li&gt;资源共享&lt;/li&gt;
&lt;li&gt;分布式处理&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;电路交换&lt;/li&gt;
&lt;li&gt;报文交换&lt;/li&gt;
&lt;li&gt;分组交换&lt;/li&gt;
&lt;li&gt;计算机网络的分类
&lt;ol&gt;
&lt;li&gt;按分布范围分类
&lt;ul&gt;
&lt;li&gt;WAN&lt;/li&gt;
&lt;li&gt;MAN&lt;/li&gt;
&lt;li&gt;LAN&lt;/li&gt;
&lt;li&gt;PAN&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;按传输技术分类
&lt;ul&gt;
&lt;li&gt;广播式网络&lt;/li&gt;
&lt;li&gt;点对点网络&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;按拓扑结构分类
&lt;ol&gt;
&lt;li&gt;总线型网络&lt;/li&gt;
&lt;li&gt;星型网络&lt;/li&gt;
&lt;li&gt;环形网络&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;按使用者分类
&lt;ul&gt;
&lt;li&gt;公用网&lt;/li&gt;
&lt;li&gt;专用网&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;计算机网络的性能指标
&lt;ol&gt;
&lt;li&gt;速率&lt;/li&gt;
&lt;li&gt;带宽&lt;/li&gt;
&lt;li&gt;吞吐量&lt;/li&gt;
&lt;li&gt;时延
&lt;ol&gt;
&lt;li&gt;发送时延（传输时延）&lt;/li&gt;
&lt;li&gt;传播时延&lt;/li&gt;
&lt;li&gt;处理时延&lt;/li&gt;
&lt;li&gt;排队时延&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;时延带宽积&lt;/li&gt;
&lt;li&gt;往返时延&lt;/li&gt;
&lt;li&gt;信道利用率 = 有数据通过时间/（有 + 无数据通过时间）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;计算机网络体系结构与参考模型&#34;&gt;计算机网络体系结构与参考模型
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;计算机网络分层结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SDU 服务数据单元&lt;/li&gt;
&lt;li&gt;PCI 协议控制信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算机网络协议、接口、服务的概念&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;协议&lt;/p&gt;
&lt;p&gt;语法、语义、同步&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求&lt;/li&gt;
&lt;li&gt;指示&lt;/li&gt;
&lt;li&gt;响应&lt;/li&gt;
&lt;li&gt;证实&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;面向连接服务与无连接服务&lt;/li&gt;
&lt;li&gt;可靠服务和不可靠服务&lt;/li&gt;
&lt;li&gt;有应答服务和无应答服务&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ISO/OSI参考模型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用层&lt;/li&gt;
&lt;li&gt;表示层&lt;/li&gt;
&lt;li&gt;会话层&lt;/li&gt;
&lt;li&gt;传输层&lt;/li&gt;
&lt;li&gt;网络层&lt;/li&gt;
&lt;li&gt;数据链路层&lt;/li&gt;
&lt;li&gt;物理层&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP/IP模型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用层&lt;/li&gt;
&lt;li&gt;传输层&lt;/li&gt;
&lt;li&gt;网际层&lt;/li&gt;
&lt;li&gt;网络接口层&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;&#34;&gt;
&lt;/h3&gt;</description>
        </item>
        <item>
        <title>0913学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0913/</link>
        <pubDate>Sat, 13 Sep 2025 00:58:10 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0913/</guid>
        <description>&lt;h2 id=&#34;计算机网络物理层&#34;&gt;计算机网络&amp;ndash;物理层
&lt;/h2&gt;&lt;h3 id=&#34;通信概念&#34;&gt;通信概念
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本概念&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据、信号与码元&lt;/li&gt;
&lt;li&gt;信源、信道与信宿&lt;/li&gt;
&lt;li&gt;单向通信、半双工与全双工通信&lt;/li&gt;
&lt;li&gt;速率、波特与带宽
&lt;ol&gt;
&lt;li&gt;码元传输速率&lt;/li&gt;
&lt;li&gt;信息传输速率&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信道的极限容量&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;奈奎斯特定理（奈氏准测）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;理想低通信道下的极限码元传输速率
&lt;/p&gt;
$$
         2W
         $$&lt;p&gt;
对应的数据传输速率
&lt;/p&gt;
$$
         2W\log_2V
         $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;香农定理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;带宽受限且有高斯噪声干扰&lt;/strong&gt;的信道的极限数据传输速率
&lt;/p&gt;
$$
          W\log_2(1+\frac{S}{N})
         $$&lt;p&gt;
其中
&lt;/p&gt;
$$
         1dB = 10 \lg\frac{S}{N}
         $$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编码与调制&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数字数据编码为数字信号
&lt;ol&gt;
&lt;li&gt;不归零数据&lt;/li&gt;
&lt;li&gt;归零编码&lt;/li&gt;
&lt;li&gt;反向非归零编码&lt;/li&gt;
&lt;li&gt;曼彻斯特编码&lt;/li&gt;
&lt;li&gt;差分曼彻斯特编码&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;模拟数据编码为数字信号&lt;/li&gt;
&lt;li&gt;数字数据调制为模拟信号
&lt;ul&gt;
&lt;li&gt;调幅AM&lt;/li&gt;
&lt;li&gt;调频FM&lt;/li&gt;
&lt;li&gt;调相PM&lt;/li&gt;
&lt;li&gt;正交幅度调制QAM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;模拟数据调制为模拟信号&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;传输介质&#34;&gt;传输介质
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;传输介质
&lt;ol&gt;
&lt;li&gt;双绞线&lt;/li&gt;
&lt;li&gt;同轴电缆&lt;/li&gt;
&lt;li&gt;光纤&lt;/li&gt;
&lt;li&gt;无线传输介质&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;物理层接口的特性
&lt;ol&gt;
&lt;li&gt;机械特性&lt;/li&gt;
&lt;li&gt;电气特性&lt;/li&gt;
&lt;li&gt;功能特性&lt;/li&gt;
&lt;li&gt;过程特性&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;物理层设备
&lt;ol&gt;
&lt;li&gt;中继器&lt;/li&gt;
&lt;li&gt;集线器（Hub）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0911学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0911/</link>
        <pubDate>Thu, 11 Sep 2025 23:08:39 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0911/</guid>
        <description>&lt;h2 id=&#34;计算机组成原理-输入输出系统&#34;&gt;计算机组成原理-输入输出系统
&lt;/h2&gt;&lt;h3 id=&#34;io接口&#34;&gt;IO接口
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;IO接口的功能
&lt;ol&gt;
&lt;li&gt;进行地址译码和设备选择&lt;/li&gt;
&lt;li&gt;实现主机和外设的通信联络控制&lt;/li&gt;
&lt;li&gt;实现数据缓冲&lt;/li&gt;
&lt;li&gt;信号格式的转换&lt;/li&gt;
&lt;li&gt;传送控制命令和状态信息&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;IO接口的基本结构&lt;/li&gt;
&lt;li&gt;IO接口的类型
&lt;ol&gt;
&lt;li&gt;按数据传送方式：并行接口、串行接口&lt;/li&gt;
&lt;li&gt;按主机访问IO设备的控制方式：程序查询接口、终端接口和DMA接口&lt;/li&gt;
&lt;li&gt;功能选择的灵活性：可编程接口、不可编程接口&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;IO端口及编址
&lt;ol&gt;
&lt;li&gt;独立编址&lt;/li&gt;
&lt;li&gt;统一编址&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;io方式&#34;&gt;IO方式
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;程序查询方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;独占查询&lt;/li&gt;
&lt;li&gt;定时查询&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序中断方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基本概念&lt;/li&gt;
&lt;li&gt;工作流程流程
&lt;ol&gt;
&lt;li&gt;中断请求&lt;/li&gt;
&lt;li&gt;中断响应判优&lt;/li&gt;
&lt;li&gt;CPU响应中断的条件&lt;/li&gt;
&lt;li&gt;中断响应的过程
&lt;ol&gt;
&lt;li&gt;关中断&lt;/li&gt;
&lt;li&gt;保存断点&lt;/li&gt;
&lt;li&gt;引出中断服务程序&lt;/li&gt;
&lt;li&gt;中断向量&lt;/li&gt;
&lt;li&gt;中断处理过程
&lt;ol&gt;
&lt;li&gt;硬件完成：
&lt;ul&gt;
&lt;li&gt;关中断&lt;/li&gt;
&lt;li&gt;保存断点&lt;/li&gt;
&lt;li&gt;终端服务程序寻址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中断程序完成
&lt;ul&gt;
&lt;li&gt;保存现场和屏蔽字&lt;/li&gt;
&lt;li&gt;开中断&lt;/li&gt;
&lt;li&gt;执行终端服务程序&lt;/li&gt;
&lt;li&gt;关中断&lt;/li&gt;
&lt;li&gt;恢复现场和屏蔽字&lt;/li&gt;
&lt;li&gt;开中断&lt;/li&gt;
&lt;li&gt;中断返回&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多重中断和中断屏蔽技术&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;DMA方式
&lt;ol&gt;
&lt;li&gt;DMA方式的特点&lt;/li&gt;
&lt;li&gt;DMA控制器的组成
&lt;ul&gt;
&lt;li&gt;主存地址计数器&lt;/li&gt;
&lt;li&gt;传送长度计数器&lt;/li&gt;
&lt;li&gt;数据缓冲寄存器&lt;/li&gt;
&lt;li&gt;DMA请求触发器&lt;/li&gt;
&lt;li&gt;“控制/状态”逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DMA的传送方式
&lt;ol&gt;
&lt;li&gt;停止CPU访存&lt;/li&gt;
&lt;li&gt;周期挪用&lt;/li&gt;
&lt;li&gt;DMA与CPU交替访存&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;DMA的传送过程
&lt;ol&gt;
&lt;li&gt;预处理&lt;/li&gt;
&lt;li&gt;数据传送&lt;/li&gt;
&lt;li&gt;后处理&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;DMA方式和中断方式的区别&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;马克思主义原理&#34;&gt;马克思主义原理
&lt;/h2&gt;&lt;h3 id=&#34;第一节-世界的多样性与物质统一性&#34;&gt;第一节 世界的多样性与物质统一性
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;哲学基本问题及其内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;哲学的含义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哲学基本问题及其内容&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;内容&lt;/th&gt;
          &lt;th&gt;意义&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;物质和意识何者为第一性&lt;/td&gt;
          &lt;td&gt;划分唯物主义和唯心主义的标准&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;存在和思维有无同一性&lt;/td&gt;
          &lt;td&gt;这是划分可知论和不可知论&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;唯物主义和唯心主义、可知论和不可知论、辩证法和形而上学&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;唯物主义和唯心主义&lt;/li&gt;
&lt;li&gt;可知论和不可知论&lt;/li&gt;
&lt;li&gt;辩证法和形而上学
&lt;ol&gt;
&lt;li&gt;基本特征&lt;/li&gt;
&lt;li&gt;辩证法和形而上学的焦点&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;马克思主义的物质范畴及其理论意义&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;物质范畴在唯物主义哲学的理论基石&lt;/li&gt;
&lt;li&gt;唯物主义的三种形态
&lt;ol&gt;
&lt;li&gt;古代朴素唯物主义&lt;/li&gt;
&lt;li&gt;近代形而上学唯物主义&lt;/li&gt;
&lt;li&gt;现代辩证唯物主义&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;马克思主义物质观的理论意义&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;物质的根本属性和运动着的物质的基本形式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;物质的根本属性是运动
&lt;ol&gt;
&lt;li&gt;运动的含义&lt;/li&gt;
&lt;li&gt;物质和运动的关系&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;物质世界的运动是绝对的、静止是相对的
&lt;ol&gt;
&lt;li&gt;相对静止的含义&lt;/li&gt;
&lt;li&gt;运动和静止的辩证关系&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;时间和空间是运动者的物质的基本存在形式&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;物质世界的二重化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;物质与意识的辩证关系&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;物质对意识的决定作用
&lt;ol&gt;
&lt;li&gt;意识的含义&lt;/li&gt;
&lt;li&gt;物质对意识的决定作用&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;意识对物质具有反作用
&lt;ol&gt;
&lt;li&gt;意识具有目的性和计划性&lt;/li&gt;
&lt;li&gt;意识具有创造性&lt;/li&gt;
&lt;li&gt;意识具有指导实践改造客观世界的作用&lt;/li&gt;
&lt;li&gt;意识具有调控人的行为和生理活动的作用&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数学-多元函数微分学&#34;&gt;数学-多元函数微分学
&lt;/h2&gt;&lt;h3 id=&#34;基本概念&#34;&gt;基本概念
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;邻域&lt;/li&gt;
&lt;li&gt;极限&lt;/li&gt;
&lt;li&gt;连续&lt;/li&gt;
&lt;li&gt;偏导数
&lt;ol&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;li&gt;几何意义&lt;/li&gt;
&lt;li&gt;高阶偏导数&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;可微
&lt;ol&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;li&gt;可微的必要条件&lt;/li&gt;
&lt;li&gt;可微的充分条件&lt;/li&gt;
&lt;li&gt;可微的判断步骤】
&lt;ol&gt;
&lt;li&gt;全增量&lt;/li&gt;
&lt;li&gt;线性增量&lt;/li&gt;
&lt;li&gt;两者差取极限&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;多元函数微分法则&#34;&gt;多元函数微分法则
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;链式求导法则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全微分形式不变性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隐函数存在定理（公式法）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;隐函数存在定理一：
&lt;/p&gt;
$$
      \frac{dy}{dx} = -\frac{F_x&#39;(x,y)}{F_y&#39;(x,y)}
      $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隐函数存在定理二：
&lt;/p&gt;
$$
      \frac{\partial z}{\partial x}=-\frac{F_x&#39;(x,y,z)}{F_z&#39;(x,y,z)}
      $$$$
      \frac{\partial z}{\partial y}=-\frac{F_y&#39;(x,y,z)}{F_z&#39;(x,y,z)}
      $$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二元函数的拉格朗日定理&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定理&lt;/li&gt;
&lt;li&gt;注意事项&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;多元函数的极值与最值&#34;&gt;多元函数的极值与最值
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;概念&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;极大值点（极小值点）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无条件极值&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;二元函数取极值的必要条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一阶偏导存在&lt;/li&gt;
&lt;li&gt;取极值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二元函数取极值的充分条件&lt;/p&gt;
&lt;p&gt;记
&lt;/p&gt;
$$
      f_{xx}&#39;&#39;(x_0,y_0) = A
      $$$$
      f_{xy}&#39;&#39;(x_0,y_0) = B
      $$$$
      f_{yy}&#39;&#39;(x_0,y_0) = C
      $$$$
      \Delta = AC-B^2
      $$&lt;ol&gt;
&lt;li&gt;$\Delta &amp;gt;0$
&lt;ol&gt;
&lt;li&gt;$A&amp;lt;0$，极大值&lt;/li&gt;
&lt;li&gt;$A&amp;gt;0$，极小值&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;$\Delta &amp;lt;0$，非极值&lt;/li&gt;
&lt;li&gt;$\Delta = 0$，方法失效&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;条件极值与拉格朗日乘数法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最远（近）点的垂线定理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有界闭区域上连续函数的最值问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;理论依据&lt;/li&gt;
&lt;li&gt;求法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0910学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0910/</link>
        <pubDate>Wed, 10 Sep 2025 11:53:46 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0910/</guid>
        <description>&lt;h2 id=&#34;计算机网络&#34;&gt;计算机网络
&lt;/h2&gt;&lt;p&gt;PCI: protocol control information&lt;/p&gt;
&lt;p&gt;PDU:protocol data unit&lt;/p&gt;
&lt;p&gt;协议三要素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法&lt;/li&gt;
&lt;li&gt;语义&lt;/li&gt;
&lt;li&gt;同步。时序，时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OSI&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用层 （资源子网）http ftp smtp&lt;/li&gt;
&lt;li&gt;表示层（资源子网）&lt;/li&gt;
&lt;li&gt;会话层（资源子网）&lt;/li&gt;
&lt;li&gt;运输层&lt;/li&gt;
&lt;li&gt;网络层（通信子网）&lt;/li&gt;
&lt;li&gt;数据链路层（通信子网）&lt;/li&gt;
&lt;li&gt;物理层（通信子网）比特&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;物理层：透明传输比特流&lt;/p&gt;
&lt;p&gt;用什么电子信号表示1和0&lt;/p&gt;
&lt;p&gt;一个比特持续多长时间&lt;/p&gt;
&lt;p&gt;是否可以两个方向传输&lt;/p&gt;
&lt;p&gt;连接建立&lt;/p&gt;
&lt;p&gt;撤销链接&lt;/p&gt;
&lt;p&gt;用途&lt;/p&gt;
&lt;p&gt;机械电子时序接口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据链路层：将一个原始的传输线路变成一条没有传输错误的线路&lt;/p&gt;
&lt;p&gt;输入的数据拆分成数据帧，顺序发送数据帧PDU&lt;/p&gt;
&lt;p&gt;流量调节机制共享信道的访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网络层：主机间的路由选择，分组转发和网络的划分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络异构细节&lt;/li&gt;
&lt;li&gt;子网划分&lt;/li&gt;
&lt;li&gt;路由选择&lt;/li&gt;
&lt;li&gt;数据转发&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传输层：接受来自上一层的数据，在必要时的时候把这些数据分割成较小的单元&lt;/p&gt;
&lt;p&gt;UDPTCP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;会话层：允许不同机器上的用户建立会话&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对话控制&lt;/li&gt;
&lt;li&gt;令牌管理&lt;/li&gt;
&lt;li&gt;同步功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表示层：关注所传递信息的语法和语义*&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准的编码方法&lt;/li&gt;
&lt;li&gt;加密解密&lt;/li&gt;
&lt;li&gt;压缩解压&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用层：包含了用户通常需要的各种各样的协议&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;TCP/IP模型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用层：提供系统与用户的接口&lt;/li&gt;
&lt;li&gt;运输层&lt;/li&gt;
&lt;li&gt;网络层&lt;/li&gt;
&lt;li&gt;网络接口层&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0909学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0909/</link>
        <pubDate>Tue, 09 Sep 2025 10:56:39 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0909/</guid>
        <description>&lt;h2 id=&#34;计算机组成原理-总线&#34;&gt;计算机组成原理-总线
&lt;/h2&gt;&lt;h3 id=&#34;总线概述&#34;&gt;总线概述
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;总线基本概念&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;总线定义
&lt;ul&gt;
&lt;li&gt;分时和共享是总线的两个特点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;总线设备
&lt;ol&gt;
&lt;li&gt;主设备&lt;/li&gt;
&lt;li&gt;从设备&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;总线特性&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总线的分类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按功能层次分类
&lt;ol&gt;
&lt;li&gt;片内总线&lt;/li&gt;
&lt;li&gt;系统总线
&lt;ol&gt;
&lt;li&gt;数据总线&lt;/li&gt;
&lt;li&gt;地址总线&lt;/li&gt;
&lt;li&gt;控制总线&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;I/O总线&lt;/li&gt;
&lt;li&gt;通信总线&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;按时序控制方式分类
&lt;ol&gt;
&lt;li&gt;同步总线&lt;/li&gt;
&lt;li&gt;异步总线&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;按数据传输方式分类
&lt;ol&gt;
&lt;li&gt;串行总线&lt;/li&gt;
&lt;li&gt;并行总线&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统总线的结构&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;单总线&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：结构简单，成本低，易于接入新的设备&lt;/li&gt;
&lt;li&gt;缺点：带宽低、负载重，多个部件争用唯一的总线，且不支持开发传送操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双总线结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：将低速IO设备从原单线上分离出来，实现了存储器总线和IO总线分离&lt;/li&gt;
&lt;li&gt;缺点：需要增加通道等硬件设备&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三总线结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：提高了IO设备的性能，使其更快的响应命令，提高系统吞吐量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：任意时刻只能使用一种总线，系统工作效率降低&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总线的性能指标&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;总线时钟周期&lt;/li&gt;
&lt;li&gt;总线时钟频率&lt;/li&gt;
&lt;li&gt;总线传输周期：一次总线操作所需的时间，包括申请阶段、寻址阶段、传输阶段和结束阶段。通常由若干个时钟周期构成。&lt;/li&gt;
&lt;li&gt;总线工作频率&lt;/li&gt;
&lt;li&gt;总线宽度&lt;/li&gt;
&lt;li&gt;总线带宽&lt;/li&gt;
&lt;li&gt;总线复用&lt;/li&gt;
&lt;li&gt;信号线束&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总线最主要的性能指标为总线宽度、总线的工作频率，总线带宽&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;总线事物和定时&#34;&gt;总线事物和定时
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;总线事物&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;请求阶段。主设备（CPU或DMA）发出总线传输请求，并且获得总线控制权&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;仲裁阶段。主线仲裁机构决定将下一个传输周期的总线使用权授予某个申请者&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;寻址阶段。主设备通过总线给出要访问的从设备地址及有关命令，启动从模块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传输阶段。主模块和从模块进行数据交换，可单向或双向进行数据传输&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;释放阶段。主模块的有关信息均从系统总线上撤除，让出总线使用权。&lt;/p&gt;
&lt;p&gt;突发（猝发）能够进行连续成组数据的传送。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总线定时&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;同步定时方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：传送速度快，具有较高的传输速率；总线控制逻辑简单&lt;/li&gt;
&lt;li&gt;缺点：主从设备属于强制性同步；不能及时进行数据通信的有效性检验，可靠性差。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步定时方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠性地进行信息交换，自动适应时间的配合&lt;/li&gt;
&lt;li&gt;缺点：比同步控制方式稍复杂一些，速度比同步较慢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据”请求“和”回答“信号的撤销是否互锁，异步定时方式又分为7以下三种类型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不互锁方式&lt;/li&gt;
&lt;li&gt;半互锁方式&lt;/li&gt;
&lt;li&gt;全互锁方式&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;半同步定时方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：控制方式比异步定时简单，各模块在系统时钟的控制下同步工作，可靠性较高&lt;/li&gt;
&lt;li&gt;缺点：系统时钟频率不能要求太高，所以从整体上看，系统工作的速度不是很高。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分离式定时方式&lt;/p&gt;
&lt;p&gt;将总线事务分解为请求和应答两个子过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：在不传送数据时释放总线，使总线可接受其他设备的请求，不存在空闲等待时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：控制复杂，开销也大&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0908学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0908/</link>
        <pubDate>Tue, 09 Sep 2025 10:56:33 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0908/</guid>
        <description>&lt;h2 id=&#34;计算机组成原理&#34;&gt;计算机组成原理
&lt;/h2&gt;&lt;h3 id=&#34;指令流水线&#34;&gt;指令流水线
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;指令流水线的基本概念&lt;/p&gt;
&lt;p&gt;时间上的并行技术：流水线技术&lt;/p&gt;
&lt;p&gt;空间上的并行技术：超标量处理机&lt;/p&gt;
&lt;p&gt;假设一条指令的执行过程分为如下5个阶段（功能段或流水段）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取指（IF）：从指令存储器或Cache中取指令&lt;/li&gt;
&lt;li&gt;译码/读寄存器（ID）：操作控制器对指令进行译码，同时从寄存器堆中取操作数&lt;/li&gt;
&lt;li&gt;执行/计算地址（EX）：执行运算操作或计算地址&lt;/li&gt;
&lt;li&gt;访存（MEM）：对存储器进行读/写操作&lt;/li&gt;
&lt;li&gt;写回（WB）：将指令执行结果写回寄存器堆&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了利于实现指令流水线，指令集应具有如下特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指令长度应尽量一致，有利于简化取指令和指令译码操作。&lt;/li&gt;
&lt;li&gt;指令格式应尽量规整，尽量保证源寄存器的位置相同。&lt;/li&gt;
&lt;li&gt;采用LOAD/STORE型指令，其他指令不能访问存储器，这样可把LOAD/SZTORE指令的地址计算和运算指令的执行步骤规整在一个周期中。&lt;/li&gt;
&lt;li&gt;数据和指令在存储器中”按边界对齐“存放。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;流水线的基本实现&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;流水线设计的原则
&lt;ol&gt;
&lt;li&gt;指令流水段个数以最复杂指令所用的功能段个数为准&lt;/li&gt;
&lt;li&gt;流水段的长度以最复杂的操作所花的时间为准&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;流水线的逻辑结构&lt;/li&gt;
&lt;li&gt;流水线的时空图表示&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;流水线的冒险与处理&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;结构冒险&lt;/li&gt;
&lt;li&gt;数据冒险
&lt;ol&gt;
&lt;li&gt;RAW
&lt;ul&gt;
&lt;li&gt;延迟执行相关指令&lt;/li&gt;
&lt;li&gt;采用转发（旁路）技术&lt;/li&gt;
&lt;li&gt;load-use数据冒险处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;WAR&lt;/li&gt;
&lt;li&gt;WAW&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;控制冒险&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;流水线的性能指标&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;流水线的吞吐率（n是任务数，$T_k$是处理完n个任务所用的总时间，k为流水线的段数）
&lt;/p&gt;
$$
      TP = \frac{n}{T_k}
      $$&lt;p&gt;
$\Delta t$为时钟周期。在输入流水线中的任务连续的理想情况下，一条$k$段流水线能在$k+n-1$
&lt;/p&gt;
$$
      TP = \lim\limits_{n\to \infty} \frac{n}{(k+n-1)\Delta t} = \frac{1}{\Delta t}
      $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;流水线的加速比
&lt;/p&gt;
$$
      S = \frac{T_0}{T_k}
      $$&lt;p&gt;
一条k段流水线完成n个任务所需的时间为$T_k=(k+n-1)\Delta t$。顺序执行n个任务时,所需的总时间为 $T_0=kn\Delta t$
&lt;/p&gt;
$$
      S = \frac{kn\Delta t}{(k+n-1)\Delta t}
      $$$$
      S_{\lim\limits_{n\to \infty}} = k
      $$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高级流水线技术&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;超标量流水线技术（多发射技术）&lt;/li&gt;
&lt;li&gt;超长指令字技术&lt;/li&gt;
&lt;li&gt;超流水线技术&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;多处理器的基本概念&#34;&gt;多处理器的基本概念
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;SISD，SIMD，MIMD的基本概念
&lt;ol&gt;
&lt;li&gt;单指令流单数据流（SISD）结构&lt;/li&gt;
&lt;li&gt;单指令流多数据流（SIMD）结构&lt;/li&gt;
&lt;li&gt;多指令流单数据流（MISD）结构（不存在）&lt;/li&gt;
&lt;li&gt;多指令流多数据流（MIMD）结构&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;硬件多线程的基本概念
&lt;ol&gt;
&lt;li&gt;细粒度多线程&lt;/li&gt;
&lt;li&gt;粗粒度多线程&lt;/li&gt;
&lt;li&gt;同时多线程&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;多核处理器的基本概念&lt;/li&gt;
&lt;li&gt;共享内存多处理器的基本概念
&lt;ul&gt;
&lt;li&gt;统一存储访问（UMA）多处理器&lt;/li&gt;
&lt;li&gt;非统一存储访问（NUMA）多处理器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0907学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0907/</link>
        <pubDate>Sun, 07 Sep 2025 23:32:48 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0907/</guid>
        <description>&lt;h2 id=&#34;计算机组成原理-中央处理器&#34;&gt;计算机组成原理-中央处理器
&lt;/h2&gt;&lt;h3 id=&#34;cpu的功能和基本结构&#34;&gt;CPU的功能和基本结构
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;CPU的功能
&lt;ol&gt;
&lt;li&gt;指令控制：取指令、分析指令和执行指令&lt;/li&gt;
&lt;li&gt;操作控制&lt;/li&gt;
&lt;li&gt;时间控制&lt;/li&gt;
&lt;li&gt;数据加工&lt;/li&gt;
&lt;li&gt;中断处理&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;CPU的基本结构
&lt;ol&gt;
&lt;li&gt;运算器
&lt;ul&gt;
&lt;li&gt;ALU&lt;/li&gt;
&lt;li&gt;暂存寄存器&lt;/li&gt;
&lt;li&gt;累加寄存器ACC&lt;/li&gt;
&lt;li&gt;通用寄存器GPRs&lt;/li&gt;
&lt;li&gt;程序状态字寄存器PSW&lt;/li&gt;
&lt;li&gt;移位寄存器&lt;/li&gt;
&lt;li&gt;计数器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;控制器
&lt;ul&gt;
&lt;li&gt;PC&lt;/li&gt;
&lt;li&gt;指令寄存器IR&lt;/li&gt;
&lt;li&gt;指令译码器ID&lt;/li&gt;
&lt;li&gt;存储器地址寄存器MAR&lt;/li&gt;
&lt;li&gt;存储器数据寄存器MDR&lt;/li&gt;
&lt;li&gt;时序电路&lt;/li&gt;
&lt;li&gt;微操作信号发生器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;CPU的寄存器
&lt;ol&gt;
&lt;li&gt;运算器的寄存器
&lt;ol&gt;
&lt;li&gt;通用寄存器组GPRs&lt;/li&gt;
&lt;li&gt;累加从寄存器ACC&lt;/li&gt;
&lt;li&gt;移位寄存器SR&lt;/li&gt;
&lt;li&gt;暂存寄存器&lt;/li&gt;
&lt;li&gt;程序状态字寄存器PSW&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;控制器中的寄存器
&lt;ol&gt;
&lt;li&gt;程序计数器PC&lt;/li&gt;
&lt;li&gt;指令寄存器IR&lt;/li&gt;
&lt;li&gt;存储器地址寄存器MAR&lt;/li&gt;
&lt;li&gt;存储器数据寄存器MDR&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;指令执行过程&#34;&gt;指令执行过程
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;指令周期&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;定长的机器周期&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;取值周期&lt;/th&gt;
          &lt;th&gt;间址周期（取有效地址）&lt;/th&gt;
          &lt;th&gt;执行周期（执行指令）&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不定长的机器周期&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;取值周期&lt;/th&gt;
          &lt;th&gt;执行周期&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指令周期的数据流&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;取值周期&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PC - MAR - 地址总线 - 存储器&lt;/li&gt;
&lt;li&gt;CU 发出读命令 - 控制总线 - 存储器&lt;/li&gt;
&lt;li&gt;主存 - 数据总线 - MDR - IR&lt;/li&gt;
&lt;li&gt;CU 发出控制信号 - PC内容加1&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;间址周期&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Ad(IR)或MDR - MAR -  地址总线 - 存储器&lt;/li&gt;
&lt;li&gt;CU发出读命令 - 控制总线 - 存储器&lt;/li&gt;
&lt;li&gt;主存 - 数据总线 - MDR (EA)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行周期&lt;/p&gt;
&lt;p&gt;取操作数，根据IR中的指令字的操作码通过ALU操作产生执行结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中断周期&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CU 控制将SP-1(stack pointer)，SP - MAR - 地址总线-存储器&lt;/li&gt;
&lt;li&gt;CU 发出写命令 - 控制总线 - 存储器&lt;/li&gt;
&lt;li&gt;PC - MDR - 数据总线 - 主存 （程序断电存入存储器）&lt;/li&gt;
&lt;li&gt;CU （中断服务程序的入口地址）- PC&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指令执行方案&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;单周期处理器&lt;/p&gt;
&lt;p&gt;所有指令相同执行时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多周期处理器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;流水线处理器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数据通路的功能和基本结构&#34;&gt;数据通路的功能和基本结构
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;数据通路的功能&lt;/li&gt;
&lt;li&gt;数据通路的组成
&lt;ol&gt;
&lt;li&gt;组合逻辑元件（操作元件）&lt;/li&gt;
&lt;li&gt;时序逻辑元件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;数据通路的基本结构
&lt;ol&gt;
&lt;li&gt;CPU内部单总线方式&lt;/li&gt;
&lt;li&gt;CPU内部多总线方式&lt;/li&gt;
&lt;li&gt;专用数据通路方式&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;控制器的功能和工作原理&#34;&gt;控制器的功能和工作原理
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;控制器的结构和功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;硬布线控制器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微程序控制器&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;微程序控制的基本概念&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;微命令与微操作&lt;/li&gt;
&lt;li&gt;微指令与微周期&lt;/li&gt;
&lt;li&gt;主存储器与控制存储器&lt;/li&gt;
&lt;li&gt;程序与微程序&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微程序控制器的组成和工作过程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;微程序控制器的组成和工作过程&lt;/li&gt;
&lt;li&gt;微程序控制器的工作过程&lt;/li&gt;
&lt;li&gt;微程序和机器指令&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微指令的编码方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直接编码（直接控制）方式&lt;/li&gt;
&lt;li&gt;字段直接编码方式&lt;/li&gt;
&lt;li&gt;字段间接编码方式&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微指令的地址形成方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;微指令的后继地址字段（下地址字段）&lt;/li&gt;
&lt;li&gt;根据机器指令的操作码形成。&lt;/li&gt;
&lt;li&gt;增量计数器法&lt;/li&gt;
&lt;li&gt;根据各种标志决定下一条微指令分支转移的地址&lt;/li&gt;
&lt;li&gt;友硬件直接产生微程序入口地址。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微指令的格式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;水平型微指令&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;A1&lt;/th&gt;
          &lt;th&gt;A2&lt;/th&gt;
          &lt;th&gt;&amp;hellip;&lt;/th&gt;
          &lt;th&gt;An-1&lt;/th&gt;
          &lt;th&gt;An&lt;/th&gt;
          &lt;th&gt;判断测试字段&lt;/th&gt;
          &lt;th&gt;后继地址字段&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;操作控制&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;顺序控制&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;垂直型微指令&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;$\mu$OP&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;Rd&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;Rs&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;微操作码&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;目的地址&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;源地址&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;硬布线和微程序控制器的特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;硬布线控制器的特点&lt;/li&gt;
&lt;li&gt;微程序控制器的特点&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;异常和中断机制&#34;&gt;异常和中断机制
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;异常和中断的基本概念
&lt;ol&gt;
&lt;li&gt;异常：由CPU内部产生的意外事件。a.k.a内中断&lt;/li&gt;
&lt;li&gt;中断：由来自CPU外部的设备向CPU发出的中断请求。a.k.a外中断。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;异常和中断的分类
&lt;ol&gt;
&lt;li&gt;异常的分类
&lt;ol&gt;
&lt;li&gt;故障Fault&lt;/li&gt;
&lt;li&gt;自陷Trap&lt;/li&gt;
&lt;li&gt;终止Abort&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;中断的分类
&lt;ol&gt;
&lt;li&gt;可屏蔽中断&lt;/li&gt;
&lt;li&gt;不可屏蔽中断&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;异常和中断响应过程
&lt;ol&gt;
&lt;li&gt;关中断&lt;/li&gt;
&lt;li&gt;保存断点和程序状态&lt;/li&gt;
&lt;li&gt;识别异常和中断并转到相应的处理程序
&lt;ol&gt;
&lt;li&gt;软件识别方式：CPU设置一个异常状态寄存器&lt;/li&gt;
&lt;li&gt;硬件识别a.k.a向量中断&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0906学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0906/</link>
        <pubDate>Sun, 07 Sep 2025 23:32:42 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0906/</guid>
        <description>&lt;h2 id=&#34;计算机组成原理-死去的risc-v突然攻击我&#34;&gt;计算机组成原理-死去的RISC-V突然攻击我
&lt;/h2&gt;&lt;h3 id=&#34;程序的机器级代码表示&#34;&gt;程序的机器级代码表示
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;常用汇编指令介绍&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;相关寄存器&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;16bit&lt;/th&gt;
          &lt;th&gt;32bit&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;AX&lt;/td&gt;
          &lt;td&gt;EAX&lt;/td&gt;
          &lt;td&gt;累加器（Accumulator）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;BX&lt;/td&gt;
          &lt;td&gt;EBX&lt;/td&gt;
          &lt;td&gt;基地址寄存器(Base Register)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;CX&lt;/td&gt;
          &lt;td&gt;ECX&lt;/td&gt;
          &lt;td&gt;计数寄存器(Count Register)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;DX&lt;/td&gt;
          &lt;td&gt;EDX&lt;/td&gt;
          &lt;td&gt;数据寄存器(Data Register)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;ESI&lt;/td&gt;
          &lt;td&gt;变址寄存器(Index Register)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;EDI&lt;/td&gt;
          &lt;td&gt;变址寄存器(Index Register)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;EBP&lt;/td&gt;
          &lt;td&gt;堆栈基指针(Base Pointer)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;ESP&lt;/td&gt;
          &lt;td&gt;堆栈顶指针(Stack Pointer)&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;汇编指令格式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;AT&amp;amp;T 格式简介&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主要用于 &lt;strong&gt;GNU Assembler (GAS)&lt;/strong&gt;，即 &lt;code&gt;gcc&lt;/code&gt; 默认输出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;语法较“繁琐”，但严格、明确，容易让编译器处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特点：寄存器有 &lt;code&gt;%&lt;/code&gt; 前缀，立即数 &lt;code&gt;$&lt;/code&gt; 前缀，操作数顺序是 &lt;code&gt;源, 目的&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;movl&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;$5&lt;/span&gt;, %eax      &lt;span style=&#34;color:#75715e&#34;&gt;# 把立即数 5 移动到 eax
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;addl&lt;/span&gt; %eax, %ebx    &lt;span style=&#34;color:#75715e&#34;&gt;# ebx = ebx + eax
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;movl&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;(%ebp), %ecx &lt;span style=&#34;color:#75715e&#34;&gt;# 从 [ebp+8] 取数到 ecx
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Intel 格式简介&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;常见于 &lt;strong&gt;MASM / NASM / Windows 平台&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更接近高级语言风格，简洁直观，广泛用于手写汇编和逆向分析。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特点：操作数顺序 &lt;code&gt;目的, 源&lt;/code&gt;，寄存器无 &lt;code&gt;%&lt;/code&gt;，立即数直接写，内存寻址用 &lt;code&gt;[]&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;eax&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;          &lt;span style=&#34;color:#75715e&#34;&gt;; 把立即数 5 移动到 eax
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ebx&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;eax&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;; ebx = ebx + eax
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ecx&lt;/span&gt;, [&lt;span style=&#34;color:#66d9ef&#34;&gt;ebp&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;]    &lt;span style=&#34;color:#75715e&#34;&gt;; 从 [ebp+8] 取数到 ecx
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对比表：AT&amp;amp;T vs Intel 汇编格式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;特点&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;AT&amp;amp;T 格式&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;Intel 格式&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;操作数顺序&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;源, 目的&lt;/td&gt;
          &lt;td&gt;目的, 源&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;寄存器&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;%eax&lt;/code&gt;、&lt;code&gt;%ebx&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;eax&lt;/code&gt;、&lt;code&gt;ebx&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;立即数&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;$5&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;5&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;内存寻址&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;disp(base, index, scale)&lt;/code&gt; → &lt;code&gt;8(%ebp, %ecx, 4)&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;[base + index*scale + disp]&lt;/code&gt; → &lt;code&gt;[ebp + ecx*4 + 8]&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;操作数大小&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;指令后缀：&lt;code&gt;b&lt;/code&gt;=8位, &lt;code&gt;w&lt;/code&gt;=16位, &lt;code&gt;l&lt;/code&gt;=32位, &lt;code&gt;q&lt;/code&gt;=64位&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;byte ptr&lt;/code&gt;, &lt;code&gt;word ptr&lt;/code&gt;, &lt;code&gt;dword ptr&lt;/code&gt;, &lt;code&gt;qword ptr&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;符号/变量&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;movl $var, %eax&lt;/code&gt; (取地址)  &lt;code&gt;movl var, %eax&lt;/code&gt; (取值)&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;mov eax, offset var&lt;/code&gt; (取地址)  &lt;code&gt;mov eax, [var]&lt;/code&gt; (取值)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;汇编器&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;GNU Assembler (&lt;code&gt;gas&lt;/code&gt;)&lt;/td&gt;
          &lt;td&gt;MASM, NASM, FASM 等&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;常见平台&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;Linux/Unix 系统&lt;/td&gt;
          &lt;td&gt;Windows、逆向工程&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常用指令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lt;reg&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;mem&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;con&amp;gt;,&amp;lt;con32&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;数据传送指令
&lt;ol&gt;
&lt;li&gt;mov&lt;/li&gt;
&lt;li&gt;push&lt;/li&gt;
&lt;li&gt;pop&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;算术和逻辑运算指令
&lt;ol&gt;
&lt;li&gt;add/sub&lt;/li&gt;
&lt;li&gt;inc/dec&lt;/li&gt;
&lt;li&gt;imul&lt;/li&gt;
&lt;li&gt;idiv&lt;/li&gt;
&lt;li&gt;and/or/xor&lt;/li&gt;
&lt;li&gt;not&lt;/li&gt;
&lt;li&gt;neg&lt;/li&gt;
&lt;li&gt;shl/shr&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;控制流指令
&lt;ol&gt;
&lt;li&gt;jmp&lt;/li&gt;
&lt;li&gt;jcondition: je,jz,jne,jg,jge,jl,jle&lt;/li&gt;
&lt;li&gt;cmp/test&lt;/li&gt;
&lt;li&gt;call/ret&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择语句的机器级表示&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-pseudocode&#34; data-lang=&#34;pseudocode&#34;&gt;if(test_expr)
	then_statement
else
	else_statement
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-pseudocode&#34; data-lang=&#34;pseudocode&#34;&gt;t=test_expr
if(!t)
	goto false;
then_statement
goto done;
false:
else_statement
done;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;循环语句的机器级表示&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;do-while&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-pseudocode&#34; data-lang=&#34;pseudocode&#34;&gt;do 
	body_statement
	while(test_expr);
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-pseudocode&#34; data-lang=&#34;pseudocode&#34;&gt;loop:
body_statement
t=test_expr;
if(t)
	goto loop;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;while&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-pseudocode&#34; data-lang=&#34;pseudocode&#34;&gt;while(test_expr)
	body_statement
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-pseudocode&#34; data-lang=&#34;pseudocode&#34;&gt;t=test_expr;
if(!t)
	goto done;
loop:
body_statement;
t=test_expr;
if(t)
	goto loop;
done:
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;for&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-pseudocode&#34; data-lang=&#34;pseudocode&#34;&gt;for(init_expr;test_expr;update_expr)
	body_statement
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-pseudocode&#34; data-lang=&#34;pseudocode&#34;&gt;init_expr;
t=test_expr;
if(!t)
	goto done;
loop:
body_statement
update_expr;
t=test_expr;
if(t)
	goto loop;
done:
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;过程调用的机器级表示&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;cisc和risc的基本概念&#34;&gt;CISC和RISC的基本概念
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;复杂指令系统计算机(CISC)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特点：指令集复杂，每条指令可以完成较复杂的操作，指令长度不固定。&lt;/li&gt;
&lt;li&gt;设计理念：&lt;strong&gt;软件简单化，把更多功能交给硬件来完成&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;常见架构：x86、VAX、68000。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;精简指令系统计算机(RISC)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特点：指令集简单，每条指令长度固定，执行时间大多相同。&lt;/li&gt;
&lt;li&gt;设计理念：&lt;strong&gt;硬件简单化，指令执行快，依靠编译器优化来实现复杂功能&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;常见架构：ARM、MIPS、RISC-V、SPARC。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CISC和RISC的比较&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;特点&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;RISC&lt;/strong&gt;（精简指令集）&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;CISC&lt;/strong&gt;（复杂指令集）&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;指令数量&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;少，指令集精简&lt;/td&gt;
          &lt;td&gt;多，指令功能复杂&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;指令长度&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;固定（常见 32 位）&lt;/td&gt;
          &lt;td&gt;不固定（8～120 字节不等）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;指令执行时间&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;大多数指令 1 个时钟周期&lt;/td&gt;
          &lt;td&gt;指令执行时间差别大&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;寻址方式&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;少（常 3～5 种）&lt;/td&gt;
          &lt;td&gt;多（十几种甚至几十种）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;硬件复杂度&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;控制器一般为硬布线（简单）&lt;/td&gt;
          &lt;td&gt;控制器常为微程序（复杂）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;编译器依赖性&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;高，复杂操作要由编译器分解&lt;/td&gt;
          &lt;td&gt;低，硬件可直接完成复杂操作&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;性能优化方式&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;通过流水线、寄存器优化&lt;/td&gt;
          &lt;td&gt;通过复杂指令减少代码长度&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;代表架构&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;ARM、MIPS、RISC-V&lt;/td&gt;
          &lt;td&gt;x86、Intel 8086、VAX&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;代码密度&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;代码长（指令多）&lt;/td&gt;
          &lt;td&gt;代码短（指令少，但复杂）&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0904学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0904/</link>
        <pubDate>Fri, 05 Sep 2025 23:42:41 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0904/</guid>
        <description>&lt;h2 id=&#34;计算机组成原理&#34;&gt;计算机组成原理
&lt;/h2&gt;&lt;h3 id=&#34;指令系统&#34;&gt;指令系统
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;指令集体系结构（ISA）&lt;/p&gt;
&lt;p&gt;ISA规定的内容主要包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;指令格式，指令寻址方式，操作类型，以及每种操作对应的操作数的相应规定&lt;/li&gt;
&lt;li&gt;操作数的类型，操作数寻址方式，以及是按大段方式还是小端方式&lt;/li&gt;
&lt;li&gt;程序可访问的寄存器编号、个数和位数，存储空间的大小和编址方式&lt;/li&gt;
&lt;li&gt;指令执行过程的控制方式等，包括程序计数器、条件码定义等&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指令的基本格式&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;操作码字段&lt;/th&gt;
          &lt;th&gt;地址码字段&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;定长指令字结构，变长指令字结构。主存一般是按字节编址的，所以指令字长通常为字节的整数倍。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;零地址指令&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;OP&lt;/th&gt;
          &lt;th&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一地址指令&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;OP&lt;/th&gt;
          &lt;th&gt;$A_1$&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二地址指令&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;OP&lt;/th&gt;
          &lt;th&gt;$A_1$&lt;/th&gt;
          &lt;th&gt;$A_2$&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三地址指令&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;OP&lt;/th&gt;
          &lt;th&gt;$A_1$&lt;/th&gt;
          &lt;th&gt;$A_2$&lt;/th&gt;
          &lt;th&gt;$A_3$（结果）&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;四地址指令&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;OP&lt;/th&gt;
          &lt;th&gt;$A_1$&lt;/th&gt;
          &lt;th&gt;$A_2$&lt;/th&gt;
          &lt;th&gt;$A_3$（结果）&lt;/th&gt;
          &lt;th&gt;$A_4$（下址）&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定长操作码指令格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;扩展操作码指令格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指令的操作类型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据传送MOV，LOAD，STORE，PUSH，POP&lt;/li&gt;
&lt;li&gt;算数和逻辑运算ADD，SUB，MUL，DIV，INC，DEC，AND，OR，NOT，XOR&lt;/li&gt;
&lt;li&gt;移位操作&lt;/li&gt;
&lt;li&gt;转移操作JMP，BRANCH，CALL，RET，TRAP&lt;/li&gt;
&lt;li&gt;输入输出操作&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;指令的寻址方式&#34;&gt;指令的寻址方式
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;指令寻址和数据寻址&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;指令寻址&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;顺序寻址PC+1&lt;/li&gt;
&lt;li&gt;跳跃寻址&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据寻址&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;操作码&lt;/th&gt;
          &lt;th&gt;寻址特征&lt;/th&gt;
          &lt;th&gt;形式地址A&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常见的数据寻址方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;隐含寻址&lt;/li&gt;
&lt;li&gt;立即（数）寻址&lt;/li&gt;
&lt;li&gt;直接寻址&lt;/li&gt;
&lt;li&gt;间接寻址&lt;/li&gt;
&lt;li&gt;寄存器寻址EA=$R_i$&lt;/li&gt;
&lt;li&gt;寄存器间接寻址&lt;/li&gt;
&lt;li&gt;相对寻址&lt;/li&gt;
&lt;li&gt;基址寻址&lt;/li&gt;
&lt;li&gt;变址寻址&lt;/li&gt;
&lt;li&gt;堆栈寻址&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;寻址方式&lt;/th&gt;
          &lt;th&gt;有效地址&lt;/th&gt;
          &lt;th&gt;访存次数&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;立即寻址&lt;/td&gt;
          &lt;td&gt;A即是操作数&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;直接寻址&lt;/td&gt;
          &lt;td&gt;EA=A&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;一次性间接寻址&lt;/td&gt;
          &lt;td&gt;EA=(A)&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;寄存器寻址&lt;/td&gt;
          &lt;td&gt;EA=$R_i$&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;寄存器间接一次寻址&lt;/td&gt;
          &lt;td&gt;EA=($R_i$)&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;相对寻址&lt;/td&gt;
          &lt;td&gt;EA=(PC)+A&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;基址寻址&lt;/td&gt;
          &lt;td&gt;EA=(BR)+A&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;变址寻址&lt;/td&gt;
          &lt;td&gt;EA=(IX)+A&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0903学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0903/</link>
        <pubDate>Fri, 05 Sep 2025 23:00:46 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0903/</guid>
        <description>&lt;h2 id=&#34;计算机组成原理&#34;&gt;计算机组成原理
&lt;/h2&gt;&lt;h3 id=&#34;虚拟存储器&#34;&gt;虚拟存储器
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;基本概念&lt;/li&gt;
&lt;li&gt;页式虚拟存储器
&lt;ol&gt;
&lt;li&gt;页表&lt;/li&gt;
&lt;li&gt;地址转换&lt;/li&gt;
&lt;li&gt;快表(TLB translation lookaside buffer)&lt;/li&gt;
&lt;li&gt;具有TLB和Cache的多级存储系统&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;段式虚拟存储器&lt;/li&gt;
&lt;li&gt;段页式虚拟存储器&lt;/li&gt;
&lt;li&gt;虚拟存储器与Cache的比较
&lt;ol&gt;
&lt;li&gt;相同之处
&lt;ul&gt;
&lt;li&gt;最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度&lt;/li&gt;
&lt;li&gt;都把数据划分为小信息块，并作为基本的交换单位，虚存系统的信息块更大&lt;/li&gt;
&lt;li&gt;都有地址映射、替换算法、更新策略等问题&lt;/li&gt;
&lt;li&gt;都依据局部性原理应用快速缓存的思想，将活跃的数据放在相对高速的部件中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不同之处
&lt;ul&gt;
&lt;li&gt;Cache主要解决系统速度，而虚拟存储器却是为了解决主存容量&lt;/li&gt;
&lt;li&gt;Cache全由硬件实现，是硬件存储器，对所有程序员透明；而虚拟存储器由OS和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明&lt;/li&gt;
&lt;li&gt;对于不命中性能影响， 因为CPU的速度约为Cache的10倍，主存的速度为硬件的100倍以上，因此虚拟存储器系统不命中时对系统性能影响更大&lt;/li&gt;
&lt;li&gt;CPU与Cache和主存都建立了直接访问通道，而辅存与CPU没有直接通路。也就是说在Cache不命中时能和CPU直接通信，同时将数据调入Cache；而虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和CPU通信&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0902学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0902/</link>
        <pubDate>Wed, 03 Sep 2025 22:37:10 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0902/</guid>
        <description>&lt;h2 id=&#34;计算机组成原理&#34;&gt;计算机组成原理
&lt;/h2&gt;&lt;h3 id=&#34;主存储器与cpu的连接&#34;&gt;主存储器与CPU的连接
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;连接原理：
&lt;ul&gt;
&lt;li&gt;主存储器通过数据总线、地址总线和控制总线与CPU连接&lt;/li&gt;
&lt;li&gt;数据总线的位数与工作频率的乘积正比于数据传输速率&lt;/li&gt;
&lt;li&gt;地址总线的位数决定了可寻址的最大内存空间&lt;/li&gt;
&lt;li&gt;控制总线(读/写)指出总线周期的类型和本次输入/输出操作完成的时刻&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主存容量的扩展
&lt;ul&gt;
&lt;li&gt;位扩展法&lt;/li&gt;
&lt;li&gt;字扩展法&lt;/li&gt;
&lt;li&gt;位字同时扩展法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;存储芯片的地址分配和片选
&lt;ul&gt;
&lt;li&gt;线选法&lt;/li&gt;
&lt;li&gt;译码片选法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;存储器与CPU的连接
&lt;ul&gt;
&lt;li&gt;合理选择存储芯片&lt;/li&gt;
&lt;li&gt;地址线的连接(cpu的地址线通常比芯片的地址线多，地位连接，高位片选)&lt;/li&gt;
&lt;li&gt;数据线的连接&lt;/li&gt;
&lt;li&gt;读写命令线的连接&lt;/li&gt;
&lt;li&gt;片选线的连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;外部存储器&#34;&gt;外部存储器
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;磁盘存储器&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;组成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁盘驱动器&lt;/li&gt;
&lt;li&gt;磁盘控制器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储区域&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁头数&lt;/li&gt;
&lt;li&gt;柱面数&lt;/li&gt;
&lt;li&gt;扇区数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;性能指标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录密度&lt;/li&gt;
&lt;li&gt;磁盘的容量 = 记录面数 * 柱面数* 每道扇区数 * 每个扇区的容量&lt;/li&gt;
&lt;li&gt;存取时间&lt;/li&gt;
&lt;li&gt;数据传输速率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;磁盘地址&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;柱面号（磁道号）&lt;/th&gt;
          &lt;th&gt;盘面号（磁头）&lt;/th&gt;
          &lt;th&gt;扇区号&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;磁盘的工作过程&lt;/p&gt;
&lt;p&gt;寻址、读盘、写盘。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;取控制字&lt;/li&gt;
&lt;li&gt;执行控制字&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;磁盘阵列（RAID）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RAID0：无冗余和无校验的磁盘阵列&lt;/li&gt;
&lt;li&gt;RAID1：镜像磁盘阵列&lt;/li&gt;
&lt;li&gt;RAID2：采用纠错的海明码的磁盘阵列&lt;/li&gt;
&lt;li&gt;RAID3：位交叉奇偶校验的磁盘阵列&lt;/li&gt;
&lt;li&gt;RAID4：块交叉奇偶校验的磁盘阵列&lt;/li&gt;
&lt;li&gt;RAID5：无独立校验的奇偶校验磁盘阵列&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;固态硬盘（SSD）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;劣势：随机写很慢，擦除块较慢&lt;/li&gt;
&lt;li&gt;优势：
&lt;ol&gt;
&lt;li&gt;半导体存储器，没有移动部件，随机访问速度比磁盘块很多，无噪音和震动；&lt;/li&gt;
&lt;li&gt;能耗低，抗震性好，安全性高&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;磨损均衡
&lt;ol&gt;
&lt;li&gt;动态磨损均衡&lt;/li&gt;
&lt;li&gt;静态磨损均衡（操作系统重合知识点）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;高速缓冲存储器cache&#34;&gt;高速缓冲存储器Cache
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;程序访问的局部性原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cache的基本工作原理&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当CPU发出读请求时：若命中，则将访存地址转换成Cache地址。直接对Cache进行读操作；否则，需要访问主存，并把此字所在的块一次性的从主存调入Cache。若满，则根据某种替换算法，用这个块替换。整个过程由硬件实现。&lt;/li&gt;
&lt;li&gt;当CPU发出写请求时：若命中，有可能会遇到Cache与主存中的内容不一致的问题。需要按照一定的写策略进行处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cache的命中率计算&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cache和主存的映射方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;直接映射&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;标记&lt;/th&gt;
          &lt;th&gt;Cache行号&lt;/th&gt;
          &lt;th&gt;块内地址&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全相联映射&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;标记&lt;/th&gt;
          &lt;th&gt;块内地址&lt;/th&gt;
          &lt;th&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组相联映射&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;标记&lt;/th&gt;
          &lt;th&gt;组号&lt;/th&gt;
          &lt;th&gt;块内地址&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cache中主存块的替换算法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;随机算法&lt;/li&gt;
&lt;li&gt;FIFO算法&lt;/li&gt;
&lt;li&gt;LRU算法&lt;/li&gt;
&lt;li&gt;最不经常使用算法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cache的一致性问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;全写法（直写法、write-through）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写缓冲&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;回写法（wirte-back）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脏位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写分配法(write-allocate)（写不命中）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非写分配法(not-write-allocate)（写不命中）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0901学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0901/</link>
        <pubDate>Wed, 03 Sep 2025 22:21:06 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0901/</guid>
        <description>&lt;h2 id=&#34;计算机组成原理-存储系统&#34;&gt;计算机组成原理-存储系统
&lt;/h2&gt;&lt;h3 id=&#34;存储器的分类&#34;&gt;存储器的分类
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;按作用（层次）分类
&lt;ol&gt;
&lt;li&gt;主存储器&lt;/li&gt;
&lt;li&gt;辅助存储器&lt;/li&gt;
&lt;li&gt;高速缓冲存储器&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;按存储介质分类
&lt;ol&gt;
&lt;li&gt;随机存储器RAM&lt;/li&gt;
&lt;li&gt;只读存储器ROM&lt;/li&gt;
&lt;li&gt;串行访问存储器&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;按信息的可保存性分类
&lt;ol&gt;
&lt;li&gt;易失性存储器&lt;/li&gt;
&lt;li&gt;非易失性存储器&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;存储器的性能指标&#34;&gt;存储器的性能指标
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;存储容量&lt;/li&gt;
&lt;li&gt;单位成本&lt;/li&gt;
&lt;li&gt;存储速度&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;多级层次的存储系统&#34;&gt;多级层次的存储系统
&lt;/h3&gt;&lt;p&gt;主要思想：上一层的存储器作为低一层存储器的高速缓存&lt;/p&gt;
&lt;h3 id=&#34;sram芯片和dram芯片&#34;&gt;SRAM芯片和DRAM芯片
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;SRAM芯片的工作原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DRAM芯片的工作原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DRAM芯片的读写周期&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SRAM和DRAM的比较&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储芯片的内部结构&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;只读存储器&#34;&gt;只读存储器
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;只读存储器的特点&lt;/li&gt;
&lt;li&gt;ROM的类型
&lt;ol&gt;
&lt;li&gt;掩模式只读存储器MROM&lt;/li&gt;
&lt;li&gt;一次可编程只读存储器PROM&lt;/li&gt;
&lt;li&gt;可擦除可编程只读存储器EPROM&lt;/li&gt;
&lt;li&gt;Flash存储器&lt;/li&gt;
&lt;li&gt;固态硬盘&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;主存储器的基本组成&#34;&gt;主存储器的基本组成
&lt;/h3&gt;&lt;h3 id=&#34;多模块存储器&#34;&gt;多模块存储器
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;单体多字存储器&lt;/li&gt;
&lt;li&gt;多体并行存储器
&lt;ol&gt;
&lt;li&gt;高位交叉编址&lt;/li&gt;
&lt;li&gt;低位交叉编址&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;马克思主义原理&#34;&gt;马克思主义原理
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;考点一：什么是马克思主义？&lt;/li&gt;
&lt;li&gt;考点二：马克思注意产生的社会根源、阶级基础和思想渊源&lt;/li&gt;
&lt;li&gt;考点三：马克思主义的发展&lt;/li&gt;
&lt;li&gt;考点四：马克思主义的中国化时代化&lt;/li&gt;
&lt;li&gt;考点五：习近平新时代中国特色社会主义思想的世界观和方法论&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0829学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0829/</link>
        <pubDate>Fri, 29 Aug 2025 23:30:56 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0829/</guid>
        <description>&lt;h2 id=&#34;数学-积分不等式和等式&#34;&gt;数学-积分不等式和等式
&lt;/h2&gt;&lt;h3 id=&#34;积分等式&#34;&gt;积分等式
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;积分中值定理
&lt;/p&gt;
$$
   \exists \xi\in(a,b),\int_a^bf(x)dx = f(\xi)(b-a)
   $$$$
   \exists \xi\in(a,b),\int_a^b{f(x)g(x)d x} = f(\xi)\int_a^bg(x)dx,g(x)\text{保号}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用夹逼准则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用积分法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;恒等变形&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;换元法
&lt;/p&gt;
$$
     \int f(x)dx = \int f(\varphi(t))\cdot\varphi&#39;(t)dt
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分布积分法
&lt;/p&gt;
$$
     \int vdu = vu - \int udv
     $$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;积分不等式&#34;&gt;积分不等式
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;函数的单调性&lt;/li&gt;
&lt;li&gt;拉格朗日中值定理&lt;/li&gt;
&lt;li&gt;泰勒公式&lt;/li&gt;
&lt;li&gt;积分法&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0827.1学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0827.1/</link>
        <pubDate>Wed, 27 Aug 2025 19:12:07 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0827.1/</guid>
        <description>&lt;h2 id=&#34;计算机组成原理&#34;&gt;计算机组成原理
&lt;/h2&gt;&lt;h3 id=&#34;数据的表示和运算&#34;&gt;数据的表示和运算
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;进位计数制及其相互转换&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进位计数法&lt;/li&gt;
&lt;li&gt;不同进制之间的相互转换（十进制小数转换为二进制小数）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定点数的编码表示&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;真值与机器数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;机器数的定点表示&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定点小数&lt;/li&gt;
&lt;li&gt;定点整数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原码&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;最高位为符号位，对于一个n+1位的原码数，其表示范围为.
&lt;/p&gt;
$$
         -(2^n-1)\leq x \leq 2^n-1
         $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单直观&lt;/li&gt;
&lt;li&gt;乘除实现简单&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0表示不唯一&lt;/li&gt;
&lt;li&gt;加减法复杂&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;补码&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;定义（n位）
&lt;/p&gt;
$$
         [x]_{\text{补}}= (2^n + x )\mod2^n
         $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;负数补码的方法：最高位为1，各位取反，末位加1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变形补码：双符号位&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移码&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;整数的表示&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无符号整数&lt;/li&gt;
&lt;li&gt;有符号整数&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C语言中的整数类型及类型转换&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;有符号无符号转换&lt;/p&gt;
&lt;p&gt;机器数不变，解释方式发生改变&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同字长&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;0扩展&lt;/li&gt;
&lt;li&gt;符号扩展&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;运算方法和运算电路&#34;&gt;运算方法和运算电路
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本运算部件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;带标志加法器&lt;/li&gt;
&lt;li&gt;算数逻辑单元(ALU )&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定点数的位移运算&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑移位&lt;/li&gt;
&lt;li&gt;算术移位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定点数的加减运算&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;补码的加减运算&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;逢二进一&lt;/li&gt;
&lt;li&gt;加法，补码直接相加；减法，被减数与-减数的补码相加。&lt;/li&gt;
&lt;li&gt;符号位一起参与运算&lt;/li&gt;
&lt;li&gt;最终结果高位丢弃&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;溢出判别方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一位符号位&lt;/p&gt;
&lt;p&gt;操作数符号相同且与结果不同，即溢出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双符号位&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;00：正数，无溢出&lt;/li&gt;
&lt;li&gt;01：正数，溢出&lt;/li&gt;
&lt;li&gt;11：负数，无溢出&lt;/li&gt;
&lt;li&gt;10：负数，溢出&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;采用一位符号位根据数值位的进位情况判断溢出&lt;/p&gt;
&lt;p&gt;符号位的进位与最高数位的进位相同，则无溢出，否则溢出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加减运算电路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;CF&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OF&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ZF&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SF&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定点数的乘除运算&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定点乘法运算
&lt;ul&gt;
&lt;li&gt;基本原理&lt;/li&gt;
&lt;li&gt;乘法运算电路&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;除法运算
&lt;ul&gt;
&lt;li&gt;基本原理&lt;/li&gt;
&lt;li&gt;除法运算电路&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0824学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0824/</link>
        <pubDate>Sun, 24 Aug 2025 00:19:58 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0824/</guid>
        <description>&lt;h2 id=&#34;a&#34;&gt;A
&lt;/h2&gt;&lt;h3 id=&#34;-auth-&#34;&gt;-auth-
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;author&lt;/li&gt;
&lt;li&gt;authority&lt;/li&gt;
&lt;li&gt;authorize&lt;/li&gt;
&lt;li&gt;authentic&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;-a-a&#34;&gt;-a-,a
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;admire&lt;/li&gt;
&lt;li&gt;afford&lt;/li&gt;
&lt;li&gt;amuse&lt;/li&gt;
&lt;li&gt;annoy&lt;/li&gt;
&lt;li&gt;appoint&lt;/li&gt;
&lt;li&gt;approach&lt;/li&gt;
&lt;li&gt;appropriate&lt;/li&gt;
&lt;li&gt;arrest&lt;/li&gt;
&lt;li&gt;assault&lt;/li&gt;
&lt;li&gt;asset&lt;/li&gt;
&lt;li&gt;assess&lt;/li&gt;
&lt;li&gt;astonishing&lt;/li&gt;
&lt;li&gt;awaken&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;b&#34;&gt;B
&lt;/h2&gt;&lt;h3 id=&#34;-back-&#34;&gt;-back-
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;setback&lt;/li&gt;
&lt;li&gt;feedback&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;-band-&#34;&gt;-band-
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;band&lt;/li&gt;
&lt;li&gt;bind&lt;/li&gt;
&lt;li&gt;bond&lt;/li&gt;
&lt;li&gt;bonus&lt;/li&gt;
&lt;li&gt;bound&lt;/li&gt;
&lt;li&gt;boundary&lt;/li&gt;
&lt;li&gt;abound&lt;/li&gt;
&lt;li&gt;abundant&lt;/li&gt;
&lt;li&gt;combine&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;-bas-&#34;&gt;-bas-
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;base&lt;/li&gt;
&lt;li&gt;basis&lt;/li&gt;
&lt;li&gt;basic&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;-bat-&#34;&gt;-bat-
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;battle&lt;/li&gt;
&lt;li&gt;combat&lt;/li&gt;
&lt;li&gt;battery&lt;/li&gt;
&lt;li&gt;debate&lt;/li&gt;
&lt;li&gt;bet&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;-be-&#34;&gt;-be-
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;behalf&lt;/li&gt;
&lt;li&gt;beneath&lt;/li&gt;
&lt;li&gt;betray&lt;/li&gt;
&lt;li&gt;behave&lt;/li&gt;
&lt;li&gt;bewilder&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;-bi-&#34;&gt;-bi-
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;bilingual&lt;/li&gt;
&lt;li&gt;linguist&lt;/li&gt;
&lt;li&gt;ambiguous&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;-blunt-&#34;&gt;-blunt-
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;blunt&lt;/li&gt;
&lt;li&gt;blunder&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;-board--broad-&#34;&gt;-board-,-broad-
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;board&lt;/li&gt;
&lt;li&gt;aboard&lt;/li&gt;
&lt;li&gt;broad&lt;/li&gt;
&lt;li&gt;abroad&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;-boast-&#34;&gt;-boast-
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;boast&lt;/li&gt;
&lt;li&gt;boost&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;-bureau-&#34;&gt;-bureau-
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;bureau&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bureaucracy&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;c&#34;&gt;C
&lt;/h2&gt;&lt;h3 id=&#34;-cal--cul-&#34;&gt;-cal-,-cul-
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;scale&lt;/li&gt;
&lt;li&gt;sculpture&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;-camp-&#34;&gt;-camp-
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;camp&lt;/li&gt;
&lt;li&gt;campaign&lt;/li&gt;
&lt;li&gt;campus&lt;/li&gt;
&lt;li&gt;chamber&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;-cap--capt--cip--cup-&#34;&gt;-cap-,-capt-,-cip-,-cup-
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;capable&lt;/li&gt;
&lt;li&gt;capital&lt;/li&gt;
&lt;li&gt;capture&lt;/li&gt;
&lt;li&gt;captive&lt;/li&gt;
&lt;li&gt;capacity&lt;/li&gt;
&lt;li&gt;escape&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;participate&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;anticipate&lt;/li&gt;
&lt;li&gt;discipline&lt;/li&gt;
&lt;li&gt;occupy&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;-car-&#34;&gt;-car-
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;career&lt;/li&gt;
&lt;li&gt;carpet&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;-care--cer--char--cur-&#34;&gt;-care-,-cer-,-char-,-cur-
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;scare&lt;/li&gt;
&lt;li&gt;dread&lt;/li&gt;
&lt;li&gt;fright&lt;/li&gt;
&lt;li&gt;charity&lt;/li&gt;
&lt;li&gt;concern&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;discern&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;curious&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;-caut-&#34;&gt;-caut-
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;caution&lt;/li&gt;
&lt;li&gt;precaution&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;-ceed--cede--cess-&#34;&gt;-ceed-,-cede-,-cess-
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;proceed&lt;/li&gt;
&lt;li&gt;process&lt;/li&gt;
&lt;li&gt;procedure&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;precede&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;precedent&lt;/li&gt;
&lt;li&gt;predecessor&lt;/li&gt;
&lt;li&gt;recession&lt;/li&gt;
&lt;li&gt;succeed&lt;/li&gt;
&lt;li&gt;success&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;succession&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;exceed&lt;/li&gt;
&lt;li&gt;excess&lt;/li&gt;
&lt;li&gt;excel&lt;/li&gt;
&lt;li&gt;excellent&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;concede&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;access&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cease&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0817学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0817/</link>
        <pubDate>Sun, 17 Aug 2025 23:52:05 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0817/</guid>
        <description>&lt;h2 id=&#34;数学-朝花夕拾&#34;&gt;数学-朝花夕拾
&lt;/h2&gt;&lt;p&gt;关于一元函数的不定积分和积分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;关于原函数的存在条件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;连续函数一定有原函数&lt;/li&gt;
&lt;li&gt;含有第一类间断点和无穷间断点的函数在包含改间断点的区间内不存在原函数&lt;/li&gt;
&lt;li&gt;震荡间断点可能有可能没有&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定积分的极限形式
&lt;/p&gt;
$$
   \begin{align}
   \int_b^af(x)dx&amp;=\lim\limits_{\lambda\to0}\sum\limits_{k=1}^n{f(\xi_k)\Delta x_k},\xi\in[x_{k-1},x_k],\Delta x_i = x_i - x_{i-1}\\
   \int_b^af(x)dx&amp;=\lim\limits_{n\to \infty}\sum\limits_{i=1}^nf(a+\frac{b-a}{n}i)\frac{b-a}{n}\\
   \int_0^1f(x)dx&amp;=\lim\limits_{n\to \infty}\sum\limits_{i=1}^nf(\frac{i}{n})\frac{1}{n}
   \end{align}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定积分存在定理&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;充分条件
&lt;ol&gt;
&lt;li&gt;闭区间连续&lt;/li&gt;
&lt;li&gt;闭区间单调&lt;/li&gt;
&lt;li&gt;闭区间有界，有限间断点（不包含无穷间断点）&lt;/li&gt;
&lt;li&gt;闭区间有有限个第一类间断点&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;必要条件
&lt;ol&gt;
&lt;li&gt;闭区间有界&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;几个重要的积分不等式
&lt;/p&gt;
$$
   \begin{align}
   \left|\int_b^af(x)dx\right|&amp;\leq\int_b^a\left|f(x)\right|\\
   mL\leq\int_b^af(x)dx&amp;\leq ML,(m\leq f(x)\leq M,L=|b-a|)
   \end{align}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变限积分性质&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;f(x)可积$\Rightarrow F(x)=\int_a^xf(t)dt$ 连续&lt;/li&gt;
&lt;li&gt;f(x)连续$\Rightarrow F(x)=\int_a^xf(t)dt$ 可导且$F&amp;rsquo;(x)=f(x)$&lt;/li&gt;
&lt;li&gt;跳跃间断点，则$F(x)$在该处不可导&lt;/li&gt;
&lt;li&gt;可取间断点，则$F(x)$在该处可导，但$F&amp;rsquo;(x)\neq f(x)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反常积分&lt;/p&gt;
$$
      \int_0^1\frac{1}{x^p}dx\begin{cases}
      \text{收敛},0&lt;p&lt;1,\\
      \\
      \text{发散},p\geq1.\\
      \end{cases}
   $$$$
      \int_{1}^{+\infty}\frac{1}{x^p}dx\begin{cases}
      \text{发散},0&lt;p&lt;1,\\
      \\
      \text{收敛},p\geq1.\\
      \end{cases}
   $$$$
   \int_0^1\frac{\ln x}{x^p}dx\begin{cases}
      \text{收敛},0&lt;p&lt;1,\\
      \text{发散},p\geq1.\\
      \end{cases}
   $$&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0816学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0816/</link>
        <pubDate>Sat, 16 Aug 2025 23:48:21 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0816/</guid>
        <description>&lt;h2 id=&#34;数学-一元积分学&#34;&gt;数学-一元积分学
&lt;/h2&gt;&lt;h3 id=&#34;不定积分&#34;&gt;不定积分
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;原函数与不定积分&lt;/li&gt;
&lt;li&gt;原函数（不定积分）存在定理
&lt;ol&gt;
&lt;li&gt;连续函数f(x)必有原函数F(x)&lt;/li&gt;
&lt;li&gt;含有第一类间断点和无穷间断点的函数f(x)在包含该间断点的区间内没有原函数F(x)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;定积分&#34;&gt;定积分
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;定义
&lt;ol&gt;
&lt;li&gt;定积分的概念&lt;/li&gt;
&lt;li&gt;几何意义&lt;/li&gt;
&lt;li&gt;定积分的精确的定义&lt;/li&gt;
&lt;li&gt;定积分的值与字母无关&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;存在定理
&lt;ol&gt;
&lt;li&gt;定积分存在的充分条件&lt;/li&gt;
&lt;li&gt;定积分存在的必要条件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;性质
&lt;ol&gt;
&lt;li&gt;性质1 ：求区间长度&lt;/li&gt;
&lt;li&gt;性质2：积分的线性性质&lt;/li&gt;
&lt;li&gt;性质3：积分的可加（拆）性&lt;/li&gt;
&lt;li&gt;性质4：积分的保号性&lt;/li&gt;
&lt;li&gt;性质5：估值定理&lt;/li&gt;
&lt;li&gt;性质6：中值定理&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;变限积分&#34;&gt;变限积分
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;概念&lt;/li&gt;
&lt;li&gt;性质&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;反常积分&#34;&gt;反常积分
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;概念&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;敛散性的判别法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;无穷区间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比较判别法&lt;/li&gt;
&lt;li&gt;比较判别法的极限形式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无界函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比较判别法&lt;/li&gt;
&lt;li&gt;比较判别法的极限形式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0814学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0814/</link>
        <pubDate>Thu, 14 Aug 2025 22:31:10 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0814/</guid>
        <description>&lt;h2 id=&#34;概率论-自然界是对数的吗&#34;&gt;概率论-自然界是对数的吗？
&lt;/h2&gt;&lt;h3 id=&#34;基本概念&#34;&gt;基本概念
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;随机试验&lt;/p&gt;
&lt;p&gt;（1）试验可以在相同的条件下重复进行&lt;/p&gt;
&lt;p&gt;（2）实验所有可能结果明确可知，且不止一个&lt;/p&gt;
&lt;p&gt;（3）每一次试验会出现哪一个结果，事先并不能确定&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;投篮&lt;/li&gt;
&lt;li&gt;掷硬币&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随机事件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;样本空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件的关系与运算&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关系
&lt;ul&gt;
&lt;li&gt;包含：如果事件A发生必导致事件B发生，则称事件B&lt;strong&gt;包含&lt;/strong&gt;事件A,$A\subset B$&lt;/li&gt;
&lt;li&gt;相等&lt;/li&gt;
&lt;li&gt;积（交）：称“事件A与B同时发生”的事件为事件A与B的积事件，$A\cap B$&lt;/li&gt;
&lt;li&gt;相容：若$AB\neq \varnothing$则称事件A和B相容&lt;/li&gt;
&lt;li&gt;互斥：若$AB=\varnothing$,则称事件A和B互不相容，即互斥&lt;/li&gt;
&lt;li&gt;和（并）：“事件A与B至少有一个发生”的事件为事件A与B的和事件，$A\cup B$&lt;/li&gt;
&lt;li&gt;差：“事件A与B至少有一个发生”的事件为事件A与B的差事件，$A-B$&lt;/li&gt;
&lt;li&gt;逆（对立）&lt;/li&gt;
&lt;li&gt;完备事件组&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;运算
&lt;ol&gt;
&lt;li&gt;吸收律&lt;/li&gt;
&lt;li&gt;交换律&lt;/li&gt;
&lt;li&gt;结合律&lt;/li&gt;
&lt;li&gt;分配律&lt;/li&gt;
&lt;li&gt;对偶率（德摩根律）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;概率的定义&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;描述性定义&lt;/li&gt;
&lt;li&gt;统计性定义&lt;/li&gt;
&lt;li&gt;公理化定义&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;古典概型和几何概型&#34;&gt;古典概型和几何概型
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;古典概型
&lt;ol&gt;
&lt;li&gt;概念
&lt;ul&gt;
&lt;li&gt;只有有限个样本点（基本事件）&lt;/li&gt;
&lt;li&gt;每个样本点（基本事件）发生的可能性都一样&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;计算方法
&lt;ol&gt;
&lt;li&gt;随机分配问题&lt;/li&gt;
&lt;li&gt;简单随机抽样问题&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;几何概型
&lt;ol&gt;
&lt;li&gt;概念
&lt;ul&gt;
&lt;li&gt;样本空间（基本事件空间）$\Omega$是一个可度量的有界区域&lt;/li&gt;
&lt;li&gt;每个样本点（基本事件）发生的可能性都一样，即样本点落入$\Omega$的某一个可度量的子区域$S$的可能性大小和S的几何度量成正比。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0813学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0813/</link>
        <pubDate>Wed, 13 Aug 2025 09:45:22 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0813/</guid>
        <description>&lt;h2 id=&#34;计算机组成原理&#34;&gt;计算机组成原理
&lt;/h2&gt;&lt;h3 id=&#34;计算机系统概述&#34;&gt;计算机系统概述
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;冯诺依曼计算机的特点
&lt;ol&gt;
&lt;li&gt;采用“存储程序”的工作方式&lt;/li&gt;
&lt;li&gt;计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备五大设备类型&lt;/li&gt;
&lt;li&gt;指令和数据以同等地位存储在存储器中，形式上没有任何区别，但计算机应能区分它们&lt;/li&gt;
&lt;li&gt;指令和数据均用二进制代码表示&lt;/li&gt;
&lt;li&gt;指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;计算机的功能部件
&lt;ol&gt;
&lt;li&gt;输入设备&lt;/li&gt;
&lt;li&gt;输出设备&lt;/li&gt;
&lt;li&gt;存储器&lt;/li&gt;
&lt;li&gt;运算器&lt;/li&gt;
&lt;li&gt;控制器&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;计算机软件
&lt;ol&gt;
&lt;li&gt;系统软件和应用软件&lt;/li&gt;
&lt;li&gt;三个级别的语言&lt;/li&gt;
&lt;li&gt;软件和硬件的逻辑功能等价性&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;计算机系统的层次结构
&lt;ol&gt;
&lt;li&gt;微程序机器层&lt;/li&gt;
&lt;li&gt;传统机器语言层&lt;/li&gt;
&lt;li&gt;操作系统层&lt;/li&gt;
&lt;li&gt;汇编语言层&lt;/li&gt;
&lt;li&gt;高级语言层&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;计算机系统的工作原理
&lt;ol&gt;
&lt;li&gt;“存储程序”工作方式&lt;/li&gt;
&lt;li&gt;从源文件到可执行文件*
&lt;ol&gt;
&lt;li&gt;预处理阶段(pre process)&lt;/li&gt;
&lt;li&gt;编译阶段(compile)&lt;/li&gt;
&lt;li&gt;汇编阶段(assemble)&lt;/li&gt;
&lt;li&gt;链接阶段(link)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;指令执行过程的描述
&lt;ol&gt;
&lt;li&gt;取指令&lt;/li&gt;
&lt;li&gt;分析指令&lt;/li&gt;
&lt;li&gt;执行指令&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;计算机的性能指标&#34;&gt;计算机的性能指标
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;计算机的主要性能指标&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;机器字长&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据通路带宽&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主存容量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运算速度&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;吞吐量和响应时间&lt;/li&gt;
&lt;li&gt;主频和CPU时钟周期&lt;/li&gt;
&lt;li&gt;CPI(Cycle per Instruction)&lt;/li&gt;
&lt;li&gt;IPS(Instruction per Second)&lt;/li&gt;
&lt;li&gt;CPU执行时间 = CPU时钟周期数/主频 = （指令条数/CPI）/主频&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;CPU的性能取决于三个要素：&lt;strong&gt;主频、CPI和指令条数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;MIPS(Million Instruction per Second) = 指令条数/(执行时间*$10^6$)&lt;/li&gt;
&lt;li&gt;FLOPS(Floating-point Operations Per Second)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基准程序(benchmark)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0811学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0811/</link>
        <pubDate>Mon, 11 Aug 2025 23:43:07 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0811/</guid>
        <description>&lt;h2 id=&#34;数据结构&#34;&gt;数据结构
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;插入排序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直接插入排序&lt;/li&gt;
&lt;li&gt;折半插入排序&lt;/li&gt;
&lt;li&gt;希尔排序&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交换排序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;冒泡排序&lt;/li&gt;
&lt;li&gt;快速排序&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二路归并排序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基数排序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;外部排序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多路平衡归并与败者树&lt;/li&gt;
&lt;li&gt;置换-选择排序&lt;/li&gt;
&lt;li&gt;最佳归并树&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;排序算法的分析和应用&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;算法&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;时间复杂度&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;最好情况&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;平均情况&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;最坏情况&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;空间复杂度&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;稳定性&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;直接插入排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(1)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;是&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;冒泡排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(1)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;是&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;简单选择排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(1)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;否&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;希尔排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(1)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;否&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;快速排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;否&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;堆排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(1)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;否&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;二路归并排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;是&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;基数排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(d(n+r)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(d(n+r))$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(d(n+r)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(1)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;是&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0809学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0809/</link>
        <pubDate>Sat, 09 Aug 2025 23:52:51 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0809/</guid>
        <description>&lt;h2 id=&#34;数据结构-查找&#34;&gt;数据结构-查找
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;顺序查找法&lt;/li&gt;
&lt;li&gt;分块查找法（索引顺序查找）&lt;/li&gt;
&lt;li&gt;折半查找法
&lt;ul&gt;
&lt;li&gt;判定树&lt;/li&gt;
&lt;li&gt;ASL（平均查找长度）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二叉搜索树
&lt;ol&gt;
&lt;li&gt;查找&lt;/li&gt;
&lt;li&gt;插入&lt;/li&gt;
&lt;li&gt;构造&lt;/li&gt;
&lt;li&gt;删除（中序）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;平衡二叉树（AVL）
&lt;ol&gt;
&lt;li&gt;插入
&lt;ul&gt;
&lt;li&gt;LL平衡旋转&lt;/li&gt;
&lt;li&gt;LR平衡旋转&lt;/li&gt;
&lt;li&gt;RR平衡旋转&lt;/li&gt;
&lt;li&gt;RL平衡旋转&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;构造&lt;/li&gt;
&lt;li&gt;删除&lt;/li&gt;
&lt;li&gt;查找&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;红黑树
&lt;ol&gt;
&lt;li&gt;定义
&lt;ul&gt;
&lt;li&gt;每个结点或是黑色或是红色&lt;/li&gt;
&lt;li&gt;根节点是黑色的&lt;/li&gt;
&lt;li&gt;叶节点（虚构的外部节点、NULL节点）都是黑色&lt;/li&gt;
&lt;li&gt;不存在两个相邻的红节点&lt;/li&gt;
&lt;li&gt;对于每个结点，从该结点到任意一个叶节点的简单路径上，所含黑节点的数量相同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结论
&lt;ol&gt;
&lt;li&gt;从根到叶结点的最长路径不大于最短路径的2倍&lt;/li&gt;
&lt;li&gt;有n个内部结点的红黑树的高度$h\leq 2\log_2{(n+1)}$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;插入
&lt;ul&gt;
&lt;li&gt;新插入红黑树的结点初始着为红色&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除*&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0808学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0808/</link>
        <pubDate>Fri, 08 Aug 2025 20:11:28 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0808/</guid>
        <description>&lt;h2 id=&#34;数学-一元微分学的应用&#34;&gt;数学-一元微分学的应用
&lt;/h2&gt;&lt;h3 id=&#34;微分等式&#34;&gt;微分等式
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;零点定理（证明根的存在性）&lt;/li&gt;
&lt;li&gt;单调性（证明根的唯一性）&lt;/li&gt;
&lt;li&gt;罗尔定理及其推论&lt;/li&gt;
&lt;li&gt;实系数奇次方程至少有一个实根($-\infty +\infty$)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;微分不等式&#34;&gt;微分不等式
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;用函数性态（包括单调性、凹凸性和最值）&lt;/li&gt;
&lt;li&gt;用常数变量化证明不等式&lt;/li&gt;
&lt;li&gt;用中值定理证明不等式&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;物理应用与相关变化率&#34;&gt;物理应用与相关变化率
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;物理应用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;速度&lt;/li&gt;
&lt;li&gt;加速度&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相关变化率&lt;/p&gt;
$$
   \dfrac{dA}{dB}=\dfrac{dA}{dC}\cdot\dfrac{dC}{dB}
   $$&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;操作系统-three-easy-pieces&#34;&gt;操作系统-Three easy pieces
&lt;/h2&gt;&lt;h3 id=&#34;segmentation&#34;&gt;Segmentation
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;explicit approach&lt;/p&gt;
&lt;p&gt;[&amp;mdash;&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; ] (address)&lt;/p&gt;
&lt;p&gt;[ segment |         offset        ]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;implicit approach&lt;/p&gt;
&lt;p&gt;Hardware determined.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Coarse segmentation vs. Fine segmentation&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;free-space-management&#34;&gt;Free Space Management
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Low level Mechanisms
&lt;ol&gt;
&lt;li&gt;Splitting and coalescing&lt;/li&gt;
&lt;li&gt;Embedding a free list&lt;/li&gt;
&lt;li&gt;Growing a Heap&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Basic Strategies
&lt;ol&gt;
&lt;li&gt;Best Fit&lt;/li&gt;
&lt;li&gt;First Fit&lt;/li&gt;
&lt;li&gt;Next Fit&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Other Approaches
&lt;ol&gt;
&lt;li&gt;Segregated Lists&lt;/li&gt;
&lt;li&gt;Buddy Allocation&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;introduction-to-paging&#34;&gt;Introduction to Paging
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Page table&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PTE&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://auroraemiya.github.io/npee_learning_log.github.io/posts/0808/PTE.png&#34;
	width=&#34;2034&#34;
	height=&#34;350&#34;
	srcset=&#34;https://auroraemiya.github.io/npee_learning_log.github.io/posts/0808/PTE_hu_6093a7be5b2aaf3a.png 480w, https://auroraemiya.github.io/npee_learning_log.github.io/posts/0808/PTE_hu_7cba0b1a9e3e7fa4.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Page table entry&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;581&#34;
		data-flex-basis=&#34;1394px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0807学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0807/</link>
        <pubDate>Thu, 07 Aug 2025 19:33:44 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0807/</guid>
        <description>&lt;h2 id=&#34;数学-太好了是中值定理我们有救了&#34;&gt;数学-太好了是中值定理我们有救了
&lt;/h2&gt;&lt;h3 id=&#34;中值定理&#34;&gt;中值定理
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;有界与最值定理：&lt;/p&gt;
&lt;p&gt;若函数 $f$ 在闭区间 $[a, b]$ 上&lt;strong&gt;连续&lt;/strong&gt;，则 $f$ 在 $[a, b]$ 上取得&lt;strong&gt;最大值&lt;/strong&gt;和&lt;strong&gt;最小值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;即存在 $x_{\min}, x_{\max} \in [a, b]$ 使得：&lt;/p&gt;
$$
   f(x_{\min}) \le f(x) \le f(x_{\max}),\quad \forall x \in [a,b]
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;界值定理&lt;/p&gt;
&lt;p&gt;设 $f$ 在闭区间 $[a, b]$ 上连续，若 $f(a) &amp;lt; 0 &amp;lt; f(b)$，则存在 $c \in (a, b)$ 使得 $f(c) = 0$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均值定理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;零点定理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;费马定理：&lt;/p&gt;
&lt;p&gt;若函数 $f$ 在 $x_0$ 点可导，且在该点取得极值（极大或极小），则：&lt;/p&gt;
$$
     f&#39;(x_0) = 0
     $$&lt;ul&gt;
&lt;li&gt;(引理)导数零点定理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;罗尔定理&lt;/p&gt;
&lt;p&gt;设 $f$ 在 $[a, b]$ 上连续，在 $(a,b)$ 上可导，且：&lt;/p&gt;
$$
     f(a) = f(b)
     $$&lt;p&gt;则存在 $c \in (a, b)$ 使得：&lt;/p&gt;
$$
     f&#39;(c) = 0
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拉格朗日中值定理&lt;/p&gt;
&lt;p&gt;设 $f$ 在 $[a,b]$ 上连续，$(a,b)$ 上可导，则存在 $c \in (a,b)$，使得：&lt;/p&gt;
$$
     f&#39;(c) = \frac{f(b) - f(a)}{b - a}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;柯西中值定理&lt;/p&gt;
&lt;p&gt;设函数 $f,g$ 在 $[a,b]$ 上连续，$(a,b)$ 可导，且 $g&amp;rsquo;(x) \ne 0$ 于 $(a,b)$，则存在 $c \in (a,b)$，使得：&lt;/p&gt;
$$
     \frac{f&#39;(c)}{g&#39;(c)} = \frac{f(b) - f(a)}{g(b) - g(a)}
     $$&lt;h3 id=&#34;&#34;&gt;
&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;泰勒公式&lt;/p&gt;
&lt;p&gt;若 $f \in C^{n+1}[a,b]$，则对 $x \in [a,b]$，存在 $\xi$ 介于 $a$ 与 $x$ 之间，使得：&lt;/p&gt;
$$
     f(x) = f(a) + f&#39;(a)(x - a) + \cdots + \frac{f^{(n)}(a)}{n!}(x - a)^n + \frac{f^{(n+1)}(\xi)}{(n+1)!}(x - a)^{n+1}
     $$&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>0806学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0806/</link>
        <pubDate>Wed, 06 Aug 2025 20:32:24 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0806/</guid>
        <description>&lt;h2 id=&#34;操作系统-three-easy-pieces&#34;&gt;操作系统-three easy pieces
&lt;/h2&gt;&lt;h3 id=&#34;memory-api&#34;&gt;Memory API
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void * malloc(size_t size)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void free(void* ptr)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;common-errors&#34;&gt;Common Errors
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Forgetting To Allocate Memory&lt;/li&gt;
&lt;li&gt;Not Allocating Enough Memory&lt;/li&gt;
&lt;li&gt;Forgetting To Initializing Memory&lt;/li&gt;
&lt;li&gt;Forgetting To Free Memory&lt;/li&gt;
&lt;li&gt;Freeing Memory Before You Are Done With It&lt;/li&gt;
&lt;li&gt;Freeing Memory Repeatedly&lt;/li&gt;
&lt;li&gt;Calling &lt;code&gt;free()&lt;/code&gt; Incorrectly&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;other-call&#34;&gt;Other Call
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;calloc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;realloc()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;address-translation&#34;&gt;Address Translation
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;hardware-based address translation: Base and bound&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://auroraemiya.github.io/npee_learning_log.github.io/posts/0806/Base_and_bound.png&#34;
	width=&#34;723&#34;
	height=&#34;1122&#34;
	srcset=&#34;https://auroraemiya.github.io/npee_learning_log.github.io/posts/0806/Base_and_bound_hu_aba0641098e337a8.png 480w, https://auroraemiya.github.io/npee_learning_log.github.io/posts/0806/Base_and_bound_hu_72a071f4a027da31.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;mechanism&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;64&#34;
		data-flex-basis=&#34;154px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0804学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0804/</link>
        <pubDate>Mon, 04 Aug 2025 20:51:06 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0804/</guid>
        <description>&lt;h2 id=&#34;操作系统-io管理&#34;&gt;操作系统-IO管理
&lt;/h2&gt;&lt;h3 id=&#34;io层次结构&#34;&gt;IO层次结构
&lt;/h3&gt;&lt;p&gt;计算机的外部设备（I/O 设备）种类繁多，特性千差万别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;速度差异巨大：&lt;/strong&gt; CPU 的速度比键盘快上亿倍，但比高速的 NVMe SSD 又慢一些。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能各异：&lt;/strong&gt; 打印机是输出设备，键盘是输入设备，硬盘既是输入也是输出设备。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制方式复杂：&lt;/strong&gt; 每个设备都有自己独特的指令集、寄存器和工作协议。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果让每个应用程序都去直接和这些具体的硬件打交道，那将是一场灾难。因此，操作系统设计了一个分层的结构来管理 I/O，其主要目标是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;设备独立性（Device Independence）：&lt;/strong&gt; 应用程序的编写不应依赖于具体的物理设备。例如，一个程序向一个文件写入数据，它不应该关心这个文件是存在于机械硬盘、U盘还是网络存储上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;统一接口（Uniform Interface）：&lt;/strong&gt; 为应用程序提供一个简洁、一致的访问接口。在类 Unix 系统中，这个思想的极致体现就是“一切皆文件”，无论是访问硬盘、键盘还是打印机，都可以使用类似 &lt;code&gt;read()&lt;/code&gt; 和 &lt;code&gt;write()&lt;/code&gt; 的函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;错误处理（Error Handling）：&lt;/strong&gt; 在尽可能低的层次处理设备错误，只将无法解决的严重错误向上层报告，简化上层软件的逻辑。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;效率与性能（Efficiency and Performance）：&lt;/strong&gt; 通过缓冲（Buffering）、缓存（Caching）和异步操作等技术，协调高速 CPU 与低速设备之间的矛盾，提高系统整体吞吐量。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I/O 软件通常被组织成一个四到五层的结构。一个 I/O 请求会从顶层逐级向下传递，直到硬件；而操作完成的信号和数据则会从底层逐级向上传递。&lt;/p&gt;
&lt;p&gt;下面是从上到下（从用户到硬件）的层次结构：&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;第-1-层用户层-io-软件-user-level-io-software&#34;&gt;&lt;strong&gt;第 1 层：用户层 I/O 软件 (User-Level I/O Software)&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;这是最靠近应用程序的一层，它不是操作系统内核的一部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能：&lt;/strong&gt; 为应用程序员提供方便的接口库（Library），这些库函数最终会通过**系统调用（System Call）**请求内核的服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;例子：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;C语言中的标准 I/O 库函数，如 &lt;code&gt;printf()&lt;/code&gt;, &lt;code&gt;scanf()&lt;/code&gt;, &lt;code&gt;fopen()&lt;/code&gt;, &lt;code&gt;fread()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;各种编程语言提供的 I/O 库。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作流程：&lt;/strong&gt; 比如，当你在程序中调用 &lt;code&gt;printf(&amp;quot;Hello&amp;quot;)&lt;/code&gt; 时，&lt;code&gt;printf&lt;/code&gt; 函数会格式化字符串，然后调用底层的 &lt;code&gt;write()&lt;/code&gt; 系统调用，请求内核将数据输出到屏幕。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;第-2-层设备无关的操作系统软件-device-independent-os-software&#34;&gt;&lt;strong&gt;第 2 层：设备无关的操作系统软件 (Device-Independent OS Software)&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;这是 I/O 结构的核心，它实现了设备独立性的主要逻辑。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能：&lt;/strong&gt; 提供一个对所有设备都统一的框架。它负责处理所有设备共有的功能。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;统一接口：&lt;/strong&gt; 向用户层提供统一的系统调用接口（如 &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设备命名：&lt;/strong&gt; 将设备映射到文件系统中的名字（例如 Linux 中的 &lt;code&gt;/dev/sda1&lt;/code&gt; 代表第一个硬盘的第一个分区）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设备保护：&lt;/strong&gt; 检查用户是否有权限访问某个设备。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提供缓冲（Buffering）：&lt;/strong&gt; 在用户空间和设备之间提供数据缓冲区，以协调速度差异。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分配与释放：&lt;/strong&gt; 管理设备的分配和释放，例如独占设备（如打印机）的使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;例子：&lt;/strong&gt; Linux 中的虚拟文件系统（VFS）层就扮演了这个角色。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;第-3-层设备驱动程序-device-drivers&#34;&gt;&lt;strong&gt;第 3 层：设备驱动程序 (Device Drivers)&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;这是操作系统内核中与特定设备直接相关的部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能：&lt;/strong&gt; 充当“翻译官”的角色。它接收来自上层（设备无关层）的抽象命令（如“从这个设备读取 512 字节”），并将其翻译成设备控制器能够理解的具体指令（如向设备的某个寄存器写入特定的值）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;设备特定：&lt;/strong&gt; 每种类型的设备（或一个设备家族）都有一个专门的驱动程序。例如，NVIDIA 显卡有其驱动，Intel 的网卡有它的驱动。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可加载模块：&lt;/strong&gt; 现代操作系统通常将驱动程序实现为内核模块，可以在系统运行时动态加载或卸载，而无需重新编译整个内核。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作流程：&lt;/strong&gt; 驱动程序设置好设备寄存器，命令设备开始工作后，它通常会阻塞（等待）直到设备完成操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;第-4-层中断处理程序-interrupt-handlers&#34;&gt;&lt;strong&gt;第 4 层：中断处理程序 (Interrupt Handlers)&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;这是处理硬件与软件交互最底层、最直接的部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能：&lt;/strong&gt; 当 I/O 设备完成一项任务（例如，硬盘读完一个数据块）或者发生错误时，它会向 CPU 发送一个&lt;strong&gt;中断信号（Interrupt）&lt;/strong&gt;。中断处理程序就是被这个信号触发而运行的一段代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作流程：&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;CPU 暂停当前正在执行的任何任务。&lt;/li&gt;
&lt;li&gt;保存当前任务的上下文（寄存器状态等）。&lt;/li&gt;
&lt;li&gt;跳转到预设的中断处理程序地址并开始执行。&lt;/li&gt;
&lt;li&gt;中断处理程序分析中断原因，进行相应处理（例如，将从设备读取的数据放入缓冲区，并唤醒正在等待这个数据的设备驱动程序）。&lt;/li&gt;
&lt;li&gt;处理完毕后，恢复之前被暂停任务的上下文，让它继续运行。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;核心作用：&lt;/strong&gt; 实现了真正的异步操作，让 CPU 在等待 I/O 时可以去做别的事情，而不是空闲等待。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;第-5-层硬件-hardware&#34;&gt;&lt;strong&gt;第 5 层：硬件 (Hardware)&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;这是层次结构的最底层，包含了物理设备本身及其控制器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;组成：&lt;/strong&gt; 设备本身（如磁盘盘片、打印机喷头）和设备控制器（一块包含寄存器和逻辑电路的芯片，负责与 CPU 通信）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能：&lt;/strong&gt; 真正执行 I/O 操作的物理实体。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;一次-io-请求的完整流程以读文件为例&#34;&gt;一次 I/O 请求的完整流程（以读文件为例）
&lt;/h4&gt;&lt;p&gt;假设一个用户程序执行 &lt;code&gt;read(fd, buffer, nbytes)&lt;/code&gt; 来读取文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;用户层：&lt;/strong&gt; &lt;code&gt;read()&lt;/code&gt; 库函数打包参数，并发起一个&lt;strong&gt;系统调用&lt;/strong&gt;陷入内核。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设备无关层：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;内核的设备无关软件接收到请求。&lt;/li&gt;
&lt;li&gt;它首先检查内核的&lt;strong&gt;缓冲区缓存（Buffer Cache）&lt;/strong&gt;，看请求的数据是否已经存在。如果命中，则直接从缓存复制数据到用户 &lt;code&gt;buffer&lt;/code&gt;，请求结束。&lt;/li&gt;
&lt;li&gt;如果未命中，它会计算出需要从哪个设备的哪个物理位置读取数据。&lt;/li&gt;
&lt;li&gt;然后调用该设备的&lt;strong&gt;驱动程序&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设备驱动层：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;设备驱动程序接收到请求（例如，“读取硬盘的第 12345 号逻辑块”）。&lt;/li&gt;
&lt;li&gt;它将这个抽象请求翻译成设备控制器能懂的命令，并把这些命令写入设备控制器的寄存器中。&lt;/li&gt;
&lt;li&gt;驱动程序随后&lt;strong&gt;阻塞&lt;/strong&gt;当前进程（将其放入等待队列），并让出 CPU。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬件层：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;设备控制器开始工作，驱动硬盘马达，移动磁头，读取数据到其内部缓冲区。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断处理层（返回过程）：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;当硬件完成数据读取后，它向 CPU 发送一个&lt;strong&gt;中断&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;CPU 捕获中断，并执行对应的&lt;strong&gt;中断处理程序&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;中断处理程序从设备控制器的缓冲区取出数据，放入内核的缓冲区缓存中。&lt;/li&gt;
&lt;li&gt;然后，它唤醒之前被阻塞的设备驱动进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回上层：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;被唤醒的设备驱动程序得知操作已完成。&lt;/li&gt;
&lt;li&gt;设备无关层将数据从内核的缓冲区缓存复制到用户程序指定的 &lt;code&gt;buffer&lt;/code&gt; 中。&lt;/li&gt;
&lt;li&gt;系统调用返回，用户程序从 &lt;code&gt;read()&lt;/code&gt; 调用处继续执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;层次&lt;/th&gt;
          &lt;th&gt;主要功能&lt;/th&gt;
          &lt;th&gt;例子&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;用户层软件&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;提供方便的编程接口，发起系统调用&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;printf()&lt;/code&gt;, &lt;code&gt;fopen()&lt;/code&gt; 等库函数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;设备无关OS软件&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;提供统一接口，设备命名，缓冲，错误报告，分配与释放&lt;/td&gt;
          &lt;td&gt;虚拟文件系统(VFS)，缓冲区缓存管理&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;设备驱动程序&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;设置设备寄存器，检查设备状态，将抽象命令翻译为具体指令&lt;/td&gt;
          &lt;td&gt;显卡驱动，网卡驱动，磁盘驱动&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;中断处理程序&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;响应硬件中断，保存CPU状态，唤醒驱动程序&lt;/td&gt;
          &lt;td&gt;I/O 完成中断，时钟中断&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;硬件&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;执行具体的I/O操作&lt;/td&gt;
          &lt;td&gt;磁盘控制器，键盘控制器，物理设备本身&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;(Output by Gemini2.5pro)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;dma&#34;&gt;DMA
&lt;/h3&gt;&lt;p&gt;（DMA工作流程）&lt;/p&gt;
&lt;p&gt;DMA的出现就是为了将CPU从这种繁琐的搬运工作中解放出来。下面是DMA的工作流程，以及各层次扮演的角色：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;步骤&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;动作&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;负责的层次/组件&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;用户程序发起一个读操作（例如 &lt;code&gt;read()&lt;/code&gt; 系统调用）。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;用户层软件&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;系统调用陷入内核，请求被&lt;strong&gt;设备无关的OS软件&lt;/strong&gt;接收。它可能会检查缓存，如果未命中，则确定需要调用哪个驱动。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;设备无关的OS软件&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;设备驱动程序&lt;/strong&gt;被调用。这是最关键的一步，驱动程序开始&lt;strong&gt;配置DMA&lt;/strong&gt;：&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;1. 在内存中分配一个缓冲区（Buffer）。&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;2. 告诉&lt;strong&gt;DMA控制器&lt;/strong&gt;四件事：&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;   - &lt;strong&gt;源地址&lt;/strong&gt;：要从哪个设备寄存器读取数据。&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;   - &lt;strong&gt;目标地址&lt;/strong&gt;：数据要存放到内存的哪个位置（即缓冲区地址）。&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;   - &lt;strong&gt;传输长度&lt;/strong&gt;：要传输多少字节的数据。&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;   - &lt;strong&gt;传输方向&lt;/strong&gt;：是从设备读到内存，还是从内存写到设备。&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;3. 驱动程序向&lt;strong&gt;设备控制器&lt;/strong&gt;发出“开始传输数据给DMA”的命令。&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;4. 驱动程序将当前进程&lt;strong&gt;阻塞&lt;/strong&gt;，并让出CPU给其他进程使用。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;设备驱动程序&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;DMA控制器&lt;/strong&gt;完全接管数据传输。它直接与&lt;strong&gt;设备控制器&lt;/strong&gt;和&lt;strong&gt;内存总线&lt;/strong&gt;交互，将数据块从设备搬运到内存缓冲区，整个过程&lt;strong&gt;无需CPU干预&lt;/strong&gt;。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;硬件层 (DMA控制器 &amp;amp; 设备控制器)&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;数据传输完成后，&lt;strong&gt;DMA控制器&lt;/strong&gt;会向CPU发送一个&lt;strong&gt;中断信号&lt;/strong&gt;，通知任务已完成。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;硬件层 (DMA控制器)&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;CPU捕获中断，并跳转到&lt;strong&gt;中断处理程序&lt;/strong&gt;执行。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;中断处理程序&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;中断处理程序分析中断来源，发现是DMA完成中断。于是它&lt;strong&gt;唤醒&lt;/strong&gt;之前被阻塞的&lt;strong&gt;设备驱动程序&lt;/strong&gt;对应的进程。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;中断处理程序&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;8&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;驱动程序被唤醒后，知道数据已经安全地存放在内存缓冲区里了。它进行一些清理工作，并将结果报告给上层。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;设备驱动程序&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;设备无关的OS软件&lt;/strong&gt;将数据从内核的缓冲区复制到用户程序的缓冲区，然后系统调用返回。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;设备无关的OS软件&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spooling&#34;&gt;SPOOLing
&lt;/h3&gt;&lt;h3 id=&#34;引导过程&#34;&gt;引导过程
&lt;/h3&gt;&lt;p&gt;好的，我们来详细、系统地讲解一下计算机的&lt;strong&gt;引导过程（Booting Process 或 Bootstrap）&lt;/strong&gt;。这个过程是指从按下电源按钮开始，到操作系统完全加载并准备好与用户交互为止的一系列复杂而有序的步骤。&lt;/p&gt;
&lt;p&gt;“Bootstrap”这个词源于一个古老的说法“pull oneself up by one&amp;rsquo;s bootstraps”（靠自己鞋带把自己拉起来），形象地比喻了计算机在没有任何外部帮助的情况下，如何一步步地“唤醒”自己。&lt;/p&gt;
&lt;p&gt;计算机的引导过程主要可以分为两种主流方式：传统的 &lt;strong&gt;BIOS-MBR&lt;/strong&gt; 方式和现代的 &lt;strong&gt;UEFI-GPT&lt;/strong&gt; 方式。我们分别来介绍。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;1-传统的-bios-mbr-引导过程&#34;&gt;1. 传统的 BIOS-MBR 引导过程
&lt;/h4&gt;&lt;p&gt;这是在2010年之前个人电脑最常见的引导方式。&lt;/p&gt;
&lt;h5 id=&#34;阶段一bios-阶段-固件执行&#34;&gt;&lt;strong&gt;阶段一：BIOS 阶段 (固件执行)&lt;/strong&gt;
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;上电 (Power On)：&lt;/strong&gt; 当你按下电源键，主板上的电源管理单元（PSU）向CPU发送一个“Power Good”信号。CPU接收到信号后，开始执行存储在主板上一个ROM芯片（通常是EEPROM或Flash）中的程序。这个程序就是 &lt;strong&gt;BIOS (Basic Input/Output System)&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;POST (Power-On Self-Test - 开机自检)：&lt;/strong&gt; BIOS 首先会运行开机自检程序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;任务：&lt;/strong&gt; 检查计算机最核心的硬件是否工作正常，包括 CPU、内存（RAM）、显卡、键盘等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反馈：&lt;/strong&gt; 如果自检通过，通常会发出一声短促的“嘀”声。如果发现严重故障（如内存没插好），它会通过不同的蜂鸣声组合来报警。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;初始化硬件 (Initialization)：&lt;/strong&gt; BIOS 初始化一些关键的硬件设备，为后续加载操作系统做准备。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;选择引导设备 (Boot Device Selection)：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BIOS会根据预设的启动顺序（Boot Order，可在BIOS设置中修改），依次检查可引导的存储设备，如硬盘、U盘、光驱、网络等。&lt;/li&gt;
&lt;li&gt;它会检查每个设备的&lt;strong&gt;第一个扇区（512字节）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;加载 MBR (Master Boot Record - 主引导记录)：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当BIOS找到一个可引导的硬盘时，它会检查这个硬盘的第一个扇区（也称为0号扇区）的最后两个字节是否为 &lt;code&gt;0x55AA&lt;/code&gt;（称为&lt;strong&gt;引导签名&lt;/strong&gt;）。&lt;/li&gt;
&lt;li&gt;如果签名正确，BIOS就会将这整个512字节的&lt;strong&gt;主引导记录（MBR）&lt;strong&gt;加载到内存的一个固定地址（通常是 &lt;code&gt;0x7C00&lt;/code&gt;）处，然后将CPU的控制权&lt;/strong&gt;转交&lt;/strong&gt;给这段刚刚加载的代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;到此，BIOS的任务彻底完成。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;阶段二mbr-与-bootloader-阶段-硬盘代码执行&#34;&gt;&lt;strong&gt;阶段二：MBR 与 Bootloader 阶段 (硬盘代码执行)&lt;/strong&gt;
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;MBR 执行：&lt;/strong&gt; CPU 开始执行内存中 &lt;code&gt;0x7C00&lt;/code&gt; 地址处的MBR代码。MBR非常小，只有不到446字节的代码空间。它的任务很简单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在MBR内部的分区表中，找到被标记为“&lt;strong&gt;活动&lt;/strong&gt;”的那个分区（只有一个）。&lt;/li&gt;
&lt;li&gt;将该活动分区的&lt;strong&gt;第一个扇区&lt;/strong&gt;——称为**分区引导记录（PBR - Partition Boot Record）**或卷引导记录（VBR）——加载到内存中。&lt;/li&gt;
&lt;li&gt;将CPU控制权转交给这段PBR代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Bootloader 执行：&lt;/strong&gt; PBR中的代码通常是**操作系统加载器（Bootloader）**的第一部分。例如，Windows的 &lt;code&gt;bootmgr&lt;/code&gt; 或 Linux 的 &lt;code&gt;GRUB (GRand Unified Bootloader)&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于一个扇区太小，Bootloader通常会分为多个阶段。第一阶段的代码（在PBR中）非常简单，其唯一任务就是从文件系统中加载Bootloader的后续、更复杂的阶段代码。&lt;/li&gt;
&lt;li&gt;Bootloader的功能要强大得多，它能够识别和解析文件系统（如NTFS, ext4），因为它需要找到并加载操作系统的核心文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;阶段三操作系统内核加载&#34;&gt;&lt;strong&gt;阶段三：操作系统内核加载&lt;/strong&gt;
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;加载内核 (Kernel Loading)：&lt;/strong&gt; Bootloader（如GRUB）会根据其配置文件（如 &lt;code&gt;grub.cfg&lt;/code&gt;）中的指令，找到操作系统内核文件（如Windows的 &lt;code&gt;ntoskrnl.exe&lt;/code&gt; 或Linux的 &lt;code&gt;vmlinuz&lt;/code&gt;）和初始内存盘（&lt;code&gt;initrd.img&lt;/code&gt;）等，并将它们加载到内存中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启动内核 (Kernel Initialization)：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bootloader将CPU控制权最终交给加载到内存中的&lt;strong&gt;操作系统内核&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;内核开始执行，它会：
&lt;ul&gt;
&lt;li&gt;初始化更高级的硬件驱动程序。&lt;/li&gt;
&lt;li&gt;启动核心的系统进程（如Windows的 &lt;code&gt;System&lt;/code&gt;进程，Linux的 &lt;code&gt;systemd&lt;/code&gt;或 &lt;code&gt;init&lt;/code&gt;进程）。&lt;/li&gt;
&lt;li&gt;挂载根文件系统。&lt;/li&gt;
&lt;li&gt;启动用户界面的相关服务，最终显示登录界面或桌面。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;至此，整个引导过程完成。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;2-现代的-uefi-gpt-引导过程&#34;&gt;2. 现代的 UEFI-GPT 引导过程
&lt;/h4&gt;&lt;p&gt;UEFI (Unified Extensible Firmware Interface) 是BIOS的现代替代品，它克服了BIOS的许多限制。GPT (GUID Partition Table) 是MBR的替代分区方案。&lt;/p&gt;
&lt;p&gt;UEFI的引导过程更直接、更灵活、更安全。&lt;/p&gt;
&lt;h5 id=&#34;阶段一uefi-固件执行&#34;&gt;&lt;strong&gt;阶段一：UEFI 固件执行&lt;/strong&gt;
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;上电与 SEC (Security) 阶段：&lt;/strong&gt; 与BIOS类似，系统上电，CPU开始执行UEFI固件代码。首先是安全验证阶段，为后续执行建立一个可信的环境。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;PEI (Pre-EFI Initialization) 阶段：&lt;/strong&gt; 类似于POST，进行核心硬件（CPU、芯片组、内存）的初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DXE (Driver Execution Environment) 阶段：&lt;/strong&gt; 这是UEFI的核心。UEFI固件会加载和执行大量的&lt;strong&gt;UEFI驱动程序&lt;/strong&gt;。这使得UEFI在引导阶段就能识别复杂硬件，并能识别GPT分区表和FAT32等文件系统。&lt;strong&gt;这是UEFI与BIOS最本质的区别&lt;/strong&gt;——BIOS不懂文件系统，而UEFI懂。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BDS (Boot Device Select) 阶段：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UEFI固件会读取存储在&lt;strong&gt;NVRAM&lt;/strong&gt;（一种非易失性RAM）中的启动项配置。&lt;/li&gt;
&lt;li&gt;它不再是盲目地去读设备的第一个扇区。相反，它直接去访问硬盘上一个特殊的、必需的、格式为FAT32的小分区，称为 &lt;strong&gt;EFI系统分区 (ESP - EFI System Partition)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;UEFI会根据启动项配置，在ESP分区中查找并执行指定的&lt;strong&gt;引导加载程序文件&lt;/strong&gt;。这个文件是一个标准的 &lt;code&gt;.efi&lt;/code&gt; 可执行文件，例如 &lt;code&gt;\EFI\Microsoft\Boot\bootmgfw.efi&lt;/code&gt; (Windows) 或 &lt;code&gt;\EFI\ubuntu\shimx64.efi&lt;/code&gt; (Ubuntu)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;阶段二操作系统加载&#34;&gt;&lt;strong&gt;阶段二：操作系统加载&lt;/strong&gt;
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;执行EFI引导程序：&lt;/strong&gt; UEFI固件直接将CPU控制权交给从ESP分区加载的 &lt;code&gt;.efi&lt;/code&gt; 文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加载操作系统：&lt;/strong&gt; 这个 &lt;code&gt;.efi&lt;/code&gt;引导程序（如Windows Boot Manager或GRUB2）接下来负责加载操作系统的内核和相关文件，并将控制权交给内核。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内核初始化：&lt;/strong&gt; 后续步骤与BIOS-MBR方式基本相同，内核接管系统，完成初始化，并启动用户界面。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;bios-mbr-vs-uefi-gpt-对比&#34;&gt;BIOS-MBR vs. UEFI-GPT 对比
&lt;/h4&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;特性&lt;/th&gt;
          &lt;th&gt;BIOS-MBR&lt;/th&gt;
          &lt;th&gt;UEFI-GPT&lt;/th&gt;
          &lt;th&gt;优势&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;分区方案&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;MBR (Master Boot Record)&lt;/td&gt;
          &lt;td&gt;GPT (GUID Partition Table)&lt;/td&gt;
          &lt;td&gt;GPT支持超过2TB的硬盘和最多128个主分区，更可靠。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;引导方式&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;读设备第一个扇区，链式加载&lt;/td&gt;
          &lt;td&gt;直接从ESP分区加载 &lt;code&gt;.efi&lt;/code&gt; 文件&lt;/td&gt;
          &lt;td&gt;UEFI更直接、更快速，因为它认识文件系统，无需链式跳转。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;代码架构&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;16位汇编，实模式&lt;/td&gt;
          &lt;td&gt;32/64位C语言，保护模式&lt;/td&gt;
          &lt;td&gt;UEFI像一个微型操作系统，功能强大，界面友好（支持鼠标）。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;安全性&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;无原生安全机制&lt;/td&gt;
          &lt;td&gt;支持&lt;strong&gt;安全启动 (Secure Boot)&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;Secure Boot可以防止未经签名的恶意引导程序（如Bootkit）加载。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;兼容性&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;兼容性好，但技术老旧&lt;/td&gt;
          &lt;td&gt;现代主流标准，但老旧系统可能不支持&lt;/td&gt;
          &lt;td&gt;UEFI是未来趋势。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;总而言之，计算机的引导过程是一个从固化在硬件中的最简单代码开始，一步步加载更复杂软件，最终将整个庞大的操作系统“唤醒”并交出控制权的接力过程。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0731学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0731/</link>
        <pubDate>Thu, 31 Jul 2025 20:04:32 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0731/</guid>
        <description>&lt;h2 id=&#34;操作系统&#34;&gt;操作系统
&lt;/h2&gt;&lt;h3 id=&#34;设备独立性软件&#34;&gt;设备独立性软件
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;高速缓存与缓冲区&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;磁盘高速缓存&lt;/li&gt;
&lt;li&gt;缓冲区
&lt;ol&gt;
&lt;li&gt;缓冲CPU与I/O设备间速度不匹配的矛盾&lt;/li&gt;
&lt;li&gt;减少对CPU的中断频率，放宽对CPU中断响应时间的限制&lt;/li&gt;
&lt;li&gt;解决基本数据单元大小（数据粒度）不匹配的问题&lt;/li&gt;
&lt;li&gt;提高CPU和IO设备之间的并行性&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;单缓冲&lt;/li&gt;
&lt;li&gt;双缓冲&lt;/li&gt;
&lt;li&gt;循环缓冲&lt;/li&gt;
&lt;li&gt;缓冲池&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设备分配与回收&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设备分配的数据结构
&lt;ol&gt;
&lt;li&gt;设备控制表（DCT）
&lt;ol&gt;
&lt;li&gt;设备控制表&lt;/li&gt;
&lt;li&gt;设备类型&lt;/li&gt;
&lt;li&gt;设备标识符&lt;/li&gt;
&lt;li&gt;设备状态&lt;/li&gt;
&lt;li&gt;指向控制器表的指针&lt;/li&gt;
&lt;li&gt;重复执行次数或时间&lt;/li&gt;
&lt;li&gt;设备队列的队首指针&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;控制器控制表（COCT）&lt;/li&gt;
&lt;li&gt;通道控制表（CHCT）&lt;/li&gt;
&lt;li&gt;系统设备表（SDT）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设备分配时应考虑的因素&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设备的固有属性
&lt;ol&gt;
&lt;li&gt;独占设备&lt;/li&gt;
&lt;li&gt;共享设备&lt;/li&gt;
&lt;li&gt;虚拟设备&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;设备分配算法
&lt;ol&gt;
&lt;li&gt;FCFS&lt;/li&gt;
&lt;li&gt;最高优先级优先算法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;设备分配中的安全性
&lt;ol&gt;
&lt;li&gt;安全分配方式&lt;/li&gt;
&lt;li&gt;不安全分配方式&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;设备分配步骤
&lt;ol&gt;
&lt;li&gt;分配设备&lt;/li&gt;
&lt;li&gt;分配控制器&lt;/li&gt;
&lt;li&gt;分配通道&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SPOOLing （假脱机技术）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入井和输出井&lt;/li&gt;
&lt;li&gt;输入缓冲区和输出缓冲区&lt;/li&gt;
&lt;li&gt;输入进程和输出进程&lt;/li&gt;
&lt;li&gt;井管理程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://auroraemiya.github.io/npee_learning_log.github.io/posts/0731/SPOOLing.png&#34;
	width=&#34;1531&#34;
	height=&#34;734&#34;
	srcset=&#34;https://auroraemiya.github.io/npee_learning_log.github.io/posts/0731/SPOOLing_hu_402004d5932a64c9.png 480w, https://auroraemiya.github.io/npee_learning_log.github.io/posts/0731/SPOOLing_hu_3336df8fbee31f45.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;SPOOLing &amp; Buffering&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;208&#34;
		data-flex-basis=&#34;500px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;磁盘和固态硬盘&#34;&gt;磁盘和固态硬盘
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;磁盘&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁头&lt;/li&gt;
&lt;li&gt;磁道&lt;/li&gt;
&lt;li&gt;扇区&lt;/li&gt;
&lt;li&gt;盘块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;磁盘是一种主要的计算机辅助存储设备，它利用磁性记录来存储和检索数字信息。为了有效地组织和访问这些数据，磁盘被划分成多个层级的结构。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;物理结构：硬件层面&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;物理结构是磁盘驱动器本身的硬件构造，决定了数据是如何被物理存储的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;盘片 (Platter)&lt;/strong&gt;
盘片是构成硬盘的核心部件，它是一个或多个坚硬的、通常由铝、玻璃或陶瓷制成的圆形盘片。盘片的双面都涂有磁性材料，用于存储数据。一个硬盘驱动器通常包含多个堆叠在一起的盘片。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主轴 (Spindle)&lt;/strong&gt;
主轴是一个马达，所有的盘片都围绕它以恒定且极高的速度旋转（例如，每分钟7200转）。主轴的稳定性和转速对硬盘的性能至关重要。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;磁头 (Read/Write Head)&lt;/strong&gt;
每个盘片的每个磁性表面都有一个对应的磁头。磁头负责读取盘片上的磁性信息（转换为数据）或向盘片写入磁性信息（存储数据）。在工作时，磁头在一个微小的气垫上“飞行”，与盘片表面保持极近但又不接触的距离。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;磁道 (Track)&lt;/strong&gt;
当盘片旋转时，磁头保持在某个固定位置，就会在盘片上划出一个看不见的同心圆，这个圆形的路径就是&lt;strong&gt;磁道&lt;/strong&gt;。数据就是沿着这些磁道存储的。每个盘面都有数千个磁道。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;柱面 (Cylinder)&lt;/strong&gt;
在一个多盘片的硬盘中，所有盘片上半径相同的磁道共同构成了一个&lt;strong&gt;柱面&lt;/strong&gt;。想象一下，从上到下穿过所有盘片，将所有相同编号的磁道连接起来，就形成了一个空心的圆柱体。当磁头臂不移动时，它可以在同一个柱面上访问所有盘面上的数据，这比移动磁头臂去访问不同磁道要快得多。因此，相关的数据通常会存储在同一个柱面内以提高访问速度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扇区 (Sector)&lt;/strong&gt;
为了进一步管理数据，每个磁道被划分为若干个小的弧段，这些弧段被称为&lt;strong&gt;扇区&lt;/strong&gt;。扇区是磁盘上进行数据读写的最小物理单位，传统上每个扇区的大小为512字节。在进行读写操作时，磁盘控制器一次至少会读取或写入一个扇区的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结一下物理结构的层级关系：
&lt;strong&gt;硬盘驱动器 &amp;gt; 盘片 &amp;gt; 磁道 &amp;gt; 扇区&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;逻辑结构：操作系统层面&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;操作系统为了更方便、更高效地管理磁盘空间，引入了逻辑结构的概念。它在物理结构的基础上进行了抽象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;盘块 (Block) / 块&lt;/strong&gt;
操作系统与磁盘进行I/O操作时，并不会直接以物理扇区为单位。因为如果每次只读写512字节，对于今天的大文件来说效率太低，会产生大量的I/O请求。因此，操作系统将一个或多个连续的扇区组合在一起，形成一个&lt;strong&gt;盘块&lt;/strong&gt;或&lt;strong&gt;块&lt;/strong&gt;。盘块是操作系统进行文件I/O的基本（逻辑）单位。例如，一个盘块可能由8个扇区组成，那么它的大小就是 4KB (8 * 512B)。当程序请求读取文件时，操作系统会一次性读取至少一个盘块的数据到内存中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;簇 (Cluster)&lt;/strong&gt;
簇是文件系统（如FAT32、NTFS）中用于分配磁盘空间的单位。它也是由一个或多个连续的盘块组成的。当你创建一个文件并写入数据时，文件系统会为这个文件分配一个或多个簇。即使一个文件非常小，比如只有1个字节，它也至少会占用一个完整的簇。这就导致了所谓的“空间浪费”，因为簇内未使用的空间无法被其他文件使用。簇的大小会影响磁盘空间的利用率和文件系统的性能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;大簇&lt;/strong&gt;：对于存储大文件的磁盘，使用较大的簇可以减少文件碎片，提高读写性能（因为文件占用的簇是连续的），但会增加小文件的空间浪费。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;小簇&lt;/strong&gt;：可以更有效地利用磁盘空间来存储小文件，但对于大文件，可能会导致其被分割成更多的簇，增加寻址开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;总结与类比&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了更好地理解这些概念，我们可以用一个“图书馆”来类比：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;硬盘驱动器&lt;/strong&gt; 就像整个 &lt;strong&gt;图书馆大楼&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;盘片&lt;/strong&gt; 就像楼里的 &lt;strong&gt;某一层&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;磁道&lt;/strong&gt; 就像这一层书架上的 &lt;strong&gt;一排书架&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扇区&lt;/strong&gt; 就像书架上的 &lt;strong&gt;一本书&lt;/strong&gt;（这是最小的物理单位）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;盘块 (Block)&lt;/strong&gt; 就像图书馆规定，你借书时不能只借一本，必须借走 &lt;strong&gt;一摞书&lt;/strong&gt;（比如5本）。这是操作系统I/O的最小单位。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;簇 (Cluster)&lt;/strong&gt; 就像图书管理员为了方便管理，把书架划分成很多个 &lt;strong&gt;隔间&lt;/strong&gt;，每个隔间放一摞或多摞书。当你要存放你的资料时，管理员会给你分配一个或多个隔间。这是文件分配的最小单位。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这种分层结构，磁盘既能通过物理设计实现高密度存储，又能通过操作系统和文件系统的逻辑抽象，实现对数据高效、便捷的管理和访问。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;磁盘的管理&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;磁盘的初始化&lt;/p&gt;
&lt;p&gt;低级格式化（物理格式化）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分区&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;磁盘分区&lt;/li&gt;
&lt;li&gt;逻辑格式化（高级格式化）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引导块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;坏块&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;磁盘调度算法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;磁盘的存取时间&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;寻道时间$T_S$：寻道时间是指将磁头臂（Read/Write Head）从当前所在的磁道移动到目标数据所在的磁道所需要的时间。这个时间除跨越$n$条磁道的时间外，还包括启动磁头臂的时间$s$&lt;/p&gt;
$$
            T_s = m\times n+ s
            $$&lt;p&gt;其中$m$是与磁盘驱动器速度有关的常熟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;旋转延迟时间$T_r$。当磁头已经成功定位到目标磁道后，等待盘片旋转，直到目标数据的起始扇区（Sector）转到磁头正下方所需要的时间。设磁盘的旋转速度为$r$&lt;/p&gt;
$$
            T_r = \frac{1}{2r}
            $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传输时间$T_t$。当目标扇区已经到达磁头下方后，实际从盘片上读取数据或向盘片写入数据所花费的时间。这个时间取决于每次所读/写的字节数$b$和磁盘的旋转速度$r$&lt;/p&gt;
$$
            T_t = \frac{b}{rN}
            $$&lt;p&gt;式中，$r$为磁盘每秒的转数，$N$为一个磁道上的字节数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;磁盘调度算法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先来先服务算法：这是最简单的调度算法。它完全按照请求到达队列的先后顺序来处理请求。不考虑磁头当前的位置和请求磁道的远近。&lt;/li&gt;
&lt;li&gt;最短寻道时间优先(SSTF)：SSTF算法选择与磁头当前位置最近的那个请求作为下一个服务对象。这是一种贪心算法，其目标是每次都执行寻道成本最小的操作。&lt;/li&gt;
&lt;li&gt;扫描算法(SCAN)：SCAN算法模仿了电梯的运行方式。磁头在一个方向上移动，沿途服务所有该方向上的请求，直到到达磁盘的最后一个磁道，然后调转方向，继续服务反向的请求。&lt;/li&gt;
&lt;li&gt;循环扫描(C-SCAN)：C-SCAN是SCAN算法的改进版，旨在解决SCAN算法对两端磁道不公平的问题。它规定磁头只在一个方向上扫描并服务请求（例如从0到199）。当到达一端后，它会立即返回到起始端，然后重新开始下一次扫描，返回途中不服务任何请求。
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;算法名称&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;优点 (Advantages)&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;缺点 (Disadvantages)&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;先来先服务 (FCFS)&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;绝对公平&lt;/strong&gt;：所有请求按到达顺序处理，不会有请求被无限期推迟（无饥饿现象）。&lt;strong&gt;实现简单&lt;/strong&gt;：算法逻辑是所有调度算法中最简单的。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;效率低下&lt;/strong&gt;：磁头移动路径完全随机，平均寻道时间很长，导致磁盘整体性能差。`&lt;strong&gt;性能不稳定&lt;/strong&gt;：性能好坏完全取决于请求序列。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;最短寻道时间优先 (SSTF)&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;性能好&lt;/strong&gt;：平均寻道时间显著短于FCFS，系统吞吐量高。&lt;strong&gt;效率高&lt;/strong&gt;：总是选择代价最小的移动，局部性能最优。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;可能产生“饥饿”现象&lt;/strong&gt;：如果新请求总是在磁头当前位置附近产生，那么远离磁头的请求可能会长时间得不到服务。&lt;strong&gt;响应时间不均&lt;/strong&gt;：对不同位置请求的响应机会不均等。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;扫描算法 (SCAN) / 电梯算法&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;性能较好&lt;/strong&gt;：是SSTF和FCFS的一种折中，兼顾了性能和公平性。&lt;strong&gt;无饥饿问题&lt;/strong&gt;：磁头会规律地来回移动，确保所有位置的请求最终都能被处理。``&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;对两端磁道不公平&lt;/strong&gt;：位于磁盘中间区域的磁道比两端磁道的服务频率更高，响应更快。&lt;strong&gt;等待时间不均&lt;/strong&gt;：磁头刚经过的位置需要等待近一个来回周期才能再次被服务。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;循环扫描 (C-SCAN)&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;等待时间更均匀&lt;/strong&gt;：通过单向服务和快速返回，使得所有请求的等待时间更加公平和可预测。&lt;strong&gt;解决了SCAN的不公平问题&lt;/strong&gt;：对所有磁道位置的请求都一视同仁，响应时间方差小。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;额外的寻道开销&lt;/strong&gt;：磁头每次扫描到末端后，都需要一次长距离的“空载”返回（从一端直接跳到另一端），这部分移动不处理任何请求，增加了总的寻道距离。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;减少延迟时间的方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;盘面扇区的交替编号&lt;/li&gt;
&lt;li&gt;磁盘盘面的错位命名&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提高磁盘IO速度的方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;采用磁盘高速缓存&lt;/li&gt;
&lt;li&gt;调整磁盘请求顺序&lt;/li&gt;
&lt;li&gt;提前读&lt;/li&gt;
&lt;li&gt;延迟写&lt;/li&gt;
&lt;li&gt;优化物理块的分布&lt;/li&gt;
&lt;li&gt;虚拟盘&lt;/li&gt;
&lt;li&gt;采用磁盘阵列RAID&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;固态硬盘&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;固态硬盘的特性&lt;/li&gt;
&lt;li&gt;磨损均衡
&lt;ol&gt;
&lt;li&gt;动态磨损均衡&lt;/li&gt;
&lt;li&gt;静态磨损均衡&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0730学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0730/</link>
        <pubDate>Wed, 30 Jul 2025 22:23:38 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0730/</guid>
        <description>&lt;h2 id=&#34;操作系统-io&#34;&gt;操作系统-I/O
&lt;/h2&gt;&lt;h3 id=&#34;文件系统&#34;&gt;文件系统
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;文件系统（自底向上）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;I/O控制层&lt;/li&gt;
&lt;li&gt;基本文件系统&lt;/li&gt;
&lt;li&gt;文件组织模块&lt;/li&gt;
&lt;li&gt;逻辑文件系统&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件系统布局&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件系统在磁盘中的结构
&lt;ol&gt;
&lt;li&gt;主引导记录&lt;/li&gt;
&lt;li&gt;引导块&lt;/li&gt;
&lt;li&gt;超级块&lt;/li&gt;
&lt;li&gt;文件系统中空闲块的信息&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;文件系统在内存中的结构
&lt;ol&gt;
&lt;li&gt;内存中的安装表（mount table）&lt;/li&gt;
&lt;li&gt;内存中的目录结构的缓存&lt;/li&gt;
&lt;li&gt;整个系统的打开文件表&lt;/li&gt;
&lt;li&gt;每个进程的打开文件表，包含进程打开文件的文件描述符&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;虚拟文件系统VFS
&lt;ol&gt;
&lt;li&gt;超级块对象&lt;/li&gt;
&lt;li&gt;索引节点对象&lt;/li&gt;
&lt;li&gt;目录项对象&lt;/li&gt;
&lt;li&gt;文件对象&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;文件系统挂载&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;io&#34;&gt;I/O
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;I/O设备&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;信息交换单位分类
&lt;ol&gt;
&lt;li&gt;块设备&lt;/li&gt;
&lt;li&gt;字符设备&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;传输速率分类
&lt;ol&gt;
&lt;li&gt;低速设备&lt;/li&gt;
&lt;li&gt;中速设备&lt;/li&gt;
&lt;li&gt;高速设备&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;使用特性
&lt;ol&gt;
&lt;li&gt;存储设备&lt;/li&gt;
&lt;li&gt;输入/输出设备&lt;/li&gt;
&lt;li&gt;共享属性
&lt;ol&gt;
&lt;li&gt;独占设备&lt;/li&gt;
&lt;li&gt;共享设备&lt;/li&gt;
&lt;li&gt;虚拟设备&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I/O接口&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设备控制器与CPU的接口&lt;/li&gt;
&lt;li&gt;设备控制器与设备的接口&lt;/li&gt;
&lt;li&gt;I/O逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据传送方式：并行接口、串行接口&lt;/li&gt;
&lt;li&gt;主机访问I/O设备的控制方式：程序查询接口、终端接口、DMA接口&lt;/li&gt;
&lt;li&gt;功能选择的灵活性：可编程接口、不可编程接口&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;端口：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据寄存器&lt;/li&gt;
&lt;li&gt;状态寄存器&lt;/li&gt;
&lt;li&gt;控制寄存器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I/O端口编址方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;独立编址&lt;/li&gt;
&lt;li&gt;统一编址&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I/O控制方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;程序直接控制方式&lt;/li&gt;
&lt;li&gt;中断驱动方式&lt;/li&gt;
&lt;li&gt;DMA方式（重要）&lt;/li&gt;
&lt;li&gt;通道控制方式&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I/O软件层次结构&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户层软件&lt;/li&gt;
&lt;li&gt;设备独立性软件&lt;/li&gt;
&lt;li&gt;设备驱动软件&lt;/li&gt;
&lt;li&gt;中断处理软件&lt;/li&gt;
&lt;li&gt;硬件（非软件层次）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数学-极值点拐点&#34;&gt;数学-极值点？拐点？
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;极值的定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单调性与极值的判别&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单调性的判别&lt;/li&gt;
&lt;li&gt;判别极值的第一充分条件&lt;/li&gt;
&lt;li&gt;判别极值的第二充分条件&lt;/li&gt;
&lt;li&gt;判别极值的第三充分条件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;凹凸性与拐点的概念&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;凹凸性的定义&lt;/li&gt;
&lt;li&gt;拐点的定义&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;凹凸性与拐点的判别&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判别凹凸性&lt;/li&gt;
&lt;li&gt;判别拐点的第一充分条件&lt;/li&gt;
&lt;li&gt;判别拐点的第二充分条件&lt;/li&gt;
&lt;li&gt;判别拐点的第三充分条件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;渐近线&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;铅直渐近线&lt;/li&gt;
&lt;li&gt;水平渐近线&lt;/li&gt;
&lt;li&gt;斜渐近线&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最值或取值范围&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最值的定义&lt;/li&gt;
&lt;li&gt;求区间[a,b]上的连续函数f(x)的最大值和最小值&lt;/li&gt;
&lt;li&gt;求区间(a,b )上的连续函数f(x)的最值或取值范围&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作函数图像&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一般步骤
&lt;ol&gt;
&lt;li&gt;确定定义域、奇偶性、周期性等&lt;/li&gt;
&lt;li&gt;用导数工具确定函数的单调区间、极值点、凹凸区间、拐点&lt;/li&gt;
&lt;li&gt;考查渐近线&lt;/li&gt;
&lt;li&gt;作出函数图像&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;曲率及曲率半径（证明放在下一期笔记中）
&lt;/p&gt;
$$
   \begin{align*}
   k &amp;= \dfrac{|y&#39;&#39;|}{{[1+{(y&#39;)}^2]}^{\frac{3}{2}}}\\
   r &amp;= \frac{1}{k} = \dfrac{{[1+{(y&#39;)}^2]}^{\frac{3}{2}}}{|y&#39;&#39;|},{y}&#39;&#39;\neq0
   \end{align*}
   $$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号:第5讲&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0729学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0729/</link>
        <pubDate>Tue, 29 Jul 2025 23:17:02 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0729/</guid>
        <description>&lt;h2 id=&#34;操作系统-mkdir&#34;&gt;操作系统-mkdir
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;文件的物理结构
&lt;ol&gt;
&lt;li&gt;连续分配&lt;/li&gt;
&lt;li&gt;链接分配
&lt;ul&gt;
&lt;li&gt;隐式链接&lt;/li&gt;
&lt;li&gt;显式链接(FAT,file allocation table)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;索引分配
&lt;ol&gt;
&lt;li&gt;单级索引分配&lt;/li&gt;
&lt;li&gt;多级索引分配&lt;/li&gt;
&lt;li&gt;混合索引分配&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;磁盘的管理和组织
&lt;ol&gt;
&lt;li&gt;磁盘结构
&lt;ul&gt;
&lt;li&gt;surface&lt;/li&gt;
&lt;li&gt;track&lt;/li&gt;
&lt;li&gt;gap&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;磁盘访问时间&lt;/li&gt;
&lt;li&gt;文件存储空间管理
&lt;ol&gt;
&lt;li&gt;空闲表法&lt;/li&gt;
&lt;li&gt;空闲链表法
&lt;ol&gt;
&lt;li&gt;空闲盘块链&lt;/li&gt;
&lt;li&gt;空闲盘区链&lt;/li&gt;
&lt;li&gt;位示图&lt;/li&gt;
&lt;li&gt;成组链表法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;磁盘格式化
&lt;ol&gt;
&lt;li&gt;低级格式化&lt;/li&gt;
&lt;li&gt;高级格式化&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;附系统调用openreadclose使用代码示例&#34;&gt;附：系统调用&lt;code&gt;open(),read(),close()使用代码示例&lt;/code&gt;
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;time.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdbool.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define MAX_BUFFER_SIZE 128
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;do_the_same_thing&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;filename, &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; sleep_enabled);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;argv[])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; sleep_enabled &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; false;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Open a file in read-only mode
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (argc &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;fprintf&lt;/span&gt;(stderr, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Usage: %s &amp;lt;filename&amp;gt; --sleep&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (argc &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;strcmp&lt;/span&gt;(argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;], &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;--sleep&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sleep_enabled &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; true;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;filename &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;pid_t&lt;/span&gt; pid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fork&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// Get the current process ID
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (pid &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;perror&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Failed to fork&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;  (pid &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// Child process
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;do_the_same_thing&lt;/span&gt;(filename, sleep_enabled);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;exit&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (pid &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;do_the_same_thing&lt;/span&gt;(filename, sleep_enabled);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;perror&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Failed to fork&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;do_the_same_thing&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;filename,&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; sleep_enabled)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; fd &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;open&lt;/span&gt;(filename, O_RDONLY); &lt;span style=&#34;color:#75715e&#34;&gt;// O_RDONLY means read-only
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (fd &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;perror&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Failed to open file&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ... use fd ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;ssize_t&lt;/span&gt; bytes_read;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; buffer[MAX_BUFFER_SIZE];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        bytes_read &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;read&lt;/span&gt;(fd, buffer, MAX_BUFFER_SIZE &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// Read up to MAX_BUFFER_SIZE - 1 bytes
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (bytes_read &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// Exit loop on error or EOF
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        buffer[bytes_read] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// Null-terminate the string
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, buffer);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (sleep_enabled)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// Sleep for 1 second to simulate processing time
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;(fd);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// This function is intentionally left empty.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// It serves as a placeholder to demonstrate that the code can be extended.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;课程编号:25-28&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0727学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0727/</link>
        <pubDate>Sun, 27 Jul 2025 18:55:08 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0727/</guid>
        <description>&lt;h2 id=&#34;数学-一元函数微分学&#34;&gt;数学-一元函数微分学
&lt;/h2&gt;&lt;h3 id=&#34;一元函数微分学的概念&#34;&gt;一元函数微分学的概念
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;导数&lt;/p&gt;
$$
   f&#39;(x_0) = \lim\limits_{x\to x_0}\frac{\Delta y}{\Delta x} = \lim\limits_{\Delta x\to 0}\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;导数的几何意义&lt;/p&gt;
$$
   \begin{align*}
   	\text{切线方程：}y-y_0&amp;=f&#39;(x_0)(x-x_0) \\
   	\text{法线方程：}y-y_0&amp;=-\frac{1}{f&#39;(x_0)}(x-x_0),(f&#39;(x_0)\neq0)
   \end{align*}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高阶导数&lt;/p&gt;
$$
   f^{(n)}(x_0) = \lim\limits_{\Delta x\to x_0}\frac{f^{(n-1)}(x)-f^{(n-1)}(x_0)}{x-x_0}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微分概念&lt;/p&gt;
&lt;p&gt;设函数$y=f(x)$在点$x_0$的某邻域内有定义，且$x_0+\Delta x$在该邻域内，对于函数增量&lt;/p&gt;
$$
   \Delta y = f(x_0+\Delta x)- f(x_0)
   $$&lt;p&gt;若存在与$\Delta x$无关的常数$A$，使得&lt;/p&gt;
$$
   \Delta y = A\Delta x + o(\Delta x)
   $$&lt;p&gt;则称$f(x)$在$x=x_0$处可微，且$A\Delta x$为线性主部也叫做$f(x) $在点$x_0$处的微分，记为&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
$$
\left.dy\right|_{x=x_0}A\Delta x = f&#39;(x_0)\mathbf{d}x
$$&lt;h3 id=&#34;一元函数微分学的计算&#34;&gt;一元函数微分学的计算
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本求导公式&lt;/p&gt;
$$
   \begin{align*}
   	\left(x^{\alpha}\right)&#39; &amp;= \alpha x^{\alpha-1}\\
   	\left(a^x\right)&#39; &amp;= a^x\ln{a},(a&gt;0,a\neq 1)\\
   	\left(e^x\right)&#39; &amp;=e^x\\
   		\left(\log_ax\right)&#39; &amp;=\frac{1}{x\ln a},(a&gt;0,a\neq 1)\\
   	\left(\ln|x|\right)&#39; &amp;=\frac{1}{x}\\
   	\left(\sin x \right)&#39; &amp;=\cos x \\
   	\left(\cos x\right)&#39; &amp;=-\sin x \\
   	\left(\arcsin x\right)&#39; &amp;=\frac{1}{\sqrt{1-x^2}}\\
   	\left(\arccos x\right)&#39; &amp;=-\frac{1}{\sqrt{1-x^2}}\\
   	\left(\tan x\right)&#39; &amp;=\sec^2 x\\
   	\left(\cot x \right)&#39; &amp;=-\csc^2 x\\
   	\left(\arctan x\right)&#39; &amp;=\frac{1}{1+x^2}\\
   	\left(\text{arccot} x\right)&#39; &amp;=-\frac{1}{1+x^2}\\
   	\left(\sec x\right)&#39; &amp;=\sec x\tan x\\
   	\left(\csc x\right)&#39; &amp;=-\csc x \cot x\\
   	\left(\ln(x+\sqrt{x^2+1})\right)&#39; &amp;=\frac{1}{x^2+1}\\
   	\left(\ln(x+\sqrt{x^2-1})\right)&#39; &amp;=\frac{1}{x^2-1}\\
   \end{align*}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;四则运算&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;和差&lt;/li&gt;
&lt;li&gt;积&lt;/li&gt;
&lt;li&gt;商&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复合函数的导数与微分形式的不变性&lt;/p&gt;
$$
   \mathbf{d}f(u)=f&#39;(u)\mathbf{d}u
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分段函数的导数&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在分段点使用导数的定义&lt;/li&gt;
&lt;li&gt;在非分段点使用导数公式&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反函数的导数&lt;/p&gt;
&lt;p&gt;设$y=f(x)$单调、可导函数，且$f&amp;rsquo;(x)\neq 0$,则存在反函数$x=\varphi(y)$，且$\frac{dx}{dy} = \frac{1}{\frac{dy}{dx}}$&lt;/p&gt;
$$
   \varphi&#39;(x) =\dfrac{1}{ \dfrac{\mathbf{d} arc\varphi(\varphi(x)) }{\mathbf{d}\varphi(x)}}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隐函数求导法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数方程所确定的函数的导数&lt;/p&gt;
$$
   \begin{align}
   \begin{cases}
   x&amp;= \varphi(t)\\
   y&amp;= \omega(t)\\
   \end{cases}\\
   \frac{dy}{dx} = \dfrac{\frac{dy}{dt}}{\frac{dx}{dt}} = \dfrac{\omega&#39;(t)}{\varphi&#39;(t)}
   \end{align}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对数求导法
&lt;/p&gt;
$$
   \begin{align*}
   \ln y &amp;= \ln f(x)\\
   y&#39; &amp;= \frac{yf&#39;(x)}{f(x)}\\
   \end{align*}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;幂指数求导法
&lt;/p&gt;
$$
   u(x)^{v(x)} = e^{v(x)\ln u(x)}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高阶导数&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;归纳法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;莱布尼茨公式
&lt;/p&gt;
$$
       \begin{align*}
       (u\pm v)^{(n)}&amp;= u^{(n)}\pm v^{(n)}\\
       (u v)^{(n)}&amp;= \sum\limits_{k=0}^{n}C_{n}^{k}u^{(k)}v^{(n-k)}
       \end{align*}
       $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;泰勒展开式，利用展开唯一性&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号：第三、四讲&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0723学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0723/</link>
        <pubDate>Wed, 23 Jul 2025 23:53:15 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0723/</guid>
        <description>&lt;h2 id=&#34;数学-1000题&#34;&gt;数学-1000题
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;对于$x_{n+1}=f(x_n)$的数列极限的判定的过程
&lt;ol&gt;
&lt;li&gt;单调有界&lt;/li&gt;
&lt;li&gt;拉格朗日中值定理&lt;/li&gt;
&lt;li&gt;放缩&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;对于行列式的计算的方法
&lt;ol&gt;
&lt;li&gt;上下三角行列式&lt;/li&gt;
&lt;li&gt;反三角行列式&lt;/li&gt;
&lt;li&gt;范德蒙德行列式&lt;/li&gt;
&lt;li&gt;递推&lt;/li&gt;
&lt;li&gt;归纳&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;英语-不背单词&#34;&gt;英语-不背单词
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;twist&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ultimate&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;strike&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;crucial&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;subordinate&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;anguish&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;subtle&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;constitute&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;suffice&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;eminent&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;prudent&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;courtesy&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;harsh&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;indispensable&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0722学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0722/</link>
        <pubDate>Tue, 22 Jul 2025 23:31:50 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0722/</guid>
        <description>&lt;h2 id=&#34;操作系统--la-pa-ca&#34;&gt;操作系统- (LA-PA-CA)
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;带快表的两级系统的地址翻译过程
&lt;ol&gt;
&lt;li&gt;从逻辑地址映射到物理地址（虚拟存储器）&lt;/li&gt;
&lt;li&gt;从物理地址映射到Cache地址（主存-Cache系统）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;文件和文件系统
&lt;ol&gt;
&lt;li&gt;构成文件的基本单位&lt;/li&gt;
&lt;li&gt;文件的定义&lt;/li&gt;
&lt;li&gt;文件属性&lt;/li&gt;
&lt;li&gt;文件的基本操作&lt;/li&gt;
&lt;li&gt;文件的打开和关闭的操作&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;文件的逻辑结构&lt;/li&gt;
&lt;li&gt;目录管理
&lt;ol&gt;
&lt;li&gt;目录的概念&lt;/li&gt;
&lt;li&gt;文件控制块和索引节点&lt;/li&gt;
&lt;li&gt;目录结构&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;英语-vocabularybuilder&#34;&gt;英语-VocabularyBuilder
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;CRIM,comes from the Latin words for &amp;ldquo;fault or crime&amp;rdquo; or &amp;ldquo;accusation.&amp;rdquo;
&lt;ol&gt;
&lt;li&gt;criminology&lt;/li&gt;
&lt;li&gt;decriminalize&lt;/li&gt;
&lt;li&gt;incriminate&lt;/li&gt;
&lt;li&gt;recrimination&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;PROB,comes from the Latin words for  &amp;ldquo;prove or proof &amp;ldquo;and &amp;ldquo;honesy or integrity.&amp;rdquo;
&lt;ol&gt;
&lt;li&gt;approbation&lt;/li&gt;
&lt;li&gt;probate&lt;/li&gt;
&lt;li&gt;probity&lt;/li&gt;
&lt;li&gt;reprobate&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;GRAV, comes from the Latin word meaning &amp;ldquo;heavy ,weighty ,serious&amp;rdquo;
&lt;ol&gt;
&lt;li&gt;grave&lt;/li&gt;
&lt;li&gt;gravitas&lt;/li&gt;
&lt;li&gt;gravitate&lt;/li&gt;
&lt;li&gt;aggravate&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;LEV,comes from the Latin adjective $levis$,meaning &amp;ldquo;light&amp;rdquo;,and the verb $levare$,meaning &amp;ldquo;to raise or lighten.&amp;rdquo;
&lt;ol&gt;
&lt;li&gt;alleviate&lt;/li&gt;
&lt;li&gt;elevation&lt;/li&gt;
&lt;li&gt;contilever&lt;/li&gt;
&lt;li&gt;levity&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数学-行列式&#34;&gt;数学-行列式
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;行列式的本质定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行列式的性质&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h6 id=&#34;aat&#34;&gt;$|A|=|A^T|$
&lt;/h6&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若行列式中某行(列)元素全为零，则行列式为零&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若行列式中某行(列) 元素有公因子$k\neq0$，则$k$可提到行列式外面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行列式中某行(列)元素均是两个数之和，则可拆成两个行列式之和&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行列式中两行(列)互换，行列式变号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行列式中的两行(列)元素相等或对应成比例，则行列式为零&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行列式的逆序法定义
&lt;/p&gt;
$$
   \begin{vmatrix}
   a_{11} &amp; a_{12} &amp; \cdots&amp;a_{1n}\\
   a_{21} &amp; a_{22} &amp; \cdots&amp;a_{2n}\\
   \vdots &amp; \vdots &amp; &amp;\vdots\\
   a_{n1} &amp; a_{n2} &amp; \cdots&amp;a_{nn}\\
   \end{vmatrix}=\sum\limits_{j_1j_2\cdots j_n}{(-1)^{\tau(j_1j_2\cdots j_n)}}a_{j_1}a_{j_2}\cdots a_{j_n}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行列式的展开定理
&lt;/p&gt;
$$
   |A| = \sum\limits_{j=1}^na_{ij}A_{ij}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;几个重要的行列式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;主对角线行列式(上(下)三角形行列式)
&lt;/p&gt;
$$
      \begin{vmatrix}
      a_{11} &amp; a_{12} &amp; \cdots&amp;a_{1n}\\
      0 &amp; a_{22} &amp; \cdots&amp;a_{2n}\\
      \vdots &amp; \vdots &amp; &amp;\vdots\\
      0 &amp; 0 &amp; \cdots&amp;a_{nn}\\
      \end{vmatrix}=\begin{vmatrix}
      a_{11} &amp; 0 &amp; \cdots&amp;0\\
      a_{21} &amp; a_{22} &amp; \cdots&amp;0\\
      \vdots &amp; \vdots &amp; &amp;\vdots\\
      a_{n1} &amp; a_{n2} &amp; \cdots&amp;a_{nn}\\
      \end{vmatrix}=\begin{vmatrix}
      a_{11} &amp; 0 &amp; \cdots&amp;0\\
      0 &amp; a_{22} &amp; \cdots&amp;0\\
      \vdots &amp; \vdots &amp; &amp;\vdots\\
      0 &amp; 0 &amp; \cdots&amp;a_{nn}\\
      \end{vmatrix}=\prod\limits_{i=1}^n a_{ii}
      $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;副对角线行列式
&lt;/p&gt;
$$
      \begin{vmatrix}
      a_{11} &amp; \cdots &amp; a_{1,n-1}&amp;a_{1n}\\
      a_{21} &amp; \cdots &amp; a_{2,n-1}&amp;0\\
      \vdots &amp;  &amp;\vdots &amp;\vdots\\
      a_{n1} &amp;\cdots&amp;0 &amp;0\\
      \end{vmatrix}=\begin{vmatrix}
      0 &amp; \cdots &amp; 0&amp;a_{1n}\\
      0 &amp;\cdots &amp; a_{2,n-1}&amp;a_{2n}\\
      \vdots &amp; &amp; \vdots &amp;\vdots\\
      a_{n1} &amp;\cdots &amp; a_{n,n-1}&amp;a_{nn}\\
      \end{vmatrix}=\begin{vmatrix}
      0 &amp; \cdots &amp; 0&amp;a_{1n}\\
      0 &amp; \cdots &amp; a_{2,n-1}&amp;0\\
      \vdots &amp; &amp;  \vdots&amp;\vdots\\
      a_{n1} &amp; \cdots &amp; 0&amp;0\\
      \end{vmatrix}=(-1)^{\frac{n(n-1)}{2}}\prod\limits_{i=1}^n a_{i(n+1-i)}
      $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拉普拉斯展开式($A\in R^{m\times m},B\in R^{n\times n}$)
&lt;/p&gt;
$$
      \begin{vmatrix}
      A&amp;O\\
      O&amp;B
      \end{vmatrix}=\begin{vmatrix}
      A&amp;C\\
      O&amp;B
      \end{vmatrix}=\begin{vmatrix}
      A&amp;O\\
      C&amp;B
      \end{vmatrix}=|A||B|
      $$$$
      \begin{vmatrix}
      O&amp;A\\
      B&amp;O
      \end{vmatrix}=\begin{vmatrix}
      C&amp;A\\
      B&amp;O
      \end{vmatrix}=\begin{vmatrix}
      O&amp;A\\
      B&amp;C
      \end{vmatrix}=(-1)^{mn}|A||B|
      $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;范德蒙德行列式,$(1\leq i &amp;lt;j\leq n)$
&lt;/p&gt;
$$
      \begin{vmatrix}
      1&amp;1&amp;\cdots&amp;1\\
      x_1&amp;x_2&amp;\cdots&amp;x_n\\
      x_1^2&amp;x_2^2&amp;\cdots&amp;x_n^2\\
      \vdots&amp;\vdots&amp;&amp;\vdots\\
      x_1^n&amp;x_2^n&amp;\cdots&amp;x_n^n
      \end{vmatrix}=\prod\limits_{i,j}{(x_i-x_j)}
      $$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0721学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0721/</link>
        <pubDate>Mon, 21 Jul 2025 17:53:02 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0721/</guid>
        <description>&lt;h2 id=&#34;英语-vocabulary-builder&#34;&gt;英语-vocabulary builder
&lt;/h2&gt;&lt;p&gt;使用 &lt;code&gt;The Merriam-Webster Vocabulary Builder&lt;/code&gt;作为词根法扩充词汇量的工具书(由网友canon提供)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BENE , latin for &lt;code&gt;well&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;benediction&lt;/li&gt;
&lt;li&gt;benefactor&lt;/li&gt;
&lt;li&gt;benefaciary&lt;/li&gt;
&lt;li&gt;benevolence&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AM, comes form the latin &lt;code&gt;admare&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;amicable&lt;/li&gt;
&lt;li&gt;enamored&lt;/li&gt;
&lt;li&gt;amorous&lt;/li&gt;
&lt;li&gt;paramour&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BELL,comes from the latin word meaning &lt;code&gt;war&lt;/code&gt;.Bellona was the little-known goddess of war .
&lt;ul&gt;
&lt;li&gt;antebellum&lt;/li&gt;
&lt;li&gt;belligerence&lt;/li&gt;
&lt;li&gt;bellicose&lt;/li&gt;
&lt;li&gt;rebellion&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PAC,is related to the Latin words for &amp;ldquo;agree&amp;rdquo; and &amp;ldquo;peace&amp;rdquo;
&lt;ul&gt;
&lt;li&gt;pacify&lt;/li&gt;
&lt;li&gt;pacifist&lt;/li&gt;
&lt;li&gt;pact&lt;/li&gt;
&lt;li&gt;pace&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;操作系统-page--segment&#34;&gt;操作系统-page &amp;amp; segment
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本分页内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;page&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;page frame&lt;/li&gt;
&lt;li&gt;page table&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;页号&lt;/th&gt;
          &lt;th&gt;页内偏移量&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;虚拟地址 = 页号 + 页内偏移&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;LRU（最近最少使用）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FIFO（先进先出）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CLOCK（近似LRU）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TLB（Translation Lookaside Buffer）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两级以及多级页表&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本分段内存管理&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本结构&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;段号&lt;/th&gt;
          &lt;th&gt;段内地址&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;段表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地址变换机制&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚拟存储器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页表机制&lt;/li&gt;
&lt;li&gt;缺页中断机制&lt;/li&gt;
&lt;li&gt;地址变换机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号：019-021&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;数据结构-二叉树&#34;&gt;数据结构-二叉树
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;线索二叉树&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;li&gt;构造&lt;/li&gt;
&lt;li&gt;遍历&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;树、森林与二叉树&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;相互转换&lt;/li&gt;
&lt;li&gt;遍历&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哈夫曼树&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;WPL&lt;/li&gt;
&lt;li&gt;构造&lt;/li&gt;
&lt;li&gt;哈夫曼编码&lt;/li&gt;
&lt;li&gt;哈夫曼树的特点&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并查集&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;li&gt;操作&lt;/li&gt;
&lt;li&gt;实现&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号：033-037&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0719学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0719/</link>
        <pubDate>Sat, 19 Jul 2025 22:41:19 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0719/</guid>
        <description>&lt;h2 id=&#34;数学-是不动点的味道&#34;&gt;数学-是不动点的味道
&lt;/h2&gt;&lt;h3 id=&#34;数列的极限&#34;&gt;数列的极限
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;概念&lt;/li&gt;
&lt;li&gt;数列极限的定义&lt;/li&gt;
&lt;li&gt;数列收敛的性质
&lt;ul&gt;
&lt;li&gt;唯一性&lt;/li&gt;
&lt;li&gt;有界性&lt;/li&gt;
&lt;li&gt;保号性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;海涅定理（归结原则）&lt;/li&gt;
&lt;li&gt;夹逼准则&lt;/li&gt;
&lt;li&gt;单调有界准则&lt;/li&gt;
&lt;li&gt;${x_n}$收敛于$a$的速度问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据结构-前序中序后序blablabla&#34;&gt;数据结构-前序中序后序blablabla
&lt;/h2&gt;&lt;h3 id=&#34;树的性质&#34;&gt;树的性质
&lt;/h3&gt;&lt;p&gt;let $T_m$ denote a tree with degree $m$.&lt;/p&gt;
&lt;p&gt;let $D(n)$ denote the out degree of the node $x$ in the tree $T_m$.&lt;/p&gt;
&lt;p&gt;let $n_i$ denote the number of notes with degree $i$.&lt;/p&gt;
&lt;p&gt;let $H$ denote the depth/height of the tree $T_m$.&lt;/p&gt;
&lt;p&gt;let $N$ denote the total number of nodes in tree.$N=\sum\limits_{i=0}^mn_i$.&lt;/p&gt;
&lt;p&gt;let $N_i$ denote the number of nodes at layer $i\in \mathcal{N^*}$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$N=1 + \sum\limits_{i=1}^mi\cdot n_i$.&lt;/li&gt;
&lt;li&gt;$n_0 =1 + \sum\limits_{i=2}^m(i-1)\cdot n_i$&lt;/li&gt;
&lt;li&gt;$N_i\leq m^{i-1}$ if not an &lt;strong&gt;empty tree&lt;/strong&gt; with degree m.&lt;/li&gt;
&lt;li&gt;$N\leq \frac{m^H-1}{m-1}$&lt;/li&gt;
&lt;li&gt;$H\geq \lceil\log_{m}\left((N(m-1))+1\right)\rceil$&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二叉树&#34;&gt;二叉树
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;二叉树的性质
&lt;ol&gt;
&lt;li&gt;$N_i\leq 2^{i-1}$ if not an &lt;strong&gt;empty tree&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;$N\leq 2^H-1$&lt;/li&gt;
&lt;li&gt;$n_0 =1 + n_2$&lt;/li&gt;
&lt;li&gt;$H\geq \lceil\log_{2}(N+1)\rceil$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;完全二叉树&lt;/li&gt;
&lt;li&gt;满二叉树&lt;/li&gt;
&lt;li&gt;二叉树的构造
&lt;ol&gt;
&lt;li&gt;前序加中序&lt;/li&gt;
&lt;li&gt;后序加中序&lt;/li&gt;
&lt;li&gt;层次加中序&lt;/li&gt;
&lt;li&gt;前序加树形结构&lt;/li&gt;
&lt;li&gt;中序加树形结构&lt;/li&gt;
&lt;li&gt;后序加树形结构&lt;/li&gt;
&lt;li&gt;层次加树形结构&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;二叉树的遍历
&lt;ol&gt;
&lt;li&gt;前序&lt;/li&gt;
&lt;li&gt;中序&lt;/li&gt;
&lt;li&gt;后序&lt;/li&gt;
&lt;li&gt;层次&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;操作系统-nice-of-linux&#34;&gt;操作系统-nice of linux
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Multi-Level Feedback Queue (cpu-sched-mlfq)
&lt;ol&gt;
&lt;li&gt;Basic Rules
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rule 1&lt;/strong&gt;:If Priority(A) $&amp;gt;$ Priority(B), A runs (B doesn’t).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rule 2&lt;/strong&gt;:If Priority(A) $=$ Priority(B), A &amp;amp; B run in RR(Round Robin).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;However&lt;/strong&gt;: Those with low Priority will get starved!&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Therefore&lt;/strong&gt;: We need to change the Priority over time.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;To change Priority
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rule 3&lt;/strong&gt;: When a job enters the system, it is placed at the highest priority (the topmost queue).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rule 4a&lt;/strong&gt;: If a job uses up its allotment while running, its priority is reduced (i.e., it moves down one queue).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rule 4b&lt;/strong&gt;: If a job gives up the CPU (for example, by performing an I/O operation) before the allotment is up, it stays at the same priority level (i.e., its allotment is reset).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;However&lt;/strong&gt;:
&lt;ol&gt;
&lt;li&gt;Those with long cpu-time will get starved as them move down to the lowest!&lt;/li&gt;
&lt;li&gt;Those with smart heart will game the scheduler as they I/O at the last ms of the allotment.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Therefore&lt;/strong&gt;: We need to change &lt;strong&gt;rule4a,b&lt;/strong&gt; and boost periodically.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The Priority Boost
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rule 5&lt;/strong&gt;: After some time period S, move all the jobs in the system to the topmost queue.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Better Accounting
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rule 4&lt;/strong&gt;: Once a job uses up its time allotment at a given level (re gardless of how many times it has given up the CPU), its priority is reduced (i.e., it moves down one queue).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Proportional share(cpu-sched-lottery)
&lt;ol&gt;
&lt;li&gt;Basic Concept: Tickets Represent Your Share&lt;/li&gt;
&lt;li&gt;Stride Scheduling&lt;/li&gt;
&lt;li&gt;The Linux Completely Fair Scheduler (CFS)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0717学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0717/</link>
        <pubDate>Thu, 17 Jul 2025 22:04:43 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0717/</guid>
        <description>&lt;h2 id=&#34;数学-纸上得来终觉浅&#34;&gt;数学-纸上得来终觉浅
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;函数极限的定义($\epsilon,\delta$语言)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数极限的性质&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;唯一性&lt;/li&gt;
&lt;li&gt;局部有界性&lt;/li&gt;
&lt;li&gt;局部保号性&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无穷小(let $\alpha$ be infinitesimal)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;性质
&lt;ul&gt;
&lt;li&gt;$\sum\limits_{k}^{N}{\alpha_k}=\alpha,(N \text{ is finite})$&lt;/li&gt;
&lt;li&gt;$\alpha&amp;rsquo;\cdot f(x)=\alpha $,where $f(x)$ is limited at the interval&lt;/li&gt;
&lt;li&gt;$\prod\limits_{k}^{N}{\alpha_k}=\alpha,(N \text{ is finite})$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;比阶($\lim\alpha(x)=0$,$\lim\beta(x)=0$,$\beta(x)\neq0$)
&lt;ul&gt;
&lt;li&gt;$\alpha(x)$是$\beta(x)$的高阶无穷小$\Leftrightarrow\lim{\frac{\alpha(x)}{\beta(x)}}=0$&lt;/li&gt;
&lt;li&gt;$\alpha(x)$是$\beta(x)$的低阶无穷小$\Leftrightarrow\lim{\frac{\alpha(x)}{\beta(x)}}=\infty$&lt;/li&gt;
&lt;li&gt;$\alpha(x)$是$\beta(x)$的同阶无穷小$\Leftrightarrow\lim{\frac{\alpha(x)}{\beta(x)}}=c,(\text{constant }c\neq 0)$&lt;/li&gt;
&lt;li&gt;$\alpha(x)$是$\beta(x)$的等价无穷小$\Leftrightarrow\lim{\frac{\alpha(x)}{\beta(x)}}=1$&lt;/li&gt;
&lt;li&gt;$\alpha(x)$是$\beta(x)$的$k$阶无穷小$\Leftrightarrow\lim{\frac{\alpha(x)}{\beta^k(x)}}=0$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;极限的运算&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;四则运算&lt;/li&gt;
&lt;li&gt;洛必达法则&lt;/li&gt;
&lt;li&gt;泰勒展开&lt;/li&gt;
&lt;li&gt;夹逼准则&lt;/li&gt;
&lt;li&gt;七种未定式：$\frac{0}{0},\frac{\infty}{\infty},0\cdot\infty,\infty-\infty,\infty^0,0^0,1^{\infty}$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数的连续和两类间断点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;超实数(&lt;a class=&#34;link&#34; href=&#34;https://people.math.wisc.edu/~hkeisler/keislercalc-06-18-25.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;hyperreal number&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;操作系统-three-easy-piece&#34;&gt;操作系统-&lt;a class=&#34;link&#34; href=&#34;https://pages.cs.wisc.edu/~remzi/OSTEP/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;three easy piece&lt;/a&gt;
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;cpu-intro
&lt;ul&gt;
&lt;li&gt;the Process&lt;/li&gt;
&lt;li&gt;Process API
&lt;ol&gt;
&lt;li&gt;create&lt;/li&gt;
&lt;li&gt;Destory&lt;/li&gt;
&lt;li&gt;Wait&lt;/li&gt;
&lt;li&gt;Miscellaneous Control&lt;/li&gt;
&lt;li&gt;Status&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Process status&lt;/li&gt;
&lt;li&gt;Proc data structure:(PCB)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;cpu-api
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;fork()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;spawn()&lt;/code&gt;*&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;cpu-mechanisms
&lt;ol&gt;
&lt;li&gt;from Directed Execution to Limited Directed Execution:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;user mode and kernel mode&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;system call&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;switch between Processes,Os need to retain CPU from process
&lt;ul&gt;
&lt;li&gt;A Cooperative Approach: Wait For System Calls&lt;/li&gt;
&lt;li&gt;A Non-Cooperative Approach: The OS Takes Control&lt;/li&gt;
&lt;li&gt;reboot (x&lt;/li&gt;
&lt;li&gt;timer interrupt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Saving and Restoring Context&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;cpu-sched(reading)&lt;/li&gt;
&lt;li&gt;cpu-sched-mlfq(reading)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据结构-排好队一个一个fifo&#34;&gt;数据结构-排好队一个一个FIFO
&lt;/h2&gt;&lt;h3 id=&#34;队列&#34;&gt;队列
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;顺序队列的性质和操作&lt;/li&gt;
&lt;li&gt;循环队列的性质和操作&lt;/li&gt;
&lt;li&gt;链式队列的性质和操作&lt;/li&gt;
&lt;li&gt;双端队列&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号018-027&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0715学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0715/</link>
        <pubDate>Tue, 15 Jul 2025 21:43:17 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0715/</guid>
        <description>&lt;h2 id=&#34;操作系统-jyy的map永远的噩梦&#34;&gt;操作系统-jyy的map永远的噩梦
&lt;/h2&gt;&lt;h3 id=&#34;死锁&#34;&gt;死锁
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;死锁的必要条件
&lt;ul&gt;
&lt;li&gt;互斥条件&lt;/li&gt;
&lt;li&gt;请求和保持条件&lt;/li&gt;
&lt;li&gt;不可剥夺条件&lt;/li&gt;
&lt;li&gt;循环等待条件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;预防死锁的方法
&lt;ul&gt;
&lt;li&gt;破坏互斥：非但不能破坏还要保护&lt;/li&gt;
&lt;li&gt;破坏不可剥夺条件&lt;/li&gt;
&lt;li&gt;破坏请求和保持条件&lt;/li&gt;
&lt;li&gt;破坏循环等待条件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;死锁避免
&lt;ol&gt;
&lt;li&gt;安全状态&lt;/li&gt;
&lt;li&gt;银行家算法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;死锁检测和解除
&lt;ul&gt;
&lt;li&gt;资源分配图&lt;/li&gt;
&lt;li&gt;死锁定理&lt;/li&gt;
&lt;li&gt;死锁的解除
&lt;ul&gt;
&lt;li&gt;剥夺资源&lt;/li&gt;
&lt;li&gt;撤销进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;内存管理&#34;&gt;内存管理
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;基本概念
&lt;ol&gt;
&lt;li&gt;逻辑地址&lt;/li&gt;
&lt;li&gt;物理地址&lt;/li&gt;
&lt;li&gt;外部碎片&lt;/li&gt;
&lt;li&gt;内部碎片&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;内存连续分配管理方式
&lt;ol&gt;
&lt;li&gt;单一连续分配&lt;/li&gt;
&lt;li&gt;固定分区分配&lt;/li&gt;
&lt;li&gt;动态分区分配
&lt;ol&gt;
&lt;li&gt;首次适应FF&lt;/li&gt;
&lt;li&gt;循环首次适应NF&lt;/li&gt;
&lt;li&gt;最佳适应BF&lt;/li&gt;
&lt;li&gt;最坏适应WF&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号016-018&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;数学-什么超实数&#34;&gt;数学-什么？！超实数？
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;函数极限的概念与性质&lt;/li&gt;
&lt;li&gt;超实数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号第一讲&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0714学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0714/</link>
        <pubDate>Mon, 14 Jul 2025 21:15:02 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0714/</guid>
        <description>&lt;h2 id=&#34;操作系统-这什么查一下这什么查一下&#34;&gt;操作系统-这什么查一下这什么查一下
&lt;/h2&gt;&lt;h3 id=&#34;经典同步问题&#34;&gt;经典同步问题
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;生产者消费者问题&lt;/li&gt;
&lt;li&gt;哲学家进餐问题&lt;/li&gt;
&lt;li&gt;读者-写者问题&lt;/li&gt;
&lt;li&gt;理发师问题&lt;/li&gt;
&lt;li&gt;抽烟者问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;处理机调度&#34;&gt;处理机调度
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;处理及调度的层次&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;高级调度（作业调度、长程调度）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作业选择&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从**后备队列（外存中等待的作业）**中选择作业&lt;/li&gt;
&lt;li&gt;判断系统资源（内存、CPU、I/O）是否充足&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;资源分配&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为选中的作业分配内存、I/O、文件等资源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进程创建&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将作业转化为一个或多个&lt;strong&gt;进程&lt;/strong&gt;，放入就绪队列&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中级调度（内存调度、中程调度）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;选择部分进程挂起（移出内存到外存）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;选择挂起的进程恢复（从外存调回内存）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;低级调度（进程调度、线程调度、短程调度）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从&lt;strong&gt;就绪队列&lt;/strong&gt;中选择一个进程&lt;/li&gt;
&lt;li&gt;把 CPU 分配给选中的进程&lt;/li&gt;
&lt;li&gt;保存和恢复进程的上下文（&lt;strong&gt;进程切换 Context Switch&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;控制 CPU 的执行顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理机的调度方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非抢占式&lt;/li&gt;
&lt;li&gt;抢占式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择调度算法的若干准则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CPU利用率&lt;/p&gt;
$$
     \frac{\text{worktime of CPU}}{\text{total time}}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统吞吐量&lt;/p&gt;
$$
     \frac{\text{number of tasks}}{\text{total time}}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;周转时间(Turnaround Time)&lt;/p&gt;
$$
     \text{Completion Time - Arrival Time}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均周转时间&lt;/p&gt;
$$
     \frac{\sum\limits_{N}\text{Turnaround Time of all processes}}{N}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;带权周转时间&lt;/p&gt;
$$
     \frac{\text{Turnaround Time}}{\text{Service Time}}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均带权周转时间&lt;/p&gt;
$$
     \frac{\sum\limits_{N}\text{Weighted Turnaround Time of all processes}}{N}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待时间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;调度算法&#34;&gt;调度算法
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;FCFS（先来先服务）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SJF（最短作业优先）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抢占&lt;/li&gt;
&lt;li&gt;非抢占&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SRTF（最短剩余时间优先）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Priority Scheduling（高优先权优先调度）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抢占&lt;/li&gt;
&lt;li&gt;非抢占&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Highest Response Ratio Next (HRRN)（高响应比有点调度算法）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Round Robin（时间片轮转）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Multilevel Feedback Queue（多级反馈队列调度）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上下文切换&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CPU上下文切换&lt;/li&gt;
&lt;li&gt;系统调用上下文切换&lt;/li&gt;
&lt;li&gt;进程上下文切换
&lt;ul&gt;
&lt;li&gt;用户级&lt;/li&gt;
&lt;li&gt;系统级&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程上下文切换&lt;/li&gt;
&lt;li&gt;中断上下文切换&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号:012-015&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;数据结构-致敬传奇栈帧pc程序计数器&#34;&gt;数据结构-致敬传奇栈帧PC程序计数器
&lt;/h2&gt;&lt;h3 id=&#34;栈&#34;&gt;栈
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;静态顺序栈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判空&lt;/li&gt;
&lt;li&gt;判满&lt;/li&gt;
&lt;li&gt;进栈&lt;/li&gt;
&lt;li&gt;出栈&lt;/li&gt;
&lt;li&gt;获取栈顶元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态顺序栈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判空&lt;/li&gt;
&lt;li&gt;判满&lt;/li&gt;
&lt;li&gt;进栈&lt;/li&gt;
&lt;li&gt;出栈&lt;/li&gt;
&lt;li&gt;获取栈顶元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链栈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判空&lt;/li&gt;
&lt;li&gt;判满&lt;/li&gt;
&lt;li&gt;进栈&lt;/li&gt;
&lt;li&gt;出栈&lt;/li&gt;
&lt;li&gt;获取栈顶元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;栈的应用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;括号匹配&lt;/li&gt;
&lt;li&gt;进制转换（辗转相除）&lt;/li&gt;
&lt;li&gt;函数递归调用&lt;/li&gt;
&lt;li&gt;表达式求值
&lt;ul&gt;
&lt;li&gt;前缀&lt;/li&gt;
&lt;li&gt;中缀（重要）&lt;/li&gt;
&lt;li&gt;后缀&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号：014-017&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;数学-太好了是张宇老师我们有救了&#34;&gt;数学-太好了是张宇老师我们有救了！
&lt;/h2&gt;&lt;h3 id=&#34;函数的概念与特性&#34;&gt;函数的概念与特性
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;函数&lt;/li&gt;
&lt;li&gt;反函数&lt;/li&gt;
&lt;li&gt;复合函数&lt;/li&gt;
&lt;li&gt;隐函数&lt;/li&gt;
&lt;li&gt;函数的四种特性
&lt;ul&gt;
&lt;li&gt;有界性&lt;/li&gt;
&lt;li&gt;单调性&lt;/li&gt;
&lt;li&gt;奇偶性&lt;/li&gt;
&lt;li&gt;周期性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基本初等函数与初等函数
&lt;ul&gt;
&lt;li&gt;常函数&lt;/li&gt;
&lt;li&gt;幂函数&lt;/li&gt;
&lt;li&gt;指数函数&lt;/li&gt;
&lt;li&gt;对数函数&lt;/li&gt;
&lt;li&gt;三角函数
&lt;ol&gt;
&lt;li&gt;sin x  cos x&lt;/li&gt;
&lt;li&gt;csc x sec x&lt;/li&gt;
&lt;li&gt;tan x cot x&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;反三角函数
&lt;ol&gt;
&lt;li&gt;arcsin x arccos x&lt;/li&gt;
&lt;li&gt;arctanx arccot x&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分段函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;高数第一讲&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0713学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0713/</link>
        <pubDate>Sun, 13 Jul 2025 23:27:16 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0713/</guid>
        <description>&lt;h2 id=&#34;数据结构-喜欢在头指针存数据的扣1&#34;&gt;数据结构-喜欢在头指针存数据的扣1
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;线性表的链式存储&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单链表&lt;/li&gt;
&lt;li&gt;静态链表&lt;/li&gt;
&lt;li&gt;其他链表
&lt;ul&gt;
&lt;li&gt;单向循环链表&lt;/li&gt;
&lt;li&gt;双向链表&lt;/li&gt;
&lt;li&gt;双向循环链表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程代码010-013&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;操作系统-谦让是美德&#34;&gt;操作系统-谦让是美德
&lt;/h2&gt;&lt;h3 id=&#34;进程与线程&#34;&gt;进程与线程
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;进程的特点：
&lt;ul&gt;
&lt;li&gt;动态性&lt;/li&gt;
&lt;li&gt;并发性&lt;/li&gt;
&lt;li&gt;独立性&lt;/li&gt;
&lt;li&gt;异步性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程的基本状态及管理切换
&lt;ul&gt;
&lt;li&gt;运行&lt;/li&gt;
&lt;li&gt;阻塞&lt;/li&gt;
&lt;li&gt;就绪&lt;/li&gt;
&lt;li&gt;创建&lt;/li&gt;
&lt;li&gt;终止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;线程的特性&lt;/li&gt;
&lt;li&gt;线程的状态&lt;/li&gt;
&lt;li&gt;线程与进程的联系和不同&lt;/li&gt;
&lt;li&gt;用户级线程与内核级线程的映射关系&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;互斥与同步&#34;&gt;互斥与同步
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;临界区实现互斥的原则&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;空闲让进&lt;/li&gt;
&lt;li&gt;忙则等待&lt;/li&gt;
&lt;li&gt;有限等待&lt;/li&gt;
&lt;li&gt;让权等待（非必须）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;临界区实现互斥的基本方法&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;软件实现方法
&lt;ol&gt;
&lt;li&gt;单标志法&lt;/li&gt;
&lt;li&gt;双标志法
&lt;ul&gt;
&lt;li&gt;先检查法&lt;/li&gt;
&lt;li&gt;后检查法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Peterson算法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;硬件实现方法
&lt;ol&gt;
&lt;li&gt;中断屏蔽&lt;/li&gt;
&lt;li&gt;TestAndSet指令&lt;/li&gt;
&lt;li&gt;Swap指令&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;互斥锁（mutex lock）&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;LockOne类&lt;/li&gt;
&lt;li&gt;LockTwo类&lt;/li&gt;
&lt;li&gt;Peterson锁&lt;/li&gt;
&lt;li&gt;Barkley锁&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;信号量&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;整型信号量&lt;/li&gt;
&lt;li&gt;记录型信号量&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;管程&#34;&gt;管程
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;管程的定义&lt;/li&gt;
&lt;li&gt;管程的组成&lt;/li&gt;
&lt;li&gt;管程的特性&lt;/li&gt;
&lt;li&gt;管程与进程的异同&lt;/li&gt;
&lt;li&gt;条件变量&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;进程通信&#34;&gt;进程通信
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;管道通信&lt;/li&gt;
&lt;li&gt;消息传递系统&lt;/li&gt;
&lt;li&gt;共享存储器系统&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号005-011&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0712学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0712/</link>
        <pubDate>Sat, 12 Jul 2025 22:05:39 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0712/</guid>
        <description>&lt;h2 id=&#34;操作系统-int-0x80&#34;&gt;操作系统-int 0x80
&lt;/h2&gt;&lt;p&gt;操作系统的运行环境&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内核程序
&lt;ul&gt;
&lt;li&gt;特权指令&lt;/li&gt;
&lt;li&gt;核心态，管态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用程序
&lt;ul&gt;
&lt;li&gt;非特权指令&lt;/li&gt;
&lt;li&gt;用户态，目态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;操作系统的内核&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;时钟管理&lt;/li&gt;
&lt;li&gt;中断机制
&lt;ol&gt;
&lt;li&gt;内部异常
&lt;ol&gt;
&lt;li&gt;故障（Fault）（软件中断）&lt;/li&gt;
&lt;li&gt;自陷（Trap）（软件中断）&lt;/li&gt;
&lt;li&gt;终止（Abort）（硬件中断）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;外部中断（硬件）
&lt;ol&gt;
&lt;li&gt;可屏蔽中断 INTR&lt;/li&gt;
&lt;li&gt;不可屏蔽中断 NMI&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号 ：003-004&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;英语-英语构词法&#34;&gt;英语-英语构词法
&lt;/h2&gt;&lt;p&gt;前缀包含两种作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;方向&lt;/li&gt;
&lt;li&gt;性质&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;后缀一般表示词性，例外：able,&amp;hellip;.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0711学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0711/</link>
        <pubDate>Fri, 11 Jul 2025 20:29:14 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0711/</guid>
        <description>&lt;h2 id=&#34;数据结构-太好了是死记硬背&#34;&gt;数据结构-太好了是死记硬背
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数据的逻辑和物理结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://auroraemiya.github.io/npee_learning_log.github.io/posts/0711/QQ20250711-202720.png&#34;
	width=&#34;1702&#34;
	height=&#34;743&#34;
	srcset=&#34;https://auroraemiya.github.io/npee_learning_log.github.io/posts/0711/QQ20250711-202720_hu_ab8a865d16a46851.png 480w, https://auroraemiya.github.io/npee_learning_log.github.io/posts/0711/QQ20250711-202720_hu_5cae573c8a98f94d.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;229&#34;
		data-flex-basis=&#34;549px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算法的时间空间复杂度&lt;/li&gt;
&lt;li&gt;线性表的顺序表以及相关算法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;课程编号001-009&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;操作系统-想念jyy的第n天&#34;&gt;操作系统-想念jyy的第n天
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;操作系统概述
&lt;ul&gt;
&lt;li&gt;并发&lt;/li&gt;
&lt;li&gt;共享&lt;/li&gt;
&lt;li&gt;虚拟&lt;/li&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统的发展历程
&lt;ul&gt;
&lt;li&gt;批处理器
&lt;ul&gt;
&lt;li&gt;单道&lt;/li&gt;
&lt;li&gt;多道&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分时操作系统&lt;/li&gt;
&lt;li&gt;实时操作系统&lt;/li&gt;
&lt;li&gt;网络操作系统&lt;/li&gt;
&lt;li&gt;分布式操作系统&lt;/li&gt;
&lt;li&gt;&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;课程编号001-002&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
