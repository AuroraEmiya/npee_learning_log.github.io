<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>数据结构 on shyの考研日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
        <description>Recent content in 数据结构 on shyの考研日志</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Tue, 12 Aug 2025 11:20:48 +0800</lastBuildDate><atom:link href="https://auroraemiya.github.io/npee_learning_log.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>0812学习笔记</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/memo/0812/</link>
        <pubDate>Tue, 12 Aug 2025 11:20:48 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/memo/0812/</guid>
        <description>&lt;h2 id=&#34;数据结构&#34;&gt;数据结构
&lt;/h2&gt;&lt;h3 id=&#34;红黑树&#34;&gt;红黑树
&lt;/h3&gt;&lt;h4 id=&#34;rule&#34;&gt;RULE
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;Every node is either black or red.&lt;/li&gt;
&lt;li&gt;The root is black&lt;/li&gt;
&lt;li&gt;All leaves(NIL/null nodes) are black.&lt;/li&gt;
&lt;li&gt;Red node rule : &lt;strong&gt;If a node is red ,both its children and parents are black.&lt;/strong&gt;(no two red in a row)&lt;/li&gt;
&lt;li&gt;Black height rule: Every path from a node to its descendant NIL node contains  &lt;strong&gt;the same number of black nodes.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;h4 id=&#34;construction-insertion&#34;&gt;Construction (Insertion)
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Case 1: Parent node is BLACK, go ahead.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Case 2: RED parent,See your uncle:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Case 2.1 :BLACK uncle , Rotation to make things in balance.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://auroraemiya.github.io/npee_learning_log.github.io/memo/0812/Case2.1l.png&#34;
	width=&#34;969&#34;
	height=&#34;759&#34;
	srcset=&#34;https://auroraemiya.github.io/npee_learning_log.github.io/memo/0812/Case2.1l_hu_e2a977b617f265b1.png 480w, https://auroraemiya.github.io/npee_learning_log.github.io/memo/0812/Case2.1l_hu_32210b6c6b327c94.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Case2.1 LL&amp;LR&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;127&#34;
		data-flex-basis=&#34;306px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://auroraemiya.github.io/npee_learning_log.github.io/memo/0812/Case2.1r.png&#34;
	width=&#34;874&#34;
	height=&#34;762&#34;
	srcset=&#34;https://auroraemiya.github.io/npee_learning_log.github.io/memo/0812/Case2.1r_hu_388296b4c50491dd.png 480w, https://auroraemiya.github.io/npee_learning_log.github.io/memo/0812/Case2.1r_hu_40f33465402eeb38.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Case2.1 RL&amp;RR&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;114&#34;
		data-flex-basis=&#34;275px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Case 2.2 :RED uncle, BLACK-lize your parent and uncle,RED-lize your grand.&lt;/p&gt;
&lt;p&gt;Now consider the process of your grand and repeat cases above.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://auroraemiya.github.io/npee_learning_log.github.io/memo/0812/Case2.2.png&#34;
	width=&#34;861&#34;
	height=&#34;390&#34;
	srcset=&#34;https://auroraemiya.github.io/npee_learning_log.github.io/memo/0812/Case2.2_hu_2bb9d3b36231e15c.png 480w, https://auroraemiya.github.io/npee_learning_log.github.io/memo/0812/Case2.2_hu_a2caedb5d994483b.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Case2.2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;220&#34;
		data-flex-basis=&#34;529px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;b树&#34;&gt;B树
&lt;/h3&gt;&lt;h4 id=&#34;rules&#34;&gt;RULES
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Key properties&lt;/strong&gt; of a B-Tree of order $m$:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Every node can have at most &lt;strong&gt;m&lt;/strong&gt; children&lt;/li&gt;
&lt;li&gt;Every node (except root )has at least $\lceil \frac{m}{2}\rceil$ children&lt;/li&gt;
&lt;li&gt;Every non-leaf node with $k$ children has exactly $k-1$ keys&lt;/li&gt;
&lt;li&gt;Keys in each node are sorted&lt;/li&gt;
&lt;li&gt;All leaves appear on the same level&lt;/li&gt;
&lt;/ol&gt;
$$
\lfloor\log_{\lceil\frac{m}{2}\rceil}(\frac{n+1}{2})\rfloor +1 \geq h\geq \lceil\log_{m}(n+1)\rceil
$$&lt;p&gt;推理过程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;左式：对于一个m阶的具有n个关键字的B树，其第二层至少有2个结点，第三层至少有$2\lceil\frac{m}{2}\rceil$个结点,以此类推，第$h+1$层至少有$2\lceil\frac{m}{2}\rceil^{h-1}$,这一层为查找失败的叶节点，结点数为$n+1$，因此有&lt;/li&gt;
&lt;/ol&gt;
$$
n+1\geq 2\lceil\frac{m}{2}\rceil^{h-1}
$$&lt;p&gt;​	化简得左式&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;右式：对于一个m阶的具有n个关键字的B树，其满足不等式
$$
   n\leq (m-1)(1+m+\cdots+m^{h-1})=m^h-1
   $$
化简得右式&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;constructioninsertion&#34;&gt;Construction(Insertion)
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Find the correct leaf&lt;/strong&gt;
Use the same logic as binary search but in multi-key nodes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Compare the new key to the existing keys in the current node.&lt;/li&gt;
&lt;li&gt;Descend into the correct child pointer until you reach a leaf.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Insert key in sorted order&lt;/strong&gt; in that leaf.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;If the node has ≤ m − 1 keys after insertion&lt;/strong&gt; → done.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;If the node overflows&lt;/strong&gt; (has m keys):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Split&lt;/strong&gt; the node into two nodes:
&lt;ul&gt;
&lt;li&gt;Middle key moves &lt;strong&gt;up&lt;/strong&gt; to the parent.&lt;/li&gt;
&lt;li&gt;Left half of keys go to the left child.&lt;/li&gt;
&lt;li&gt;Right half of keys go to the right child.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;If the parent also overflows, split it &lt;strong&gt;recursively&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;If the root splits&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create a &lt;strong&gt;new root&lt;/strong&gt; containing the middle key.&lt;/li&gt;
&lt;li&gt;The height of the B-Tree increases by 1.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;deletion&#34;&gt;Deletion
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;If the key is in a leaf → just remove it.&lt;/li&gt;
&lt;li&gt;If the key is in an internal node:
&lt;ul&gt;
&lt;li&gt;Replace it with the &lt;strong&gt;predecessor&lt;/strong&gt; (largest in left subtree) or &lt;strong&gt;successor&lt;/strong&gt; (smallest in right subtree).&lt;/li&gt;
&lt;li&gt;Then delete that replacement key from the leaf.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;If a node falls below &lt;strong&gt;⌈m/2⌉ − 1 keys&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Borrow&lt;/strong&gt; a key from a sibling if possible.&lt;/li&gt;
&lt;li&gt;Otherwise, &lt;strong&gt;merge&lt;/strong&gt; with a sibling.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;If the root becomes empty → its only child becomes the new root.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>0811学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0811/</link>
        <pubDate>Mon, 11 Aug 2025 23:43:07 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0811/</guid>
        <description>&lt;h2 id=&#34;数据结构&#34;&gt;数据结构
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;插入排序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直接插入排序&lt;/li&gt;
&lt;li&gt;折半插入排序&lt;/li&gt;
&lt;li&gt;希尔排序&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交换排序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;冒泡排序&lt;/li&gt;
&lt;li&gt;快速排序&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二路归并排序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基数排序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;外部排序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多路平衡归并与败者树&lt;/li&gt;
&lt;li&gt;置换-选择排序&lt;/li&gt;
&lt;li&gt;最佳归并树&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;排序算法的分析和应用&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;算法&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;时间复杂度&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;最好情况&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;平均情况&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;最坏情况&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;空间复杂度&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;稳定性&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;直接插入排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(1)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;是&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;冒泡排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(1)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;是&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;简单选择排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(1)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;否&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;希尔排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(1)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;否&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;快速排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;否&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;堆排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(1)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;否&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;二路归并排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;是&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;基数排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(d(n+r)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(d(n+r))$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(d(n+r)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(1)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;是&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0809学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0809/</link>
        <pubDate>Sat, 09 Aug 2025 23:52:51 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0809/</guid>
        <description>&lt;h2 id=&#34;数据结构-查找&#34;&gt;数据结构-查找
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;顺序查找法&lt;/li&gt;
&lt;li&gt;分块查找法（索引顺序查找）&lt;/li&gt;
&lt;li&gt;折半查找法
&lt;ul&gt;
&lt;li&gt;判定树&lt;/li&gt;
&lt;li&gt;ASL（平均查找长度）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二叉搜索树
&lt;ol&gt;
&lt;li&gt;查找&lt;/li&gt;
&lt;li&gt;插入&lt;/li&gt;
&lt;li&gt;构造&lt;/li&gt;
&lt;li&gt;删除（中序）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;平衡二叉树（AVL）
&lt;ol&gt;
&lt;li&gt;插入
&lt;ul&gt;
&lt;li&gt;LL平衡旋转&lt;/li&gt;
&lt;li&gt;LR平衡旋转&lt;/li&gt;
&lt;li&gt;RR平衡旋转&lt;/li&gt;
&lt;li&gt;RL平衡旋转&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;构造&lt;/li&gt;
&lt;li&gt;删除&lt;/li&gt;
&lt;li&gt;查找&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;红黑树
&lt;ol&gt;
&lt;li&gt;定义
&lt;ul&gt;
&lt;li&gt;每个结点或是黑色或是红色&lt;/li&gt;
&lt;li&gt;根节点是黑色的&lt;/li&gt;
&lt;li&gt;叶节点（虚构的外部节点、NULL节点）都是黑色&lt;/li&gt;
&lt;li&gt;不存在两个相邻的红节点&lt;/li&gt;
&lt;li&gt;对于每个结点，从该结点到任意一个叶节点的简单路径上，所含黑节点的数量相同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结论
&lt;ol&gt;
&lt;li&gt;从根到叶结点的最长路径不大于最短路径的2倍&lt;/li&gt;
&lt;li&gt;有n个内部结点的红黑树的高度$h\leq 2\log_2{(n+1)}$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;插入
&lt;ul&gt;
&lt;li&gt;新插入红黑树的结点初始着为红色&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除*&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0721学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0721/</link>
        <pubDate>Mon, 21 Jul 2025 17:53:02 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0721/</guid>
        <description>&lt;h2 id=&#34;英语-vocabulary-builder&#34;&gt;英语-vocabulary builder
&lt;/h2&gt;&lt;p&gt;使用 &lt;code&gt;The Merriam-Webster Vocabulary Builder&lt;/code&gt;作为词根法扩充词汇量的工具书(由网友canon提供)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BENE , latin for &lt;code&gt;well&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;benediction&lt;/li&gt;
&lt;li&gt;benefactor&lt;/li&gt;
&lt;li&gt;benefaciary&lt;/li&gt;
&lt;li&gt;benevolence&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AM, comes form the latin &lt;code&gt;admare&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;amicable&lt;/li&gt;
&lt;li&gt;enamored&lt;/li&gt;
&lt;li&gt;amorous&lt;/li&gt;
&lt;li&gt;paramour&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BELL,comes from the latin word meaning &lt;code&gt;war&lt;/code&gt;.Bellona was the little-known goddess of war .
&lt;ul&gt;
&lt;li&gt;antebellum&lt;/li&gt;
&lt;li&gt;belligerence&lt;/li&gt;
&lt;li&gt;bellicose&lt;/li&gt;
&lt;li&gt;rebellion&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PAC,is related to the Latin words for &amp;ldquo;agree&amp;rdquo; and &amp;ldquo;peace&amp;rdquo;
&lt;ul&gt;
&lt;li&gt;pacify&lt;/li&gt;
&lt;li&gt;pacifist&lt;/li&gt;
&lt;li&gt;pact&lt;/li&gt;
&lt;li&gt;pace&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;操作系统-page--segment&#34;&gt;操作系统-page &amp;amp; segment
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本分页内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;page&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;page frame&lt;/li&gt;
&lt;li&gt;page table&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;页号&lt;/th&gt;
          &lt;th&gt;页内偏移量&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;虚拟地址 = 页号 + 页内偏移&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;LRU（最近最少使用）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FIFO（先进先出）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CLOCK（近似LRU）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TLB（Translation Lookaside Buffer）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两级以及多级页表&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本分段内存管理&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本结构&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;段号&lt;/th&gt;
          &lt;th&gt;段内地址&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;段表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地址变换机制&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚拟存储器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页表机制&lt;/li&gt;
&lt;li&gt;缺页中断机制&lt;/li&gt;
&lt;li&gt;地址变换机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号：019-021&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;数据结构-二叉树&#34;&gt;数据结构-二叉树
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;线索二叉树&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;li&gt;构造&lt;/li&gt;
&lt;li&gt;遍历&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;树、森林与二叉树&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;相互转换&lt;/li&gt;
&lt;li&gt;遍历&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哈夫曼树&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;WPL&lt;/li&gt;
&lt;li&gt;构造&lt;/li&gt;
&lt;li&gt;哈夫曼编码&lt;/li&gt;
&lt;li&gt;哈夫曼树的特点&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并查集&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;li&gt;操作&lt;/li&gt;
&lt;li&gt;实现&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号：033-037&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0719学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0719/</link>
        <pubDate>Sat, 19 Jul 2025 22:41:19 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0719/</guid>
        <description>&lt;h2 id=&#34;数学-是不动点的味道&#34;&gt;数学-是不动点的味道
&lt;/h2&gt;&lt;h3 id=&#34;数列的极限&#34;&gt;数列的极限
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;概念&lt;/li&gt;
&lt;li&gt;数列极限的定义&lt;/li&gt;
&lt;li&gt;数列收敛的性质
&lt;ul&gt;
&lt;li&gt;唯一性&lt;/li&gt;
&lt;li&gt;有界性&lt;/li&gt;
&lt;li&gt;保号性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;海涅定理（归结原则）&lt;/li&gt;
&lt;li&gt;夹逼准则&lt;/li&gt;
&lt;li&gt;单调有界准则&lt;/li&gt;
&lt;li&gt;${x_n}$收敛于$a$的速度问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据结构-前序中序后序blablabla&#34;&gt;数据结构-前序中序后序blablabla
&lt;/h2&gt;&lt;h3 id=&#34;树的性质&#34;&gt;树的性质
&lt;/h3&gt;&lt;p&gt;let $T_m$ denote a tree with degree $m$.&lt;/p&gt;
&lt;p&gt;let $D(n)$ denote the out degree of the node $x$ in the tree $T_m$.&lt;/p&gt;
&lt;p&gt;let $n_i$ denote the number of notes with degree $i$.&lt;/p&gt;
&lt;p&gt;let $H$ denote the depth/height of the tree $T_m$.&lt;/p&gt;
&lt;p&gt;let $N$ denote the total number of nodes in tree.$N=\sum\limits_{i=0}^mn_i$.&lt;/p&gt;
&lt;p&gt;let $N_i$ denote the number of nodes at layer $i\in \mathcal{N^*}$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$N=1 + \sum\limits_{i=1}^mi\cdot n_i$.&lt;/li&gt;
&lt;li&gt;$n_0 =1 + \sum\limits_{i=2}^m(i-1)\cdot n_i$&lt;/li&gt;
&lt;li&gt;$N_i\leq m^{i-1}$ if not an &lt;strong&gt;empty tree&lt;/strong&gt; with degree m.&lt;/li&gt;
&lt;li&gt;$N\leq \frac{m^H-1}{m-1}$&lt;/li&gt;
&lt;li&gt;$H\geq \lceil\log_{m}\left((N(m-1))+1\right)\rceil$&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二叉树&#34;&gt;二叉树
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;二叉树的性质
&lt;ol&gt;
&lt;li&gt;$N_i\leq 2^{i-1}$ if not an &lt;strong&gt;empty tree&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;$N\leq 2^H-1$&lt;/li&gt;
&lt;li&gt;$n_0 =1 + n_2$&lt;/li&gt;
&lt;li&gt;$H\geq \lceil\log_{2}(N+1)\rceil$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;完全二叉树&lt;/li&gt;
&lt;li&gt;满二叉树&lt;/li&gt;
&lt;li&gt;二叉树的构造
&lt;ol&gt;
&lt;li&gt;前序加中序&lt;/li&gt;
&lt;li&gt;后序加中序&lt;/li&gt;
&lt;li&gt;层次加中序&lt;/li&gt;
&lt;li&gt;前序加树形结构&lt;/li&gt;
&lt;li&gt;中序加树形结构&lt;/li&gt;
&lt;li&gt;后序加树形结构&lt;/li&gt;
&lt;li&gt;层次加树形结构&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;二叉树的遍历
&lt;ol&gt;
&lt;li&gt;前序&lt;/li&gt;
&lt;li&gt;中序&lt;/li&gt;
&lt;li&gt;后序&lt;/li&gt;
&lt;li&gt;层次&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;操作系统-nice-of-linux&#34;&gt;操作系统-nice of linux
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Multi-Level Feedback Queue (cpu-sched-mlfq)
&lt;ol&gt;
&lt;li&gt;Basic Rules
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rule 1&lt;/strong&gt;:If Priority(A) $&amp;gt;$ Priority(B), A runs (B doesn’t).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rule 2&lt;/strong&gt;:If Priority(A) $=$ Priority(B), A &amp;amp; B run in RR(Round Robin).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;However&lt;/strong&gt;: Those with low Priority will get starved!&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Therefore&lt;/strong&gt;: We need to change the Priority over time.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;To change Priority
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rule 3&lt;/strong&gt;: When a job enters the system, it is placed at the highest priority (the topmost queue).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rule 4a&lt;/strong&gt;: If a job uses up its allotment while running, its priority is reduced (i.e., it moves down one queue).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rule 4b&lt;/strong&gt;: If a job gives up the CPU (for example, by performing an I/O operation) before the allotment is up, it stays at the same priority level (i.e., its allotment is reset).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;However&lt;/strong&gt;:
&lt;ol&gt;
&lt;li&gt;Those with long cpu-time will get starved as them move down to the lowest!&lt;/li&gt;
&lt;li&gt;Those with smart heart will game the scheduler as they I/O at the last ms of the allotment.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Therefore&lt;/strong&gt;: We need to change &lt;strong&gt;rule4a,b&lt;/strong&gt; and boost periodically.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The Priority Boost
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rule 5&lt;/strong&gt;: After some time period S, move all the jobs in the system to the topmost queue.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Better Accounting
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rule 4&lt;/strong&gt;: Once a job uses up its time allotment at a given level (re gardless of how many times it has given up the CPU), its priority is reduced (i.e., it moves down one queue).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Proportional share(cpu-sched-lottery)
&lt;ol&gt;
&lt;li&gt;Basic Concept: Tickets Represent Your Share&lt;/li&gt;
&lt;li&gt;Stride Scheduling&lt;/li&gt;
&lt;li&gt;The Linux Completely Fair Scheduler (CFS)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0717学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0717/</link>
        <pubDate>Thu, 17 Jul 2025 22:04:43 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0717/</guid>
        <description>&lt;h2 id=&#34;数学-纸上得来终觉浅&#34;&gt;数学-纸上得来终觉浅
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;函数极限的定义($\epsilon,\delta$语言)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数极限的性质&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;唯一性&lt;/li&gt;
&lt;li&gt;局部有界性&lt;/li&gt;
&lt;li&gt;局部保号性&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无穷小(let $\alpha$ be infinitesimal)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;性质
&lt;ul&gt;
&lt;li&gt;$\sum\limits_{k}^{N}{\alpha_k}=\alpha,(N \text{ is finite})$&lt;/li&gt;
&lt;li&gt;$\alpha&amp;rsquo;\cdot f(x)=\alpha $,where $f(x)$ is limited at the interval&lt;/li&gt;
&lt;li&gt;$\prod\limits_{k}^{N}{\alpha_k}=\alpha,(N \text{ is finite})$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;比阶($\lim\alpha(x)=0$,$\lim\beta(x)=0$,$\beta(x)\neq0$)
&lt;ul&gt;
&lt;li&gt;$\alpha(x)$是$\beta(x)$的高阶无穷小$\Leftrightarrow\lim{\frac{\alpha(x)}{\beta(x)}}=0$&lt;/li&gt;
&lt;li&gt;$\alpha(x)$是$\beta(x)$的低阶无穷小$\Leftrightarrow\lim{\frac{\alpha(x)}{\beta(x)}}=\infty$&lt;/li&gt;
&lt;li&gt;$\alpha(x)$是$\beta(x)$的同阶无穷小$\Leftrightarrow\lim{\frac{\alpha(x)}{\beta(x)}}=c,(\text{constant }c\neq 0)$&lt;/li&gt;
&lt;li&gt;$\alpha(x)$是$\beta(x)$的等价无穷小$\Leftrightarrow\lim{\frac{\alpha(x)}{\beta(x)}}=1$&lt;/li&gt;
&lt;li&gt;$\alpha(x)$是$\beta(x)$的$k$阶无穷小$\Leftrightarrow\lim{\frac{\alpha(x)}{\beta^k(x)}}=0$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;极限的运算&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;四则运算&lt;/li&gt;
&lt;li&gt;洛必达法则&lt;/li&gt;
&lt;li&gt;泰勒展开&lt;/li&gt;
&lt;li&gt;夹逼准则&lt;/li&gt;
&lt;li&gt;七种未定式：$\frac{0}{0},\frac{\infty}{\infty},0\cdot\infty,\infty-\infty,\infty^0,0^0,1^{\infty}$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数的连续和两类间断点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;超实数(&lt;a class=&#34;link&#34; href=&#34;https://people.math.wisc.edu/~hkeisler/keislercalc-06-18-25.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;hyperreal number&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;操作系统-three-easy-piece&#34;&gt;操作系统-&lt;a class=&#34;link&#34; href=&#34;https://pages.cs.wisc.edu/~remzi/OSTEP/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;three easy piece&lt;/a&gt;
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;cpu-intro
&lt;ul&gt;
&lt;li&gt;the Process&lt;/li&gt;
&lt;li&gt;Process API
&lt;ol&gt;
&lt;li&gt;create&lt;/li&gt;
&lt;li&gt;Destory&lt;/li&gt;
&lt;li&gt;Wait&lt;/li&gt;
&lt;li&gt;Miscellaneous Control&lt;/li&gt;
&lt;li&gt;Status&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Process status&lt;/li&gt;
&lt;li&gt;Proc data structure:(PCB)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;cpu-api
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;fork()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;spawn()&lt;/code&gt;*&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;cpu-mechanisms
&lt;ol&gt;
&lt;li&gt;from Directed Execution to Limited Directed Execution:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;user mode and kernel mode&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;system call&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;switch between Processes,Os need to retain CPU from process
&lt;ul&gt;
&lt;li&gt;A Cooperative Approach: Wait For System Calls&lt;/li&gt;
&lt;li&gt;A Non-Cooperative Approach: The OS Takes Control&lt;/li&gt;
&lt;li&gt;reboot (x&lt;/li&gt;
&lt;li&gt;timer interrupt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Saving and Restoring Context&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;cpu-sched(reading)&lt;/li&gt;
&lt;li&gt;cpu-sched-mlfq(reading)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据结构-排好队一个一个fifo&#34;&gt;数据结构-排好队一个一个FIFO
&lt;/h2&gt;&lt;h3 id=&#34;队列&#34;&gt;队列
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;顺序队列的性质和操作&lt;/li&gt;
&lt;li&gt;循环队列的性质和操作&lt;/li&gt;
&lt;li&gt;链式队列的性质和操作&lt;/li&gt;
&lt;li&gt;双端队列&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号018-027&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0714学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0714/</link>
        <pubDate>Mon, 14 Jul 2025 21:15:02 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0714/</guid>
        <description>&lt;h2 id=&#34;操作系统-这什么查一下这什么查一下&#34;&gt;操作系统-这什么查一下这什么查一下
&lt;/h2&gt;&lt;h3 id=&#34;经典同步问题&#34;&gt;经典同步问题
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;生产者消费者问题&lt;/li&gt;
&lt;li&gt;哲学家进餐问题&lt;/li&gt;
&lt;li&gt;读者-写者问题&lt;/li&gt;
&lt;li&gt;理发师问题&lt;/li&gt;
&lt;li&gt;抽烟者问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;处理机调度&#34;&gt;处理机调度
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;处理及调度的层次&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;高级调度（作业调度、长程调度）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作业选择&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从**后备队列（外存中等待的作业）**中选择作业&lt;/li&gt;
&lt;li&gt;判断系统资源（内存、CPU、I/O）是否充足&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;资源分配&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为选中的作业分配内存、I/O、文件等资源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进程创建&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将作业转化为一个或多个&lt;strong&gt;进程&lt;/strong&gt;，放入就绪队列&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中级调度（内存调度、中程调度）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;选择部分进程挂起（移出内存到外存）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;选择挂起的进程恢复（从外存调回内存）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;低级调度（进程调度、线程调度、短程调度）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从&lt;strong&gt;就绪队列&lt;/strong&gt;中选择一个进程&lt;/li&gt;
&lt;li&gt;把 CPU 分配给选中的进程&lt;/li&gt;
&lt;li&gt;保存和恢复进程的上下文（&lt;strong&gt;进程切换 Context Switch&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;控制 CPU 的执行顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理机的调度方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非抢占式&lt;/li&gt;
&lt;li&gt;抢占式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择调度算法的若干准则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CPU利用率&lt;/p&gt;
$$
     \frac{\text{worktime of CPU}}{\text{total time}}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统吞吐量&lt;/p&gt;
$$
     \frac{\text{number of tasks}}{\text{total time}}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;周转时间(Turnaround Time)&lt;/p&gt;
$$
     \text{Completion Time - Arrival Time}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均周转时间&lt;/p&gt;
$$
     \frac{\sum\limits_{N}\text{Turnaround Time of all processes}}{N}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;带权周转时间&lt;/p&gt;
$$
     \frac{\text{Turnaround Time}}{\text{Service Time}}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均带权周转时间&lt;/p&gt;
$$
     \frac{\sum\limits_{N}\text{Weighted Turnaround Time of all processes}}{N}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待时间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;调度算法&#34;&gt;调度算法
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;FCFS（先来先服务）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SJF（最短作业优先）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抢占&lt;/li&gt;
&lt;li&gt;非抢占&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SRTF（最短剩余时间优先）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Priority Scheduling（高优先权优先调度）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抢占&lt;/li&gt;
&lt;li&gt;非抢占&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Highest Response Ratio Next (HRRN)（高响应比有点调度算法）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Round Robin（时间片轮转）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Multilevel Feedback Queue（多级反馈队列调度）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上下文切换&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CPU上下文切换&lt;/li&gt;
&lt;li&gt;系统调用上下文切换&lt;/li&gt;
&lt;li&gt;进程上下文切换
&lt;ul&gt;
&lt;li&gt;用户级&lt;/li&gt;
&lt;li&gt;系统级&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程上下文切换&lt;/li&gt;
&lt;li&gt;中断上下文切换&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号:012-015&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;数据结构-致敬传奇栈帧pc程序计数器&#34;&gt;数据结构-致敬传奇栈帧PC程序计数器
&lt;/h2&gt;&lt;h3 id=&#34;栈&#34;&gt;栈
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;静态顺序栈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判空&lt;/li&gt;
&lt;li&gt;判满&lt;/li&gt;
&lt;li&gt;进栈&lt;/li&gt;
&lt;li&gt;出栈&lt;/li&gt;
&lt;li&gt;获取栈顶元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态顺序栈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判空&lt;/li&gt;
&lt;li&gt;判满&lt;/li&gt;
&lt;li&gt;进栈&lt;/li&gt;
&lt;li&gt;出栈&lt;/li&gt;
&lt;li&gt;获取栈顶元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链栈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判空&lt;/li&gt;
&lt;li&gt;判满&lt;/li&gt;
&lt;li&gt;进栈&lt;/li&gt;
&lt;li&gt;出栈&lt;/li&gt;
&lt;li&gt;获取栈顶元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;栈的应用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;括号匹配&lt;/li&gt;
&lt;li&gt;进制转换（辗转相除）&lt;/li&gt;
&lt;li&gt;函数递归调用&lt;/li&gt;
&lt;li&gt;表达式求值
&lt;ul&gt;
&lt;li&gt;前缀&lt;/li&gt;
&lt;li&gt;中缀（重要）&lt;/li&gt;
&lt;li&gt;后缀&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号：014-017&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;数学-太好了是张宇老师我们有救了&#34;&gt;数学-太好了是张宇老师我们有救了！
&lt;/h2&gt;&lt;h3 id=&#34;函数的概念与特性&#34;&gt;函数的概念与特性
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;函数&lt;/li&gt;
&lt;li&gt;反函数&lt;/li&gt;
&lt;li&gt;复合函数&lt;/li&gt;
&lt;li&gt;隐函数&lt;/li&gt;
&lt;li&gt;函数的四种特性
&lt;ul&gt;
&lt;li&gt;有界性&lt;/li&gt;
&lt;li&gt;单调性&lt;/li&gt;
&lt;li&gt;奇偶性&lt;/li&gt;
&lt;li&gt;周期性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基本初等函数与初等函数
&lt;ul&gt;
&lt;li&gt;常函数&lt;/li&gt;
&lt;li&gt;幂函数&lt;/li&gt;
&lt;li&gt;指数函数&lt;/li&gt;
&lt;li&gt;对数函数&lt;/li&gt;
&lt;li&gt;三角函数
&lt;ol&gt;
&lt;li&gt;sin x  cos x&lt;/li&gt;
&lt;li&gt;csc x sec x&lt;/li&gt;
&lt;li&gt;tan x cot x&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;反三角函数
&lt;ol&gt;
&lt;li&gt;arcsin x arccos x&lt;/li&gt;
&lt;li&gt;arctanx arccot x&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分段函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;高数第一讲&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0711学习日志</title>
        <link>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0711/</link>
        <pubDate>Fri, 11 Jul 2025 20:29:14 +0800</pubDate>
        
        <guid>https://auroraemiya.github.io/npee_learning_log.github.io/posts/0711/</guid>
        <description>&lt;h2 id=&#34;数据结构-太好了是死记硬背&#34;&gt;数据结构-太好了是死记硬背
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数据的逻辑和物理结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://auroraemiya.github.io/npee_learning_log.github.io/posts/0711/QQ20250711-202720.png&#34;
	width=&#34;1702&#34;
	height=&#34;743&#34;
	srcset=&#34;https://auroraemiya.github.io/npee_learning_log.github.io/posts/0711/QQ20250711-202720_hu_ab8a865d16a46851.png 480w, https://auroraemiya.github.io/npee_learning_log.github.io/posts/0711/QQ20250711-202720_hu_5cae573c8a98f94d.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;229&#34;
		data-flex-basis=&#34;549px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算法的时间空间复杂度&lt;/li&gt;
&lt;li&gt;线性表的顺序表以及相关算法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;课程编号001-009&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;操作系统-想念jyy的第n天&#34;&gt;操作系统-想念jyy的第n天
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;操作系统概述
&lt;ul&gt;
&lt;li&gt;并发&lt;/li&gt;
&lt;li&gt;共享&lt;/li&gt;
&lt;li&gt;虚拟&lt;/li&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统的发展历程
&lt;ul&gt;
&lt;li&gt;批处理器
&lt;ul&gt;
&lt;li&gt;单道&lt;/li&gt;
&lt;li&gt;多道&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分时操作系统&lt;/li&gt;
&lt;li&gt;实时操作系统&lt;/li&gt;
&lt;li&gt;网络操作系统&lt;/li&gt;
&lt;li&gt;分布式操作系统&lt;/li&gt;
&lt;li&gt;&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;课程编号001-002&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
