<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on shyの考研日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/</link>
        <description>Recent content in Posts on shyの考研日志</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 14 Aug 2025 22:31:10 +0800</lastBuildDate><atom:link href="http://localhost:1313/npee_learning_log.github.io/posts/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>0814学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0814/</link>
        <pubDate>Thu, 14 Aug 2025 22:31:10 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0814/</guid>
        <description>&lt;h2 id=&#34;概率论-自然界是对数的吗&#34;&gt;概率论-自然界是对数的吗？
&lt;/h2&gt;&lt;h3 id=&#34;基本概念&#34;&gt;基本概念
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;随机试验&lt;/p&gt;
&lt;p&gt;（1）试验可以在相同的条件下重复进行&lt;/p&gt;
&lt;p&gt;（2）实验所有可能结果明确可知，且不止一个&lt;/p&gt;
&lt;p&gt;（3）每一次试验会出现哪一个结果，事先并不能确定&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;投篮&lt;/li&gt;
&lt;li&gt;掷硬币&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随机事件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;样本空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件的关系与运算&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关系
&lt;ul&gt;
&lt;li&gt;包含：如果事件A发生必导致事件B发生，则称事件B&lt;strong&gt;包含&lt;/strong&gt;事件A,$A\subset B$&lt;/li&gt;
&lt;li&gt;相等&lt;/li&gt;
&lt;li&gt;积（交）：称“事件A与B同时发生”的事件为事件A与B的积事件，$A\cap B$&lt;/li&gt;
&lt;li&gt;相容：若$AB\neq \varnothing$则称事件A和B相容&lt;/li&gt;
&lt;li&gt;互斥：若$AB=\varnothing$,则称事件A和B互不相容，即互斥&lt;/li&gt;
&lt;li&gt;和（并）：“事件A与B至少有一个发生”的事件为事件A与B的和事件，$A\cup B$&lt;/li&gt;
&lt;li&gt;差：“事件A与B至少有一个发生”的事件为事件A与B的差事件，$A-B$&lt;/li&gt;
&lt;li&gt;逆（对立）&lt;/li&gt;
&lt;li&gt;完备事件组&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;运算
&lt;ol&gt;
&lt;li&gt;吸收律&lt;/li&gt;
&lt;li&gt;交换律&lt;/li&gt;
&lt;li&gt;结合律&lt;/li&gt;
&lt;li&gt;分配律&lt;/li&gt;
&lt;li&gt;对偶率（德摩根律）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;概率的定义&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;描述性定义&lt;/li&gt;
&lt;li&gt;统计性定义&lt;/li&gt;
&lt;li&gt;公理化定义&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;古典概型和几何概型&#34;&gt;古典概型和几何概型
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;古典概型
&lt;ol&gt;
&lt;li&gt;概念
&lt;ul&gt;
&lt;li&gt;只有有限个样本点（基本事件）&lt;/li&gt;
&lt;li&gt;每个样本点（基本事件）发生的可能性都一样&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;计算方法
&lt;ol&gt;
&lt;li&gt;随机分配问题&lt;/li&gt;
&lt;li&gt;简单随机抽样问题&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;几何概型
&lt;ol&gt;
&lt;li&gt;概念
&lt;ul&gt;
&lt;li&gt;样本空间（基本事件空间）$\Omega$是一个可度量的有界区域&lt;/li&gt;
&lt;li&gt;每个样本点（基本事件）发生的可能性都一样，即样本点落入$\Omega$的某一个可度量的子区域$S$的可能性大小和S的几何度量成正比。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0813学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0813/</link>
        <pubDate>Wed, 13 Aug 2025 09:45:22 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0813/</guid>
        <description>&lt;h2 id=&#34;计算机组成原理&#34;&gt;计算机组成原理
&lt;/h2&gt;&lt;h3 id=&#34;计算机系统概述&#34;&gt;计算机系统概述
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;冯诺依曼计算机的特点
&lt;ol&gt;
&lt;li&gt;采用“存储程序”的工作方式&lt;/li&gt;
&lt;li&gt;计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备五大设备类型&lt;/li&gt;
&lt;li&gt;指令和数据以同等地位存储在存储器中，形式上没有任何区别，但计算机应能区分它们&lt;/li&gt;
&lt;li&gt;指令和数据均用二进制代码表示&lt;/li&gt;
&lt;li&gt;指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;计算机的功能部件
&lt;ol&gt;
&lt;li&gt;输入设备&lt;/li&gt;
&lt;li&gt;输出设备&lt;/li&gt;
&lt;li&gt;存储器&lt;/li&gt;
&lt;li&gt;运算器&lt;/li&gt;
&lt;li&gt;控制器&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;计算机软件
&lt;ol&gt;
&lt;li&gt;系统软件和应用软件&lt;/li&gt;
&lt;li&gt;三个级别的语言&lt;/li&gt;
&lt;li&gt;软件和硬件的逻辑功能等价性&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;计算机系统的层次结构
&lt;ol&gt;
&lt;li&gt;微程序机器层&lt;/li&gt;
&lt;li&gt;传统机器语言层&lt;/li&gt;
&lt;li&gt;操作系统层&lt;/li&gt;
&lt;li&gt;汇编语言层&lt;/li&gt;
&lt;li&gt;高级语言层&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;计算机系统的工作原理
&lt;ol&gt;
&lt;li&gt;“存储程序”工作方式&lt;/li&gt;
&lt;li&gt;从源文件到可执行文件*
&lt;ol&gt;
&lt;li&gt;预处理阶段(pre process)&lt;/li&gt;
&lt;li&gt;编译阶段(compile)&lt;/li&gt;
&lt;li&gt;汇编阶段(assemble)&lt;/li&gt;
&lt;li&gt;链接阶段(link)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;指令执行过程的描述
&lt;ol&gt;
&lt;li&gt;取指令&lt;/li&gt;
&lt;li&gt;分析指令&lt;/li&gt;
&lt;li&gt;执行指令&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;计算机的性能指标&#34;&gt;计算机的性能指标
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;计算机的主要性能指标&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;机器字长&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据通路带宽&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主存容量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运算速度&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;吞吐量和响应时间&lt;/li&gt;
&lt;li&gt;主频和CPU时钟周期&lt;/li&gt;
&lt;li&gt;CPI(Cycle per Instruction)&lt;/li&gt;
&lt;li&gt;IPS(Instruction per Second)&lt;/li&gt;
&lt;li&gt;CPU执行时间 = CPU时钟周期数/主频 = （指令条数/CPI）/主频&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;CPU的性能取决于三个要素：&lt;strong&gt;主频、CPI和指令条数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;MIPS(Million Instruction per Second) = 指令条数/(执行时间*$10^6$)&lt;/li&gt;
&lt;li&gt;FLOPS(Floating-point Operations Per Second)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基准程序(benchmark)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0811学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0811/</link>
        <pubDate>Mon, 11 Aug 2025 23:43:07 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0811/</guid>
        <description>&lt;h2 id=&#34;数据结构&#34;&gt;数据结构
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;插入排序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直接插入排序&lt;/li&gt;
&lt;li&gt;折半插入排序&lt;/li&gt;
&lt;li&gt;希尔排序&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交换排序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;冒泡排序&lt;/li&gt;
&lt;li&gt;快速排序&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二路归并排序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基数排序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;外部排序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多路平衡归并与败者树&lt;/li&gt;
&lt;li&gt;置换-选择排序&lt;/li&gt;
&lt;li&gt;最佳归并树&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;排序算法的分析和应用&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;算法&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;时间复杂度&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;最好情况&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;平均情况&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;最坏情况&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;空间复杂度&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;稳定性&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;直接插入排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(1)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;是&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;冒泡排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(1)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;是&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;简单选择排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(1)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;否&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;希尔排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(1)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;否&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;快速排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n^2)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;否&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;堆排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(1)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;否&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;二路归并排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(n)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;是&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;基数排序&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(d(n+r)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(d(n+r))$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(d(n+r)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$O(1)$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;是&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0809学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0809/</link>
        <pubDate>Sat, 09 Aug 2025 23:52:51 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0809/</guid>
        <description>&lt;h2 id=&#34;数据结构-查找&#34;&gt;数据结构-查找
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;顺序查找法&lt;/li&gt;
&lt;li&gt;分块查找法（索引顺序查找）&lt;/li&gt;
&lt;li&gt;折半查找法
&lt;ul&gt;
&lt;li&gt;判定树&lt;/li&gt;
&lt;li&gt;ASL（平均查找长度）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二叉搜索树
&lt;ol&gt;
&lt;li&gt;查找&lt;/li&gt;
&lt;li&gt;插入&lt;/li&gt;
&lt;li&gt;构造&lt;/li&gt;
&lt;li&gt;删除（中序）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;平衡二叉树（AVL）
&lt;ol&gt;
&lt;li&gt;插入
&lt;ul&gt;
&lt;li&gt;LL平衡旋转&lt;/li&gt;
&lt;li&gt;LR平衡旋转&lt;/li&gt;
&lt;li&gt;RR平衡旋转&lt;/li&gt;
&lt;li&gt;RL平衡旋转&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;构造&lt;/li&gt;
&lt;li&gt;删除&lt;/li&gt;
&lt;li&gt;查找&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;红黑树
&lt;ol&gt;
&lt;li&gt;定义
&lt;ul&gt;
&lt;li&gt;每个结点或是黑色或是红色&lt;/li&gt;
&lt;li&gt;根节点是黑色的&lt;/li&gt;
&lt;li&gt;叶节点（虚构的外部节点、NULL节点）都是黑色&lt;/li&gt;
&lt;li&gt;不存在两个相邻的红节点&lt;/li&gt;
&lt;li&gt;对于每个结点，从该结点到任意一个叶节点的简单路径上，所含黑节点的数量相同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结论
&lt;ol&gt;
&lt;li&gt;从根到叶结点的最长路径不大于最短路径的2倍&lt;/li&gt;
&lt;li&gt;有n个内部结点的红黑树的高度$h\leq 2\log_2{(n+1)}$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;插入
&lt;ul&gt;
&lt;li&gt;新插入红黑树的结点初始着为红色&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除*&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0808学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0808/</link>
        <pubDate>Fri, 08 Aug 2025 20:11:28 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0808/</guid>
        <description>&lt;h2 id=&#34;数学-一元微分学的应用&#34;&gt;数学-一元微分学的应用
&lt;/h2&gt;&lt;h3 id=&#34;微分等式&#34;&gt;微分等式
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;零点定理（证明根的存在性）&lt;/li&gt;
&lt;li&gt;单调性（证明根的唯一性）&lt;/li&gt;
&lt;li&gt;罗尔定理及其推论&lt;/li&gt;
&lt;li&gt;实系数奇次方程至少有一个实根($-\infty +\infty$)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;微分不等式&#34;&gt;微分不等式
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;用函数性态（包括单调性、凹凸性和最值）&lt;/li&gt;
&lt;li&gt;用常数变量化证明不等式&lt;/li&gt;
&lt;li&gt;用中值定理证明不等式&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;物理应用与相关变化率&#34;&gt;物理应用与相关变化率
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;物理应用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;速度&lt;/li&gt;
&lt;li&gt;加速度&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相关变化率&lt;/p&gt;
$$
   \dfrac{dA}{dB}=\dfrac{dA}{dC}\cdot\dfrac{dC}{dB}
   $$&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;操作系统-three-easy-pieces&#34;&gt;操作系统-Three easy pieces
&lt;/h2&gt;&lt;h3 id=&#34;segmentation&#34;&gt;Segmentation
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;explicit approach&lt;/p&gt;
&lt;p&gt;[&amp;mdash;&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; ] (address)&lt;/p&gt;
&lt;p&gt;[ segment |         offset        ]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;implicit approach&lt;/p&gt;
&lt;p&gt;Hardware determined.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Coarse segmentation vs. Fine segmentation&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;free-space-management&#34;&gt;Free Space Management
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Low level Mechanisms
&lt;ol&gt;
&lt;li&gt;Splitting and coalescing&lt;/li&gt;
&lt;li&gt;Embedding a free list&lt;/li&gt;
&lt;li&gt;Growing a Heap&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Basic Strategies
&lt;ol&gt;
&lt;li&gt;Best Fit&lt;/li&gt;
&lt;li&gt;First Fit&lt;/li&gt;
&lt;li&gt;Next Fit&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Other Approaches
&lt;ol&gt;
&lt;li&gt;Segregated Lists&lt;/li&gt;
&lt;li&gt;Buddy Allocation&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;introduction-to-paging&#34;&gt;Introduction to Paging
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Page table&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PTE&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/npee_learning_log.github.io/posts/0808/PTE.png&#34;
	width=&#34;2034&#34;
	height=&#34;350&#34;
	srcset=&#34;http://localhost:1313/npee_learning_log.github.io/posts/0808/PTE_hu_6093a7be5b2aaf3a.png 480w, http://localhost:1313/npee_learning_log.github.io/posts/0808/PTE_hu_7cba0b1a9e3e7fa4.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Page table entry&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;581&#34;
		data-flex-basis=&#34;1394px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0807学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0807/</link>
        <pubDate>Thu, 07 Aug 2025 19:33:44 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0807/</guid>
        <description>&lt;h2 id=&#34;数学-太好了是中值定理我们有救了&#34;&gt;数学-太好了是中值定理我们有救了
&lt;/h2&gt;&lt;h3 id=&#34;中值定理&#34;&gt;中值定理
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;有界与最值定理：&lt;/p&gt;
&lt;p&gt;若函数 $f$ 在闭区间 $[a, b]$ 上&lt;strong&gt;连续&lt;/strong&gt;，则 $f$ 在 $[a, b]$ 上取得&lt;strong&gt;最大值&lt;/strong&gt;和&lt;strong&gt;最小值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;即存在 $x_{\min}, x_{\max} \in [a, b]$ 使得：&lt;/p&gt;
$$
   f(x_{\min}) \le f(x) \le f(x_{\max}),\quad \forall x \in [a,b]
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;界值定理&lt;/p&gt;
&lt;p&gt;设 $f$ 在闭区间 $[a, b]$ 上连续，若 $f(a) &amp;lt; 0 &amp;lt; f(b)$，则存在 $c \in (a, b)$ 使得 $f(c) = 0$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均值定理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;零点定理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;费马定理：&lt;/p&gt;
&lt;p&gt;若函数 $f$ 在 $x_0$ 点可导，且在该点取得极值（极大或极小），则：&lt;/p&gt;
$$
     f&#39;(x_0) = 0
     $$&lt;ul&gt;
&lt;li&gt;(引理)导数零点定理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;罗尔定理&lt;/p&gt;
&lt;p&gt;设 $f$ 在 $[a, b]$ 上连续，在 $(a,b)$ 上可导，且：&lt;/p&gt;
$$
     f(a) = f(b)
     $$&lt;p&gt;则存在 $c \in (a, b)$ 使得：&lt;/p&gt;
$$
     f&#39;(c) = 0
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拉格朗日中值定理&lt;/p&gt;
&lt;p&gt;设 $f$ 在 $[a,b]$ 上连续，$(a,b)$ 上可导，则存在 $c \in (a,b)$，使得：&lt;/p&gt;
$$
     f&#39;(c) = \frac{f(b) - f(a)}{b - a}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;柯西中值定理&lt;/p&gt;
&lt;p&gt;设函数 $f,g$ 在 $[a,b]$ 上连续，$(a,b)$ 可导，且 $g&amp;rsquo;(x) \ne 0$ 于 $(a,b)$，则存在 $c \in (a,b)$，使得：&lt;/p&gt;
$$
     \frac{f&#39;(c)}{g&#39;(c)} = \frac{f(b) - f(a)}{g(b) - g(a)}
     $$&lt;h3 id=&#34;&#34;&gt;
&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;泰勒公式&lt;/p&gt;
&lt;p&gt;若 $f \in C^{n+1}[a,b]$，则对 $x \in [a,b]$，存在 $\xi$ 介于 $a$ 与 $x$ 之间，使得：&lt;/p&gt;
$$
     f(x) = f(a) + f&#39;(a)(x - a) + \cdots + \frac{f^{(n)}(a)}{n!}(x - a)^n + \frac{f^{(n+1)}(\xi)}{(n+1)!}(x - a)^{n+1}
     $$&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>0806学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0806/</link>
        <pubDate>Wed, 06 Aug 2025 20:32:24 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0806/</guid>
        <description>&lt;h2 id=&#34;操作系统-three-easy-pieces&#34;&gt;操作系统-three easy pieces
&lt;/h2&gt;&lt;h3 id=&#34;memory-api&#34;&gt;Memory API
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void * malloc(size_t size)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void free(void* ptr)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;common-errors&#34;&gt;Common Errors
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Forgetting To Allocate Memory&lt;/li&gt;
&lt;li&gt;Not Allocating Enough Memory&lt;/li&gt;
&lt;li&gt;Forgetting To Initializing Memory&lt;/li&gt;
&lt;li&gt;Forgetting To Free Memory&lt;/li&gt;
&lt;li&gt;Freeing Memory Before You Are Done With It&lt;/li&gt;
&lt;li&gt;Freeing Memory Repeatedly&lt;/li&gt;
&lt;li&gt;Calling &lt;code&gt;free()&lt;/code&gt; Incorrectly&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;other-call&#34;&gt;Other Call
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;calloc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;realloc()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;address-translation&#34;&gt;Address Translation
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;hardware-based address translation: Base and bound&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/npee_learning_log.github.io/posts/0806/Base_and_bound.png&#34;
	width=&#34;723&#34;
	height=&#34;1122&#34;
	srcset=&#34;http://localhost:1313/npee_learning_log.github.io/posts/0806/Base_and_bound_hu_aba0641098e337a8.png 480w, http://localhost:1313/npee_learning_log.github.io/posts/0806/Base_and_bound_hu_72a071f4a027da31.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;mechanism&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;64&#34;
		data-flex-basis=&#34;154px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0804学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0804/</link>
        <pubDate>Mon, 04 Aug 2025 20:51:06 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0804/</guid>
        <description>&lt;h2 id=&#34;操作系统-io管理&#34;&gt;操作系统-IO管理
&lt;/h2&gt;&lt;h3 id=&#34;io层次结构&#34;&gt;IO层次结构
&lt;/h3&gt;&lt;p&gt;计算机的外部设备（I/O 设备）种类繁多，特性千差万别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;速度差异巨大：&lt;/strong&gt; CPU 的速度比键盘快上亿倍，但比高速的 NVMe SSD 又慢一些。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能各异：&lt;/strong&gt; 打印机是输出设备，键盘是输入设备，硬盘既是输入也是输出设备。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制方式复杂：&lt;/strong&gt; 每个设备都有自己独特的指令集、寄存器和工作协议。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果让每个应用程序都去直接和这些具体的硬件打交道，那将是一场灾难。因此，操作系统设计了一个分层的结构来管理 I/O，其主要目标是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;设备独立性（Device Independence）：&lt;/strong&gt; 应用程序的编写不应依赖于具体的物理设备。例如，一个程序向一个文件写入数据，它不应该关心这个文件是存在于机械硬盘、U盘还是网络存储上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;统一接口（Uniform Interface）：&lt;/strong&gt; 为应用程序提供一个简洁、一致的访问接口。在类 Unix 系统中，这个思想的极致体现就是“一切皆文件”，无论是访问硬盘、键盘还是打印机，都可以使用类似 &lt;code&gt;read()&lt;/code&gt; 和 &lt;code&gt;write()&lt;/code&gt; 的函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;错误处理（Error Handling）：&lt;/strong&gt; 在尽可能低的层次处理设备错误，只将无法解决的严重错误向上层报告，简化上层软件的逻辑。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;效率与性能（Efficiency and Performance）：&lt;/strong&gt; 通过缓冲（Buffering）、缓存（Caching）和异步操作等技术，协调高速 CPU 与低速设备之间的矛盾，提高系统整体吞吐量。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I/O 软件通常被组织成一个四到五层的结构。一个 I/O 请求会从顶层逐级向下传递，直到硬件；而操作完成的信号和数据则会从底层逐级向上传递。&lt;/p&gt;
&lt;p&gt;下面是从上到下（从用户到硬件）的层次结构：&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;第-1-层用户层-io-软件-user-level-io-software&#34;&gt;&lt;strong&gt;第 1 层：用户层 I/O 软件 (User-Level I/O Software)&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;这是最靠近应用程序的一层，它不是操作系统内核的一部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能：&lt;/strong&gt; 为应用程序员提供方便的接口库（Library），这些库函数最终会通过**系统调用（System Call）**请求内核的服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;例子：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;C语言中的标准 I/O 库函数，如 &lt;code&gt;printf()&lt;/code&gt;, &lt;code&gt;scanf()&lt;/code&gt;, &lt;code&gt;fopen()&lt;/code&gt;, &lt;code&gt;fread()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;各种编程语言提供的 I/O 库。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作流程：&lt;/strong&gt; 比如，当你在程序中调用 &lt;code&gt;printf(&amp;quot;Hello&amp;quot;)&lt;/code&gt; 时，&lt;code&gt;printf&lt;/code&gt; 函数会格式化字符串，然后调用底层的 &lt;code&gt;write()&lt;/code&gt; 系统调用，请求内核将数据输出到屏幕。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;第-2-层设备无关的操作系统软件-device-independent-os-software&#34;&gt;&lt;strong&gt;第 2 层：设备无关的操作系统软件 (Device-Independent OS Software)&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;这是 I/O 结构的核心，它实现了设备独立性的主要逻辑。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能：&lt;/strong&gt; 提供一个对所有设备都统一的框架。它负责处理所有设备共有的功能。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;统一接口：&lt;/strong&gt; 向用户层提供统一的系统调用接口（如 &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设备命名：&lt;/strong&gt; 将设备映射到文件系统中的名字（例如 Linux 中的 &lt;code&gt;/dev/sda1&lt;/code&gt; 代表第一个硬盘的第一个分区）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设备保护：&lt;/strong&gt; 检查用户是否有权限访问某个设备。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提供缓冲（Buffering）：&lt;/strong&gt; 在用户空间和设备之间提供数据缓冲区，以协调速度差异。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分配与释放：&lt;/strong&gt; 管理设备的分配和释放，例如独占设备（如打印机）的使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;例子：&lt;/strong&gt; Linux 中的虚拟文件系统（VFS）层就扮演了这个角色。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;第-3-层设备驱动程序-device-drivers&#34;&gt;&lt;strong&gt;第 3 层：设备驱动程序 (Device Drivers)&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;这是操作系统内核中与特定设备直接相关的部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能：&lt;/strong&gt; 充当“翻译官”的角色。它接收来自上层（设备无关层）的抽象命令（如“从这个设备读取 512 字节”），并将其翻译成设备控制器能够理解的具体指令（如向设备的某个寄存器写入特定的值）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;设备特定：&lt;/strong&gt; 每种类型的设备（或一个设备家族）都有一个专门的驱动程序。例如，NVIDIA 显卡有其驱动，Intel 的网卡有它的驱动。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可加载模块：&lt;/strong&gt; 现代操作系统通常将驱动程序实现为内核模块，可以在系统运行时动态加载或卸载，而无需重新编译整个内核。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作流程：&lt;/strong&gt; 驱动程序设置好设备寄存器，命令设备开始工作后，它通常会阻塞（等待）直到设备完成操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;第-4-层中断处理程序-interrupt-handlers&#34;&gt;&lt;strong&gt;第 4 层：中断处理程序 (Interrupt Handlers)&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;这是处理硬件与软件交互最底层、最直接的部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能：&lt;/strong&gt; 当 I/O 设备完成一项任务（例如，硬盘读完一个数据块）或者发生错误时，它会向 CPU 发送一个&lt;strong&gt;中断信号（Interrupt）&lt;/strong&gt;。中断处理程序就是被这个信号触发而运行的一段代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作流程：&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;CPU 暂停当前正在执行的任何任务。&lt;/li&gt;
&lt;li&gt;保存当前任务的上下文（寄存器状态等）。&lt;/li&gt;
&lt;li&gt;跳转到预设的中断处理程序地址并开始执行。&lt;/li&gt;
&lt;li&gt;中断处理程序分析中断原因，进行相应处理（例如，将从设备读取的数据放入缓冲区，并唤醒正在等待这个数据的设备驱动程序）。&lt;/li&gt;
&lt;li&gt;处理完毕后，恢复之前被暂停任务的上下文，让它继续运行。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;核心作用：&lt;/strong&gt; 实现了真正的异步操作，让 CPU 在等待 I/O 时可以去做别的事情，而不是空闲等待。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;第-5-层硬件-hardware&#34;&gt;&lt;strong&gt;第 5 层：硬件 (Hardware)&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;这是层次结构的最底层，包含了物理设备本身及其控制器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;组成：&lt;/strong&gt; 设备本身（如磁盘盘片、打印机喷头）和设备控制器（一块包含寄存器和逻辑电路的芯片，负责与 CPU 通信）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能：&lt;/strong&gt; 真正执行 I/O 操作的物理实体。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;一次-io-请求的完整流程以读文件为例&#34;&gt;一次 I/O 请求的完整流程（以读文件为例）
&lt;/h4&gt;&lt;p&gt;假设一个用户程序执行 &lt;code&gt;read(fd, buffer, nbytes)&lt;/code&gt; 来读取文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;用户层：&lt;/strong&gt; &lt;code&gt;read()&lt;/code&gt; 库函数打包参数，并发起一个&lt;strong&gt;系统调用&lt;/strong&gt;陷入内核。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设备无关层：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;内核的设备无关软件接收到请求。&lt;/li&gt;
&lt;li&gt;它首先检查内核的&lt;strong&gt;缓冲区缓存（Buffer Cache）&lt;/strong&gt;，看请求的数据是否已经存在。如果命中，则直接从缓存复制数据到用户 &lt;code&gt;buffer&lt;/code&gt;，请求结束。&lt;/li&gt;
&lt;li&gt;如果未命中，它会计算出需要从哪个设备的哪个物理位置读取数据。&lt;/li&gt;
&lt;li&gt;然后调用该设备的&lt;strong&gt;驱动程序&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设备驱动层：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;设备驱动程序接收到请求（例如，“读取硬盘的第 12345 号逻辑块”）。&lt;/li&gt;
&lt;li&gt;它将这个抽象请求翻译成设备控制器能懂的命令，并把这些命令写入设备控制器的寄存器中。&lt;/li&gt;
&lt;li&gt;驱动程序随后&lt;strong&gt;阻塞&lt;/strong&gt;当前进程（将其放入等待队列），并让出 CPU。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬件层：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;设备控制器开始工作，驱动硬盘马达，移动磁头，读取数据到其内部缓冲区。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断处理层（返回过程）：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;当硬件完成数据读取后，它向 CPU 发送一个&lt;strong&gt;中断&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;CPU 捕获中断，并执行对应的&lt;strong&gt;中断处理程序&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;中断处理程序从设备控制器的缓冲区取出数据，放入内核的缓冲区缓存中。&lt;/li&gt;
&lt;li&gt;然后，它唤醒之前被阻塞的设备驱动进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回上层：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;被唤醒的设备驱动程序得知操作已完成。&lt;/li&gt;
&lt;li&gt;设备无关层将数据从内核的缓冲区缓存复制到用户程序指定的 &lt;code&gt;buffer&lt;/code&gt; 中。&lt;/li&gt;
&lt;li&gt;系统调用返回，用户程序从 &lt;code&gt;read()&lt;/code&gt; 调用处继续执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;层次&lt;/th&gt;
          &lt;th&gt;主要功能&lt;/th&gt;
          &lt;th&gt;例子&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;用户层软件&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;提供方便的编程接口，发起系统调用&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;printf()&lt;/code&gt;, &lt;code&gt;fopen()&lt;/code&gt; 等库函数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;设备无关OS软件&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;提供统一接口，设备命名，缓冲，错误报告，分配与释放&lt;/td&gt;
          &lt;td&gt;虚拟文件系统(VFS)，缓冲区缓存管理&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;设备驱动程序&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;设置设备寄存器，检查设备状态，将抽象命令翻译为具体指令&lt;/td&gt;
          &lt;td&gt;显卡驱动，网卡驱动，磁盘驱动&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;中断处理程序&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;响应硬件中断，保存CPU状态，唤醒驱动程序&lt;/td&gt;
          &lt;td&gt;I/O 完成中断，时钟中断&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;硬件&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;执行具体的I/O操作&lt;/td&gt;
          &lt;td&gt;磁盘控制器，键盘控制器，物理设备本身&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;(Output by Gemini2.5pro)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;dma&#34;&gt;DMA
&lt;/h3&gt;&lt;p&gt;（DMA工作流程）&lt;/p&gt;
&lt;p&gt;DMA的出现就是为了将CPU从这种繁琐的搬运工作中解放出来。下面是DMA的工作流程，以及各层次扮演的角色：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;步骤&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;动作&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;负责的层次/组件&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;用户程序发起一个读操作（例如 &lt;code&gt;read()&lt;/code&gt; 系统调用）。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;用户层软件&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;系统调用陷入内核，请求被&lt;strong&gt;设备无关的OS软件&lt;/strong&gt;接收。它可能会检查缓存，如果未命中，则确定需要调用哪个驱动。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;设备无关的OS软件&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;设备驱动程序&lt;/strong&gt;被调用。这是最关键的一步，驱动程序开始&lt;strong&gt;配置DMA&lt;/strong&gt;：&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;1. 在内存中分配一个缓冲区（Buffer）。&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;2. 告诉&lt;strong&gt;DMA控制器&lt;/strong&gt;四件事：&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;   - &lt;strong&gt;源地址&lt;/strong&gt;：要从哪个设备寄存器读取数据。&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;   - &lt;strong&gt;目标地址&lt;/strong&gt;：数据要存放到内存的哪个位置（即缓冲区地址）。&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;   - &lt;strong&gt;传输长度&lt;/strong&gt;：要传输多少字节的数据。&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;   - &lt;strong&gt;传输方向&lt;/strong&gt;：是从设备读到内存，还是从内存写到设备。&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;3. 驱动程序向&lt;strong&gt;设备控制器&lt;/strong&gt;发出“开始传输数据给DMA”的命令。&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;4. 驱动程序将当前进程&lt;strong&gt;阻塞&lt;/strong&gt;，并让出CPU给其他进程使用。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;设备驱动程序&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;DMA控制器&lt;/strong&gt;完全接管数据传输。它直接与&lt;strong&gt;设备控制器&lt;/strong&gt;和&lt;strong&gt;内存总线&lt;/strong&gt;交互，将数据块从设备搬运到内存缓冲区，整个过程&lt;strong&gt;无需CPU干预&lt;/strong&gt;。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;硬件层 (DMA控制器 &amp;amp; 设备控制器)&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;数据传输完成后，&lt;strong&gt;DMA控制器&lt;/strong&gt;会向CPU发送一个&lt;strong&gt;中断信号&lt;/strong&gt;，通知任务已完成。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;硬件层 (DMA控制器)&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;CPU捕获中断，并跳转到&lt;strong&gt;中断处理程序&lt;/strong&gt;执行。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;中断处理程序&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;中断处理程序分析中断来源，发现是DMA完成中断。于是它&lt;strong&gt;唤醒&lt;/strong&gt;之前被阻塞的&lt;strong&gt;设备驱动程序&lt;/strong&gt;对应的进程。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;中断处理程序&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;8&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;驱动程序被唤醒后，知道数据已经安全地存放在内存缓冲区里了。它进行一些清理工作，并将结果报告给上层。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;设备驱动程序&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;设备无关的OS软件&lt;/strong&gt;将数据从内核的缓冲区复制到用户程序的缓冲区，然后系统调用返回。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;设备无关的OS软件&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spooling&#34;&gt;SPOOLing
&lt;/h3&gt;&lt;h3 id=&#34;引导过程&#34;&gt;引导过程
&lt;/h3&gt;&lt;p&gt;好的，我们来详细、系统地讲解一下计算机的&lt;strong&gt;引导过程（Booting Process 或 Bootstrap）&lt;/strong&gt;。这个过程是指从按下电源按钮开始，到操作系统完全加载并准备好与用户交互为止的一系列复杂而有序的步骤。&lt;/p&gt;
&lt;p&gt;“Bootstrap”这个词源于一个古老的说法“pull oneself up by one&amp;rsquo;s bootstraps”（靠自己鞋带把自己拉起来），形象地比喻了计算机在没有任何外部帮助的情况下，如何一步步地“唤醒”自己。&lt;/p&gt;
&lt;p&gt;计算机的引导过程主要可以分为两种主流方式：传统的 &lt;strong&gt;BIOS-MBR&lt;/strong&gt; 方式和现代的 &lt;strong&gt;UEFI-GPT&lt;/strong&gt; 方式。我们分别来介绍。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;1-传统的-bios-mbr-引导过程&#34;&gt;1. 传统的 BIOS-MBR 引导过程
&lt;/h4&gt;&lt;p&gt;这是在2010年之前个人电脑最常见的引导方式。&lt;/p&gt;
&lt;h5 id=&#34;阶段一bios-阶段-固件执行&#34;&gt;&lt;strong&gt;阶段一：BIOS 阶段 (固件执行)&lt;/strong&gt;
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;上电 (Power On)：&lt;/strong&gt; 当你按下电源键，主板上的电源管理单元（PSU）向CPU发送一个“Power Good”信号。CPU接收到信号后，开始执行存储在主板上一个ROM芯片（通常是EEPROM或Flash）中的程序。这个程序就是 &lt;strong&gt;BIOS (Basic Input/Output System)&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;POST (Power-On Self-Test - 开机自检)：&lt;/strong&gt; BIOS 首先会运行开机自检程序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;任务：&lt;/strong&gt; 检查计算机最核心的硬件是否工作正常，包括 CPU、内存（RAM）、显卡、键盘等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反馈：&lt;/strong&gt; 如果自检通过，通常会发出一声短促的“嘀”声。如果发现严重故障（如内存没插好），它会通过不同的蜂鸣声组合来报警。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;初始化硬件 (Initialization)：&lt;/strong&gt; BIOS 初始化一些关键的硬件设备，为后续加载操作系统做准备。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;选择引导设备 (Boot Device Selection)：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BIOS会根据预设的启动顺序（Boot Order，可在BIOS设置中修改），依次检查可引导的存储设备，如硬盘、U盘、光驱、网络等。&lt;/li&gt;
&lt;li&gt;它会检查每个设备的&lt;strong&gt;第一个扇区（512字节）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;加载 MBR (Master Boot Record - 主引导记录)：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当BIOS找到一个可引导的硬盘时，它会检查这个硬盘的第一个扇区（也称为0号扇区）的最后两个字节是否为 &lt;code&gt;0x55AA&lt;/code&gt;（称为&lt;strong&gt;引导签名&lt;/strong&gt;）。&lt;/li&gt;
&lt;li&gt;如果签名正确，BIOS就会将这整个512字节的&lt;strong&gt;主引导记录（MBR）&lt;strong&gt;加载到内存的一个固定地址（通常是 &lt;code&gt;0x7C00&lt;/code&gt;）处，然后将CPU的控制权&lt;/strong&gt;转交&lt;/strong&gt;给这段刚刚加载的代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;到此，BIOS的任务彻底完成。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;阶段二mbr-与-bootloader-阶段-硬盘代码执行&#34;&gt;&lt;strong&gt;阶段二：MBR 与 Bootloader 阶段 (硬盘代码执行)&lt;/strong&gt;
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;MBR 执行：&lt;/strong&gt; CPU 开始执行内存中 &lt;code&gt;0x7C00&lt;/code&gt; 地址处的MBR代码。MBR非常小，只有不到446字节的代码空间。它的任务很简单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在MBR内部的分区表中，找到被标记为“&lt;strong&gt;活动&lt;/strong&gt;”的那个分区（只有一个）。&lt;/li&gt;
&lt;li&gt;将该活动分区的&lt;strong&gt;第一个扇区&lt;/strong&gt;——称为**分区引导记录（PBR - Partition Boot Record）**或卷引导记录（VBR）——加载到内存中。&lt;/li&gt;
&lt;li&gt;将CPU控制权转交给这段PBR代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Bootloader 执行：&lt;/strong&gt; PBR中的代码通常是**操作系统加载器（Bootloader）**的第一部分。例如，Windows的 &lt;code&gt;bootmgr&lt;/code&gt; 或 Linux 的 &lt;code&gt;GRUB (GRand Unified Bootloader)&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于一个扇区太小，Bootloader通常会分为多个阶段。第一阶段的代码（在PBR中）非常简单，其唯一任务就是从文件系统中加载Bootloader的后续、更复杂的阶段代码。&lt;/li&gt;
&lt;li&gt;Bootloader的功能要强大得多，它能够识别和解析文件系统（如NTFS, ext4），因为它需要找到并加载操作系统的核心文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;阶段三操作系统内核加载&#34;&gt;&lt;strong&gt;阶段三：操作系统内核加载&lt;/strong&gt;
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;加载内核 (Kernel Loading)：&lt;/strong&gt; Bootloader（如GRUB）会根据其配置文件（如 &lt;code&gt;grub.cfg&lt;/code&gt;）中的指令，找到操作系统内核文件（如Windows的 &lt;code&gt;ntoskrnl.exe&lt;/code&gt; 或Linux的 &lt;code&gt;vmlinuz&lt;/code&gt;）和初始内存盘（&lt;code&gt;initrd.img&lt;/code&gt;）等，并将它们加载到内存中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启动内核 (Kernel Initialization)：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bootloader将CPU控制权最终交给加载到内存中的&lt;strong&gt;操作系统内核&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;内核开始执行，它会：
&lt;ul&gt;
&lt;li&gt;初始化更高级的硬件驱动程序。&lt;/li&gt;
&lt;li&gt;启动核心的系统进程（如Windows的 &lt;code&gt;System&lt;/code&gt;进程，Linux的 &lt;code&gt;systemd&lt;/code&gt;或 &lt;code&gt;init&lt;/code&gt;进程）。&lt;/li&gt;
&lt;li&gt;挂载根文件系统。&lt;/li&gt;
&lt;li&gt;启动用户界面的相关服务，最终显示登录界面或桌面。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;至此，整个引导过程完成。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;2-现代的-uefi-gpt-引导过程&#34;&gt;2. 现代的 UEFI-GPT 引导过程
&lt;/h4&gt;&lt;p&gt;UEFI (Unified Extensible Firmware Interface) 是BIOS的现代替代品，它克服了BIOS的许多限制。GPT (GUID Partition Table) 是MBR的替代分区方案。&lt;/p&gt;
&lt;p&gt;UEFI的引导过程更直接、更灵活、更安全。&lt;/p&gt;
&lt;h5 id=&#34;阶段一uefi-固件执行&#34;&gt;&lt;strong&gt;阶段一：UEFI 固件执行&lt;/strong&gt;
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;上电与 SEC (Security) 阶段：&lt;/strong&gt; 与BIOS类似，系统上电，CPU开始执行UEFI固件代码。首先是安全验证阶段，为后续执行建立一个可信的环境。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;PEI (Pre-EFI Initialization) 阶段：&lt;/strong&gt; 类似于POST，进行核心硬件（CPU、芯片组、内存）的初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DXE (Driver Execution Environment) 阶段：&lt;/strong&gt; 这是UEFI的核心。UEFI固件会加载和执行大量的&lt;strong&gt;UEFI驱动程序&lt;/strong&gt;。这使得UEFI在引导阶段就能识别复杂硬件，并能识别GPT分区表和FAT32等文件系统。&lt;strong&gt;这是UEFI与BIOS最本质的区别&lt;/strong&gt;——BIOS不懂文件系统，而UEFI懂。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BDS (Boot Device Select) 阶段：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UEFI固件会读取存储在&lt;strong&gt;NVRAM&lt;/strong&gt;（一种非易失性RAM）中的启动项配置。&lt;/li&gt;
&lt;li&gt;它不再是盲目地去读设备的第一个扇区。相反，它直接去访问硬盘上一个特殊的、必需的、格式为FAT32的小分区，称为 &lt;strong&gt;EFI系统分区 (ESP - EFI System Partition)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;UEFI会根据启动项配置，在ESP分区中查找并执行指定的&lt;strong&gt;引导加载程序文件&lt;/strong&gt;。这个文件是一个标准的 &lt;code&gt;.efi&lt;/code&gt; 可执行文件，例如 &lt;code&gt;\EFI\Microsoft\Boot\bootmgfw.efi&lt;/code&gt; (Windows) 或 &lt;code&gt;\EFI\ubuntu\shimx64.efi&lt;/code&gt; (Ubuntu)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;阶段二操作系统加载&#34;&gt;&lt;strong&gt;阶段二：操作系统加载&lt;/strong&gt;
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;执行EFI引导程序：&lt;/strong&gt; UEFI固件直接将CPU控制权交给从ESP分区加载的 &lt;code&gt;.efi&lt;/code&gt; 文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加载操作系统：&lt;/strong&gt; 这个 &lt;code&gt;.efi&lt;/code&gt;引导程序（如Windows Boot Manager或GRUB2）接下来负责加载操作系统的内核和相关文件，并将控制权交给内核。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内核初始化：&lt;/strong&gt; 后续步骤与BIOS-MBR方式基本相同，内核接管系统，完成初始化，并启动用户界面。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;bios-mbr-vs-uefi-gpt-对比&#34;&gt;BIOS-MBR vs. UEFI-GPT 对比
&lt;/h4&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;特性&lt;/th&gt;
          &lt;th&gt;BIOS-MBR&lt;/th&gt;
          &lt;th&gt;UEFI-GPT&lt;/th&gt;
          &lt;th&gt;优势&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;分区方案&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;MBR (Master Boot Record)&lt;/td&gt;
          &lt;td&gt;GPT (GUID Partition Table)&lt;/td&gt;
          &lt;td&gt;GPT支持超过2TB的硬盘和最多128个主分区，更可靠。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;引导方式&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;读设备第一个扇区，链式加载&lt;/td&gt;
          &lt;td&gt;直接从ESP分区加载 &lt;code&gt;.efi&lt;/code&gt; 文件&lt;/td&gt;
          &lt;td&gt;UEFI更直接、更快速，因为它认识文件系统，无需链式跳转。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;代码架构&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;16位汇编，实模式&lt;/td&gt;
          &lt;td&gt;32/64位C语言，保护模式&lt;/td&gt;
          &lt;td&gt;UEFI像一个微型操作系统，功能强大，界面友好（支持鼠标）。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;安全性&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;无原生安全机制&lt;/td&gt;
          &lt;td&gt;支持&lt;strong&gt;安全启动 (Secure Boot)&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;Secure Boot可以防止未经签名的恶意引导程序（如Bootkit）加载。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;兼容性&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;兼容性好，但技术老旧&lt;/td&gt;
          &lt;td&gt;现代主流标准，但老旧系统可能不支持&lt;/td&gt;
          &lt;td&gt;UEFI是未来趋势。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;总而言之，计算机的引导过程是一个从固化在硬件中的最简单代码开始，一步步加载更复杂软件，最终将整个庞大的操作系统“唤醒”并交出控制权的接力过程。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0731学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0731/</link>
        <pubDate>Thu, 31 Jul 2025 20:04:32 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0731/</guid>
        <description>&lt;h2 id=&#34;操作系统&#34;&gt;操作系统
&lt;/h2&gt;&lt;h3 id=&#34;设备独立性软件&#34;&gt;设备独立性软件
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;高速缓存与缓冲区&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;磁盘高速缓存&lt;/li&gt;
&lt;li&gt;缓冲区
&lt;ol&gt;
&lt;li&gt;缓冲CPU与I/O设备间速度不匹配的矛盾&lt;/li&gt;
&lt;li&gt;减少对CPU的中断频率，放宽对CPU中断响应时间的限制&lt;/li&gt;
&lt;li&gt;解决基本数据单元大小（数据粒度）不匹配的问题&lt;/li&gt;
&lt;li&gt;提高CPU和IO设备之间的并行性&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;单缓冲&lt;/li&gt;
&lt;li&gt;双缓冲&lt;/li&gt;
&lt;li&gt;循环缓冲&lt;/li&gt;
&lt;li&gt;缓冲池&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设备分配与回收&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设备分配的数据结构
&lt;ol&gt;
&lt;li&gt;设备控制表（DCT）
&lt;ol&gt;
&lt;li&gt;设备控制表&lt;/li&gt;
&lt;li&gt;设备类型&lt;/li&gt;
&lt;li&gt;设备标识符&lt;/li&gt;
&lt;li&gt;设备状态&lt;/li&gt;
&lt;li&gt;指向控制器表的指针&lt;/li&gt;
&lt;li&gt;重复执行次数或时间&lt;/li&gt;
&lt;li&gt;设备队列的队首指针&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;控制器控制表（COCT）&lt;/li&gt;
&lt;li&gt;通道控制表（CHCT）&lt;/li&gt;
&lt;li&gt;系统设备表（SDT）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设备分配时应考虑的因素&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设备的固有属性
&lt;ol&gt;
&lt;li&gt;独占设备&lt;/li&gt;
&lt;li&gt;共享设备&lt;/li&gt;
&lt;li&gt;虚拟设备&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;设备分配算法
&lt;ol&gt;
&lt;li&gt;FCFS&lt;/li&gt;
&lt;li&gt;最高优先级优先算法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;设备分配中的安全性
&lt;ol&gt;
&lt;li&gt;安全分配方式&lt;/li&gt;
&lt;li&gt;不安全分配方式&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;设备分配步骤
&lt;ol&gt;
&lt;li&gt;分配设备&lt;/li&gt;
&lt;li&gt;分配控制器&lt;/li&gt;
&lt;li&gt;分配通道&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SPOOLing （假脱机技术）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入井和输出井&lt;/li&gt;
&lt;li&gt;输入缓冲区和输出缓冲区&lt;/li&gt;
&lt;li&gt;输入进程和输出进程&lt;/li&gt;
&lt;li&gt;井管理程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/npee_learning_log.github.io/posts/0731/SPOOLing.png&#34;
	width=&#34;1531&#34;
	height=&#34;734&#34;
	srcset=&#34;http://localhost:1313/npee_learning_log.github.io/posts/0731/SPOOLing_hu_402004d5932a64c9.png 480w, http://localhost:1313/npee_learning_log.github.io/posts/0731/SPOOLing_hu_3336df8fbee31f45.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;SPOOLing &amp; Buffering&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;208&#34;
		data-flex-basis=&#34;500px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;磁盘和固态硬盘&#34;&gt;磁盘和固态硬盘
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;磁盘&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁头&lt;/li&gt;
&lt;li&gt;磁道&lt;/li&gt;
&lt;li&gt;扇区&lt;/li&gt;
&lt;li&gt;盘块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;磁盘是一种主要的计算机辅助存储设备，它利用磁性记录来存储和检索数字信息。为了有效地组织和访问这些数据，磁盘被划分成多个层级的结构。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;物理结构：硬件层面&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;物理结构是磁盘驱动器本身的硬件构造，决定了数据是如何被物理存储的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;盘片 (Platter)&lt;/strong&gt;
盘片是构成硬盘的核心部件，它是一个或多个坚硬的、通常由铝、玻璃或陶瓷制成的圆形盘片。盘片的双面都涂有磁性材料，用于存储数据。一个硬盘驱动器通常包含多个堆叠在一起的盘片。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主轴 (Spindle)&lt;/strong&gt;
主轴是一个马达，所有的盘片都围绕它以恒定且极高的速度旋转（例如，每分钟7200转）。主轴的稳定性和转速对硬盘的性能至关重要。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;磁头 (Read/Write Head)&lt;/strong&gt;
每个盘片的每个磁性表面都有一个对应的磁头。磁头负责读取盘片上的磁性信息（转换为数据）或向盘片写入磁性信息（存储数据）。在工作时，磁头在一个微小的气垫上“飞行”，与盘片表面保持极近但又不接触的距离。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;磁道 (Track)&lt;/strong&gt;
当盘片旋转时，磁头保持在某个固定位置，就会在盘片上划出一个看不见的同心圆，这个圆形的路径就是&lt;strong&gt;磁道&lt;/strong&gt;。数据就是沿着这些磁道存储的。每个盘面都有数千个磁道。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;柱面 (Cylinder)&lt;/strong&gt;
在一个多盘片的硬盘中，所有盘片上半径相同的磁道共同构成了一个&lt;strong&gt;柱面&lt;/strong&gt;。想象一下，从上到下穿过所有盘片，将所有相同编号的磁道连接起来，就形成了一个空心的圆柱体。当磁头臂不移动时，它可以在同一个柱面上访问所有盘面上的数据，这比移动磁头臂去访问不同磁道要快得多。因此，相关的数据通常会存储在同一个柱面内以提高访问速度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扇区 (Sector)&lt;/strong&gt;
为了进一步管理数据，每个磁道被划分为若干个小的弧段，这些弧段被称为&lt;strong&gt;扇区&lt;/strong&gt;。扇区是磁盘上进行数据读写的最小物理单位，传统上每个扇区的大小为512字节。在进行读写操作时，磁盘控制器一次至少会读取或写入一个扇区的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结一下物理结构的层级关系：
&lt;strong&gt;硬盘驱动器 &amp;gt; 盘片 &amp;gt; 磁道 &amp;gt; 扇区&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;逻辑结构：操作系统层面&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;操作系统为了更方便、更高效地管理磁盘空间，引入了逻辑结构的概念。它在物理结构的基础上进行了抽象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;盘块 (Block) / 块&lt;/strong&gt;
操作系统与磁盘进行I/O操作时，并不会直接以物理扇区为单位。因为如果每次只读写512字节，对于今天的大文件来说效率太低，会产生大量的I/O请求。因此，操作系统将一个或多个连续的扇区组合在一起，形成一个&lt;strong&gt;盘块&lt;/strong&gt;或&lt;strong&gt;块&lt;/strong&gt;。盘块是操作系统进行文件I/O的基本（逻辑）单位。例如，一个盘块可能由8个扇区组成，那么它的大小就是 4KB (8 * 512B)。当程序请求读取文件时，操作系统会一次性读取至少一个盘块的数据到内存中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;簇 (Cluster)&lt;/strong&gt;
簇是文件系统（如FAT32、NTFS）中用于分配磁盘空间的单位。它也是由一个或多个连续的盘块组成的。当你创建一个文件并写入数据时，文件系统会为这个文件分配一个或多个簇。即使一个文件非常小，比如只有1个字节，它也至少会占用一个完整的簇。这就导致了所谓的“空间浪费”，因为簇内未使用的空间无法被其他文件使用。簇的大小会影响磁盘空间的利用率和文件系统的性能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;大簇&lt;/strong&gt;：对于存储大文件的磁盘，使用较大的簇可以减少文件碎片，提高读写性能（因为文件占用的簇是连续的），但会增加小文件的空间浪费。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;小簇&lt;/strong&gt;：可以更有效地利用磁盘空间来存储小文件，但对于大文件，可能会导致其被分割成更多的簇，增加寻址开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;总结与类比&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了更好地理解这些概念，我们可以用一个“图书馆”来类比：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;硬盘驱动器&lt;/strong&gt; 就像整个 &lt;strong&gt;图书馆大楼&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;盘片&lt;/strong&gt; 就像楼里的 &lt;strong&gt;某一层&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;磁道&lt;/strong&gt; 就像这一层书架上的 &lt;strong&gt;一排书架&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扇区&lt;/strong&gt; 就像书架上的 &lt;strong&gt;一本书&lt;/strong&gt;（这是最小的物理单位）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;盘块 (Block)&lt;/strong&gt; 就像图书馆规定，你借书时不能只借一本，必须借走 &lt;strong&gt;一摞书&lt;/strong&gt;（比如5本）。这是操作系统I/O的最小单位。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;簇 (Cluster)&lt;/strong&gt; 就像图书管理员为了方便管理，把书架划分成很多个 &lt;strong&gt;隔间&lt;/strong&gt;，每个隔间放一摞或多摞书。当你要存放你的资料时，管理员会给你分配一个或多个隔间。这是文件分配的最小单位。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这种分层结构，磁盘既能通过物理设计实现高密度存储，又能通过操作系统和文件系统的逻辑抽象，实现对数据高效、便捷的管理和访问。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;磁盘的管理&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;磁盘的初始化&lt;/p&gt;
&lt;p&gt;低级格式化（物理格式化）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分区&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;磁盘分区&lt;/li&gt;
&lt;li&gt;逻辑格式化（高级格式化）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引导块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;坏块&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;磁盘调度算法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;磁盘的存取时间&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;寻道时间$T_S$：寻道时间是指将磁头臂（Read/Write Head）从当前所在的磁道移动到目标数据所在的磁道所需要的时间。这个时间除跨越$n$条磁道的时间外，还包括启动磁头臂的时间$s$&lt;/p&gt;
$$
            T_s = m\times n+ s
            $$&lt;p&gt;其中$m$是与磁盘驱动器速度有关的常熟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;旋转延迟时间$T_r$。当磁头已经成功定位到目标磁道后，等待盘片旋转，直到目标数据的起始扇区（Sector）转到磁头正下方所需要的时间。设磁盘的旋转速度为$r$&lt;/p&gt;
$$
            T_r = \frac{1}{2r}
            $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传输时间$T_t$。当目标扇区已经到达磁头下方后，实际从盘片上读取数据或向盘片写入数据所花费的时间。这个时间取决于每次所读/写的字节数$b$和磁盘的旋转速度$r$&lt;/p&gt;
$$
            T_t = \frac{b}{rN}
            $$&lt;p&gt;式中，$r$为磁盘每秒的转数，$N$为一个磁道上的字节数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;磁盘调度算法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先来先服务算法：这是最简单的调度算法。它完全按照请求到达队列的先后顺序来处理请求。不考虑磁头当前的位置和请求磁道的远近。&lt;/li&gt;
&lt;li&gt;最短寻道时间优先(SSTF)：SSTF算法选择与磁头当前位置最近的那个请求作为下一个服务对象。这是一种贪心算法，其目标是每次都执行寻道成本最小的操作。&lt;/li&gt;
&lt;li&gt;扫描算法(SCAN)：SCAN算法模仿了电梯的运行方式。磁头在一个方向上移动，沿途服务所有该方向上的请求，直到到达磁盘的最后一个磁道，然后调转方向，继续服务反向的请求。&lt;/li&gt;
&lt;li&gt;循环扫描(C-SCAN)：C-SCAN是SCAN算法的改进版，旨在解决SCAN算法对两端磁道不公平的问题。它规定磁头只在一个方向上扫描并服务请求（例如从0到199）。当到达一端后，它会立即返回到起始端，然后重新开始下一次扫描，返回途中不服务任何请求。
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;算法名称&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;优点 (Advantages)&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;缺点 (Disadvantages)&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;先来先服务 (FCFS)&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;绝对公平&lt;/strong&gt;：所有请求按到达顺序处理，不会有请求被无限期推迟（无饥饿现象）。&lt;strong&gt;实现简单&lt;/strong&gt;：算法逻辑是所有调度算法中最简单的。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;效率低下&lt;/strong&gt;：磁头移动路径完全随机，平均寻道时间很长，导致磁盘整体性能差。`&lt;strong&gt;性能不稳定&lt;/strong&gt;：性能好坏完全取决于请求序列。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;最短寻道时间优先 (SSTF)&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;性能好&lt;/strong&gt;：平均寻道时间显著短于FCFS，系统吞吐量高。&lt;strong&gt;效率高&lt;/strong&gt;：总是选择代价最小的移动，局部性能最优。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;可能产生“饥饿”现象&lt;/strong&gt;：如果新请求总是在磁头当前位置附近产生，那么远离磁头的请求可能会长时间得不到服务。&lt;strong&gt;响应时间不均&lt;/strong&gt;：对不同位置请求的响应机会不均等。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;扫描算法 (SCAN) / 电梯算法&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;性能较好&lt;/strong&gt;：是SSTF和FCFS的一种折中，兼顾了性能和公平性。&lt;strong&gt;无饥饿问题&lt;/strong&gt;：磁头会规律地来回移动，确保所有位置的请求最终都能被处理。``&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;对两端磁道不公平&lt;/strong&gt;：位于磁盘中间区域的磁道比两端磁道的服务频率更高，响应更快。&lt;strong&gt;等待时间不均&lt;/strong&gt;：磁头刚经过的位置需要等待近一个来回周期才能再次被服务。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;循环扫描 (C-SCAN)&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;等待时间更均匀&lt;/strong&gt;：通过单向服务和快速返回，使得所有请求的等待时间更加公平和可预测。&lt;strong&gt;解决了SCAN的不公平问题&lt;/strong&gt;：对所有磁道位置的请求都一视同仁，响应时间方差小。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;额外的寻道开销&lt;/strong&gt;：磁头每次扫描到末端后，都需要一次长距离的“空载”返回（从一端直接跳到另一端），这部分移动不处理任何请求，增加了总的寻道距离。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;减少延迟时间的方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;盘面扇区的交替编号&lt;/li&gt;
&lt;li&gt;磁盘盘面的错位命名&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提高磁盘IO速度的方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;采用磁盘高速缓存&lt;/li&gt;
&lt;li&gt;调整磁盘请求顺序&lt;/li&gt;
&lt;li&gt;提前读&lt;/li&gt;
&lt;li&gt;延迟写&lt;/li&gt;
&lt;li&gt;优化物理块的分布&lt;/li&gt;
&lt;li&gt;虚拟盘&lt;/li&gt;
&lt;li&gt;采用磁盘阵列RAID&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;固态硬盘&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;固态硬盘的特性&lt;/li&gt;
&lt;li&gt;磨损均衡
&lt;ol&gt;
&lt;li&gt;动态磨损均衡&lt;/li&gt;
&lt;li&gt;静态磨损均衡&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0730学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0730/</link>
        <pubDate>Wed, 30 Jul 2025 22:23:38 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0730/</guid>
        <description>&lt;h2 id=&#34;操作系统-io&#34;&gt;操作系统-I/O
&lt;/h2&gt;&lt;h3 id=&#34;文件系统&#34;&gt;文件系统
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;文件系统（自底向上）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;I/O控制层&lt;/li&gt;
&lt;li&gt;基本文件系统&lt;/li&gt;
&lt;li&gt;文件组织模块&lt;/li&gt;
&lt;li&gt;逻辑文件系统&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件系统布局&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件系统在磁盘中的结构
&lt;ol&gt;
&lt;li&gt;主引导记录&lt;/li&gt;
&lt;li&gt;引导块&lt;/li&gt;
&lt;li&gt;超级块&lt;/li&gt;
&lt;li&gt;文件系统中空闲块的信息&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;文件系统在内存中的结构
&lt;ol&gt;
&lt;li&gt;内存中的安装表（mount table）&lt;/li&gt;
&lt;li&gt;内存中的目录结构的缓存&lt;/li&gt;
&lt;li&gt;整个系统的打开文件表&lt;/li&gt;
&lt;li&gt;每个进程的打开文件表，包含进程打开文件的文件描述符&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;虚拟文件系统VFS
&lt;ol&gt;
&lt;li&gt;超级块对象&lt;/li&gt;
&lt;li&gt;索引节点对象&lt;/li&gt;
&lt;li&gt;目录项对象&lt;/li&gt;
&lt;li&gt;文件对象&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;文件系统挂载&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;io&#34;&gt;I/O
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;I/O设备&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;信息交换单位分类
&lt;ol&gt;
&lt;li&gt;块设备&lt;/li&gt;
&lt;li&gt;字符设备&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;传输速率分类
&lt;ol&gt;
&lt;li&gt;低速设备&lt;/li&gt;
&lt;li&gt;中速设备&lt;/li&gt;
&lt;li&gt;高速设备&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;使用特性
&lt;ol&gt;
&lt;li&gt;存储设备&lt;/li&gt;
&lt;li&gt;输入/输出设备&lt;/li&gt;
&lt;li&gt;共享属性
&lt;ol&gt;
&lt;li&gt;独占设备&lt;/li&gt;
&lt;li&gt;共享设备&lt;/li&gt;
&lt;li&gt;虚拟设备&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I/O接口&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设备控制器与CPU的接口&lt;/li&gt;
&lt;li&gt;设备控制器与设备的接口&lt;/li&gt;
&lt;li&gt;I/O逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据传送方式：并行接口、串行接口&lt;/li&gt;
&lt;li&gt;主机访问I/O设备的控制方式：程序查询接口、终端接口、DMA接口&lt;/li&gt;
&lt;li&gt;功能选择的灵活性：可编程接口、不可编程接口&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;端口：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据寄存器&lt;/li&gt;
&lt;li&gt;状态寄存器&lt;/li&gt;
&lt;li&gt;控制寄存器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I/O端口编址方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;独立编址&lt;/li&gt;
&lt;li&gt;统一编址&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I/O控制方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;程序直接控制方式&lt;/li&gt;
&lt;li&gt;中断驱动方式&lt;/li&gt;
&lt;li&gt;DMA方式（重要）&lt;/li&gt;
&lt;li&gt;通道控制方式&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I/O软件层次结构&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户层软件&lt;/li&gt;
&lt;li&gt;设备独立性软件&lt;/li&gt;
&lt;li&gt;设备驱动软件&lt;/li&gt;
&lt;li&gt;中断处理软件&lt;/li&gt;
&lt;li&gt;硬件（非软件层次）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数学-极值点拐点&#34;&gt;数学-极值点？拐点？
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;极值的定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单调性与极值的判别&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单调性的判别&lt;/li&gt;
&lt;li&gt;判别极值的第一充分条件&lt;/li&gt;
&lt;li&gt;判别极值的第二充分条件&lt;/li&gt;
&lt;li&gt;判别极值的第三充分条件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;凹凸性与拐点的概念&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;凹凸性的定义&lt;/li&gt;
&lt;li&gt;拐点的定义&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;凹凸性与拐点的判别&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判别凹凸性&lt;/li&gt;
&lt;li&gt;判别拐点的第一充分条件&lt;/li&gt;
&lt;li&gt;判别拐点的第二充分条件&lt;/li&gt;
&lt;li&gt;判别拐点的第三充分条件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;渐近线&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;铅直渐近线&lt;/li&gt;
&lt;li&gt;水平渐近线&lt;/li&gt;
&lt;li&gt;斜渐近线&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最值或取值范围&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最值的定义&lt;/li&gt;
&lt;li&gt;求区间[a,b]上的连续函数f(x)的最大值和最小值&lt;/li&gt;
&lt;li&gt;求区间(a,b )上的连续函数f(x)的最值或取值范围&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作函数图像&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一般步骤
&lt;ol&gt;
&lt;li&gt;确定定义域、奇偶性、周期性等&lt;/li&gt;
&lt;li&gt;用导数工具确定函数的单调区间、极值点、凹凸区间、拐点&lt;/li&gt;
&lt;li&gt;考查渐近线&lt;/li&gt;
&lt;li&gt;作出函数图像&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;曲率及曲率半径（证明放在下一期笔记中）
&lt;/p&gt;
$$
   \begin{align*}
   k &amp;= \dfrac{|y&#39;&#39;|}{{[1+{(y&#39;)}^2]}^{\frac{3}{2}}}\\
   r &amp;= \frac{1}{k} = \dfrac{{[1+{(y&#39;)}^2]}^{\frac{3}{2}}}{|y&#39;&#39;|},{y}&#39;&#39;\neq0
   \end{align*}
   $$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号:第5讲&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0729学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0729/</link>
        <pubDate>Tue, 29 Jul 2025 23:17:02 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0729/</guid>
        <description>&lt;h2 id=&#34;操作系统-mkdir&#34;&gt;操作系统-mkdir
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;文件的物理结构
&lt;ol&gt;
&lt;li&gt;连续分配&lt;/li&gt;
&lt;li&gt;链接分配
&lt;ul&gt;
&lt;li&gt;隐式链接&lt;/li&gt;
&lt;li&gt;显式链接(FAT,file allocation table)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;索引分配
&lt;ol&gt;
&lt;li&gt;单级索引分配&lt;/li&gt;
&lt;li&gt;多级索引分配&lt;/li&gt;
&lt;li&gt;混合索引分配&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;磁盘的管理和组织
&lt;ol&gt;
&lt;li&gt;磁盘结构
&lt;ul&gt;
&lt;li&gt;surface&lt;/li&gt;
&lt;li&gt;track&lt;/li&gt;
&lt;li&gt;gap&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;磁盘访问时间&lt;/li&gt;
&lt;li&gt;文件存储空间管理
&lt;ol&gt;
&lt;li&gt;空闲表法&lt;/li&gt;
&lt;li&gt;空闲链表法
&lt;ol&gt;
&lt;li&gt;空闲盘块链&lt;/li&gt;
&lt;li&gt;空闲盘区链&lt;/li&gt;
&lt;li&gt;位示图&lt;/li&gt;
&lt;li&gt;成组链表法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;磁盘格式化
&lt;ol&gt;
&lt;li&gt;低级格式化&lt;/li&gt;
&lt;li&gt;高级格式化&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;附系统调用openreadclose使用代码示例&#34;&gt;附：系统调用&lt;code&gt;open(),read(),close()使用代码示例&lt;/code&gt;
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;time.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdbool.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define MAX_BUFFER_SIZE 128
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;do_the_same_thing&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;filename, &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; sleep_enabled);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;argv[])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; sleep_enabled &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; false;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Open a file in read-only mode
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (argc &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;fprintf&lt;/span&gt;(stderr, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Usage: %s &amp;lt;filename&amp;gt; --sleep&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (argc &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;strcmp&lt;/span&gt;(argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;], &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;--sleep&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sleep_enabled &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; true;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;filename &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;pid_t&lt;/span&gt; pid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fork&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// Get the current process ID
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (pid &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;perror&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Failed to fork&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;  (pid &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// Child process
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;do_the_same_thing&lt;/span&gt;(filename, sleep_enabled);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;exit&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (pid &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;do_the_same_thing&lt;/span&gt;(filename, sleep_enabled);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;perror&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Failed to fork&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;do_the_same_thing&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;filename,&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; sleep_enabled)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; fd &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;open&lt;/span&gt;(filename, O_RDONLY); &lt;span style=&#34;color:#75715e&#34;&gt;// O_RDONLY means read-only
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (fd &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;perror&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Failed to open file&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ... use fd ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;ssize_t&lt;/span&gt; bytes_read;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; buffer[MAX_BUFFER_SIZE];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        bytes_read &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;read&lt;/span&gt;(fd, buffer, MAX_BUFFER_SIZE &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// Read up to MAX_BUFFER_SIZE - 1 bytes
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (bytes_read &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// Exit loop on error or EOF
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        buffer[bytes_read] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// Null-terminate the string
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, buffer);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (sleep_enabled)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// Sleep for 1 second to simulate processing time
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;(fd);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// This function is intentionally left empty.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// It serves as a placeholder to demonstrate that the code can be extended.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;课程编号:25-28&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0727学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0727/</link>
        <pubDate>Sun, 27 Jul 2025 18:55:08 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0727/</guid>
        <description>&lt;h2 id=&#34;数学-一元函数微分学&#34;&gt;数学-一元函数微分学
&lt;/h2&gt;&lt;h3 id=&#34;一元函数微分学的概念&#34;&gt;一元函数微分学的概念
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;导数&lt;/p&gt;
$$
   f&#39;(x_0) = \lim\limits_{x\to x_0}\frac{\Delta y}{\Delta x} = \lim\limits_{\Delta x\to 0}\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;导数的几何意义&lt;/p&gt;
$$
   \begin{align*}
   	\text{切线方程：}y-y_0&amp;=f&#39;(x_0)(x-x_0) \\
   	\text{法线方程：}y-y_0&amp;=-\frac{1}{f&#39;(x_0)}(x-x_0),(f&#39;(x_0)\neq0)
   \end{align*}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高阶导数&lt;/p&gt;
$$
   f^{(n)}(x_0) = \lim\limits_{\Delta x\to x_0}\frac{f^{(n-1)}(x)-f^{(n-1)}(x_0)}{x-x_0}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微分概念&lt;/p&gt;
&lt;p&gt;设函数$y=f(x)$在点$x_0$的某邻域内有定义，且$x_0+\Delta x$在该邻域内，对于函数增量&lt;/p&gt;
$$
   \Delta y = f(x_0+\Delta x)- f(x_0)
   $$&lt;p&gt;若存在与$\Delta x$无关的常数$A$，使得&lt;/p&gt;
$$
   \Delta y = A\Delta x + o(\Delta x)
   $$&lt;p&gt;则称$f(x)$在$x=x_0$处可微，且$A\Delta x$为线性主部也叫做$f(x) $在点$x_0$处的微分，记为&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
$$
\left.dy\right|_{x=x_0}A\Delta x = f&#39;(x_0)\mathbf{d}x
$$&lt;h3 id=&#34;一元函数微分学的计算&#34;&gt;一元函数微分学的计算
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本求导公式&lt;/p&gt;
$$
   \begin{align*}
   	\left(x^{\alpha}\right)&#39; &amp;= \alpha x^{\alpha-1}\\
   	\left(a^x\right)&#39; &amp;= a^x\ln{a},(a&gt;0,a\neq 1)\\
   	\left(e^x\right)&#39; &amp;=e^x\\
   		\left(\log_ax\right)&#39; &amp;=\frac{1}{x\ln a},(a&gt;0,a\neq 1)\\
   	\left(\ln|x|\right)&#39; &amp;=\frac{1}{x}\\
   	\left(\sin x \right)&#39; &amp;=\cos x \\
   	\left(\cos x\right)&#39; &amp;=-\sin x \\
   	\left(\arcsin x\right)&#39; &amp;=\frac{1}{\sqrt{1-x^2}}\\
   	\left(\arccos x\right)&#39; &amp;=-\frac{1}{\sqrt{1-x^2}}\\
   	\left(\tan x\right)&#39; &amp;=\sec^2 x\\
   	\left(\cot x \right)&#39; &amp;=-\csc^2 x\\
   	\left(\arctan x\right)&#39; &amp;=\frac{1}{1+x^2}\\
   	\left(\text{arccot} x\right)&#39; &amp;=-\frac{1}{1+x^2}\\
   	\left(\sec x\right)&#39; &amp;=\sec x\tan x\\
   	\left(\csc x\right)&#39; &amp;=-\csc x \cot x\\
   	\left(\ln(x+\sqrt{x^2+1})\right)&#39; &amp;=\frac{1}{x^2+1}\\
   	\left(\ln(x+\sqrt{x^2-1})\right)&#39; &amp;=\frac{1}{x^2-1}\\
   \end{align*}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;四则运算&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;和差&lt;/li&gt;
&lt;li&gt;积&lt;/li&gt;
&lt;li&gt;商&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复合函数的导数与微分形式的不变性&lt;/p&gt;
$$
   \mathbf{d}f(u)=f&#39;(u)\mathbf{d}u
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分段函数的导数&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在分段点使用导数的定义&lt;/li&gt;
&lt;li&gt;在非分段点使用导数公式&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反函数的导数&lt;/p&gt;
&lt;p&gt;设$y=f(x)$单调、可导函数，且$f&amp;rsquo;(x)\neq 0$,则存在反函数$x=\varphi(y)$，且$\frac{dx}{dy} = \frac{1}{\frac{dy}{dx}}$&lt;/p&gt;
$$
   \varphi&#39;(x) =\dfrac{1}{ \dfrac{\mathbf{d} arc\varphi(\varphi(x)) }{\mathbf{d}\varphi(x)}}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隐函数求导法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数方程所确定的函数的导数&lt;/p&gt;
$$
   \begin{align}
   \begin{cases}
   x&amp;= \varphi(t)\\
   y&amp;= \omega(t)\\
   \end{cases}\\
   \frac{dy}{dx} = \dfrac{\frac{dy}{dt}}{\frac{dx}{dt}} = \dfrac{\omega&#39;(t)}{\varphi&#39;(t)}
   \end{align}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对数求导法
&lt;/p&gt;
$$
   \begin{align*}
   \ln y &amp;= \ln f(x)\\
   y&#39; &amp;= \frac{yf&#39;(x)}{f(x)}\\
   \end{align*}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;幂指数求导法
&lt;/p&gt;
$$
   u(x)^{v(x)} = e^{v(x)\ln u(x)}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高阶导数&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;归纳法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;莱布尼茨公式
&lt;/p&gt;
$$
       \begin{align*}
       (u\pm v)^{(n)}&amp;= u^{(n)}\pm v^{(n)}\\
       (u v)^{(n)}&amp;= \sum\limits_{k=0}^{n}C_{n}^{k}u^{(k)}v^{(n-k)}
       \end{align*}
       $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;泰勒展开式，利用展开唯一性&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号：第三、四讲&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0723学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0723/</link>
        <pubDate>Wed, 23 Jul 2025 23:53:15 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0723/</guid>
        <description>&lt;h2 id=&#34;数学-1000题&#34;&gt;数学-1000题
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;对于$x_{n+1}=f(x_n)$的数列极限的判定的过程
&lt;ol&gt;
&lt;li&gt;单调有界&lt;/li&gt;
&lt;li&gt;拉格朗日中值定理&lt;/li&gt;
&lt;li&gt;放缩&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;对于行列式的计算的方法
&lt;ol&gt;
&lt;li&gt;上下三角行列式&lt;/li&gt;
&lt;li&gt;反三角行列式&lt;/li&gt;
&lt;li&gt;范德蒙德行列式&lt;/li&gt;
&lt;li&gt;递推&lt;/li&gt;
&lt;li&gt;归纳&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;英语-不背单词&#34;&gt;英语-不背单词
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;twist&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ultimate&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;strike&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;crucial&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;subordinate&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;anguish&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;subtle&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;constitute&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;suffice&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;eminent&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;prudent&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;courtesy&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;harsh&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;indispensable&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0722学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0722/</link>
        <pubDate>Tue, 22 Jul 2025 23:31:50 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0722/</guid>
        <description>&lt;h2 id=&#34;操作系统--la-pa-ca&#34;&gt;操作系统- (LA-PA-CA)
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;带快表的两级系统的地址翻译过程
&lt;ol&gt;
&lt;li&gt;从逻辑地址映射到物理地址（虚拟存储器）&lt;/li&gt;
&lt;li&gt;从物理地址映射到Cache地址（主存-Cache系统）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;文件和文件系统
&lt;ol&gt;
&lt;li&gt;构成文件的基本单位&lt;/li&gt;
&lt;li&gt;文件的定义&lt;/li&gt;
&lt;li&gt;文件属性&lt;/li&gt;
&lt;li&gt;文件的基本操作&lt;/li&gt;
&lt;li&gt;文件的打开和关闭的操作&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;文件的逻辑结构&lt;/li&gt;
&lt;li&gt;目录管理
&lt;ol&gt;
&lt;li&gt;目录的概念&lt;/li&gt;
&lt;li&gt;文件控制块和索引节点&lt;/li&gt;
&lt;li&gt;目录结构&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;英语-vocabularybuilder&#34;&gt;英语-VocabularyBuilder
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;CRIM,comes from the Latin words for &amp;ldquo;fault or crime&amp;rdquo; or &amp;ldquo;accusation.&amp;rdquo;
&lt;ol&gt;
&lt;li&gt;criminology&lt;/li&gt;
&lt;li&gt;decriminalize&lt;/li&gt;
&lt;li&gt;incriminate&lt;/li&gt;
&lt;li&gt;recrimination&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;PROB,comes from the Latin words for  &amp;ldquo;prove or proof &amp;ldquo;and &amp;ldquo;honesy or integrity.&amp;rdquo;
&lt;ol&gt;
&lt;li&gt;approbation&lt;/li&gt;
&lt;li&gt;probate&lt;/li&gt;
&lt;li&gt;probity&lt;/li&gt;
&lt;li&gt;reprobate&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;GRAV, comes from the Latin word meaning &amp;ldquo;heavy ,weighty ,serious&amp;rdquo;
&lt;ol&gt;
&lt;li&gt;grave&lt;/li&gt;
&lt;li&gt;gravitas&lt;/li&gt;
&lt;li&gt;gravitate&lt;/li&gt;
&lt;li&gt;aggravate&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;LEV,comes from the Latin adjective $levis$,meaning &amp;ldquo;light&amp;rdquo;,and the verb $levare$,meaning &amp;ldquo;to raise or lighten.&amp;rdquo;
&lt;ol&gt;
&lt;li&gt;alleviate&lt;/li&gt;
&lt;li&gt;elevation&lt;/li&gt;
&lt;li&gt;contilever&lt;/li&gt;
&lt;li&gt;levity&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数学-行列式&#34;&gt;数学-行列式
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;行列式的本质定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行列式的性质&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h6 id=&#34;aat&#34;&gt;$|A|=|A^T|$
&lt;/h6&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若行列式中某行(列)元素全为零，则行列式为零&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若行列式中某行(列) 元素有公因子$k\neq0$，则$k$可提到行列式外面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行列式中某行(列)元素均是两个数之和，则可拆成两个行列式之和&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行列式中两行(列)互换，行列式变号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行列式中的两行(列)元素相等或对应成比例，则行列式为零&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行列式的逆序法定义
&lt;/p&gt;
$$
   \begin{vmatrix}
   a_{11} &amp; a_{12} &amp; \cdots&amp;a_{1n}\\
   a_{21} &amp; a_{22} &amp; \cdots&amp;a_{2n}\\
   \vdots &amp; \vdots &amp; &amp;\vdots\\
   a_{n1} &amp; a_{n2} &amp; \cdots&amp;a_{nn}\\
   \end{vmatrix}=\sum\limits_{j_1j_2\cdots j_n}{(-1)^{\tau(j_1j_2\cdots j_n)}}a_{j_1}a_{j_2}\cdots a_{j_n}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行列式的展开定理
&lt;/p&gt;
$$
   |A| = \sum\limits_{j=1}^na_{ij}A_{ij}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;几个重要的行列式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;主对角线行列式(上(下)三角形行列式)
&lt;/p&gt;
$$
      \begin{vmatrix}
      a_{11} &amp; a_{12} &amp; \cdots&amp;a_{1n}\\
      0 &amp; a_{22} &amp; \cdots&amp;a_{2n}\\
      \vdots &amp; \vdots &amp; &amp;\vdots\\
      0 &amp; 0 &amp; \cdots&amp;a_{nn}\\
      \end{vmatrix}=\begin{vmatrix}
      a_{11} &amp; 0 &amp; \cdots&amp;0\\
      a_{21} &amp; a_{22} &amp; \cdots&amp;0\\
      \vdots &amp; \vdots &amp; &amp;\vdots\\
      a_{n1} &amp; a_{n2} &amp; \cdots&amp;a_{nn}\\
      \end{vmatrix}=\begin{vmatrix}
      a_{11} &amp; 0 &amp; \cdots&amp;0\\
      0 &amp; a_{22} &amp; \cdots&amp;0\\
      \vdots &amp; \vdots &amp; &amp;\vdots\\
      0 &amp; 0 &amp; \cdots&amp;a_{nn}\\
      \end{vmatrix}=\prod\limits_{i=1}^n a_{ii}
      $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;副对角线行列式
&lt;/p&gt;
$$
      \begin{vmatrix}
      a_{11} &amp; \cdots &amp; a_{1,n-1}&amp;a_{1n}\\
      a_{21} &amp; \cdots &amp; a_{2,n-1}&amp;0\\
      \vdots &amp;  &amp;\vdots &amp;\vdots\\
      a_{n1} &amp;\cdots&amp;0 &amp;0\\
      \end{vmatrix}=\begin{vmatrix}
      0 &amp; \cdots &amp; 0&amp;a_{1n}\\
      0 &amp;\cdots &amp; a_{2,n-1}&amp;a_{2n}\\
      \vdots &amp; &amp; \vdots &amp;\vdots\\
      a_{n1} &amp;\cdots &amp; a_{n,n-1}&amp;a_{nn}\\
      \end{vmatrix}=\begin{vmatrix}
      0 &amp; \cdots &amp; 0&amp;a_{1n}\\
      0 &amp; \cdots &amp; a_{2,n-1}&amp;0\\
      \vdots &amp; &amp;  \vdots&amp;\vdots\\
      a_{n1} &amp; \cdots &amp; 0&amp;0\\
      \end{vmatrix}=(-1)^{\frac{n(n-1)}{2}}\prod\limits_{i=1}^n a_{i(n+1-i)}
      $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拉普拉斯展开式($A\in R^{m\times m},B\in R^{n\times n}$)
&lt;/p&gt;
$$
      \begin{vmatrix}
      A&amp;O\\
      O&amp;B
      \end{vmatrix}=\begin{vmatrix}
      A&amp;C\\
      O&amp;B
      \end{vmatrix}=\begin{vmatrix}
      A&amp;O\\
      C&amp;B
      \end{vmatrix}=|A||B|
      $$$$
      \begin{vmatrix}
      O&amp;A\\
      B&amp;O
      \end{vmatrix}=\begin{vmatrix}
      C&amp;A\\
      B&amp;O
      \end{vmatrix}=\begin{vmatrix}
      O&amp;A\\
      B&amp;C
      \end{vmatrix}=(-1)^{mn}|A||B|
      $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;范德蒙德行列式,$(1\leq i &amp;lt;j\leq n)$
&lt;/p&gt;
$$
      \begin{vmatrix}
      1&amp;1&amp;\cdots&amp;1\\
      x_1&amp;x_2&amp;\cdots&amp;x_n\\
      x_1^2&amp;x_2^2&amp;\cdots&amp;x_n^2\\
      \vdots&amp;\vdots&amp;&amp;\vdots\\
      x_1^n&amp;x_2^n&amp;\cdots&amp;x_n^n
      \end{vmatrix}=\prod\limits_{i,j}{(x_i-x_j)}
      $$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0721学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0721/</link>
        <pubDate>Mon, 21 Jul 2025 17:53:02 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0721/</guid>
        <description>&lt;h2 id=&#34;英语-vocabulary-builder&#34;&gt;英语-vocabulary builder
&lt;/h2&gt;&lt;p&gt;使用 &lt;code&gt;The Merriam-Webster Vocabulary Builder&lt;/code&gt;作为词根法扩充词汇量的工具书(由网友canon提供)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BENE , latin for &lt;code&gt;well&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;benediction&lt;/li&gt;
&lt;li&gt;benefactor&lt;/li&gt;
&lt;li&gt;benefaciary&lt;/li&gt;
&lt;li&gt;benevolence&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AM, comes form the latin &lt;code&gt;admare&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;amicable&lt;/li&gt;
&lt;li&gt;enamored&lt;/li&gt;
&lt;li&gt;amorous&lt;/li&gt;
&lt;li&gt;paramour&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BELL,comes from the latin word meaning &lt;code&gt;war&lt;/code&gt;.Bellona was the little-known goddess of war .
&lt;ul&gt;
&lt;li&gt;antebellum&lt;/li&gt;
&lt;li&gt;belligerence&lt;/li&gt;
&lt;li&gt;bellicose&lt;/li&gt;
&lt;li&gt;rebellion&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PAC,is related to the Latin words for &amp;ldquo;agree&amp;rdquo; and &amp;ldquo;peace&amp;rdquo;
&lt;ul&gt;
&lt;li&gt;pacify&lt;/li&gt;
&lt;li&gt;pacifist&lt;/li&gt;
&lt;li&gt;pact&lt;/li&gt;
&lt;li&gt;pace&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;操作系统-page--segment&#34;&gt;操作系统-page &amp;amp; segment
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本分页内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;page&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;page frame&lt;/li&gt;
&lt;li&gt;page table&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;页号&lt;/th&gt;
          &lt;th&gt;页内偏移量&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;虚拟地址 = 页号 + 页内偏移&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;LRU（最近最少使用）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FIFO（先进先出）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CLOCK（近似LRU）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TLB（Translation Lookaside Buffer）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两级以及多级页表&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本分段内存管理&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本结构&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;段号&lt;/th&gt;
          &lt;th&gt;段内地址&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;段表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地址变换机制&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚拟存储器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页表机制&lt;/li&gt;
&lt;li&gt;缺页中断机制&lt;/li&gt;
&lt;li&gt;地址变换机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号：019-021&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;数据结构-二叉树&#34;&gt;数据结构-二叉树
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;线索二叉树&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;li&gt;构造&lt;/li&gt;
&lt;li&gt;遍历&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;树、森林与二叉树&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;相互转换&lt;/li&gt;
&lt;li&gt;遍历&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哈夫曼树&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;WPL&lt;/li&gt;
&lt;li&gt;构造&lt;/li&gt;
&lt;li&gt;哈夫曼编码&lt;/li&gt;
&lt;li&gt;哈夫曼树的特点&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并查集&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;li&gt;操作&lt;/li&gt;
&lt;li&gt;实现&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号：033-037&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0719学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0719/</link>
        <pubDate>Sat, 19 Jul 2025 22:41:19 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0719/</guid>
        <description>&lt;h2 id=&#34;数学-是不动点的味道&#34;&gt;数学-是不动点的味道
&lt;/h2&gt;&lt;h3 id=&#34;数列的极限&#34;&gt;数列的极限
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;概念&lt;/li&gt;
&lt;li&gt;数列极限的定义&lt;/li&gt;
&lt;li&gt;数列收敛的性质
&lt;ul&gt;
&lt;li&gt;唯一性&lt;/li&gt;
&lt;li&gt;有界性&lt;/li&gt;
&lt;li&gt;保号性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;海涅定理（归结原则）&lt;/li&gt;
&lt;li&gt;夹逼准则&lt;/li&gt;
&lt;li&gt;单调有界准则&lt;/li&gt;
&lt;li&gt;${x_n}$收敛于$a$的速度问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据结构-前序中序后序blablabla&#34;&gt;数据结构-前序中序后序blablabla
&lt;/h2&gt;&lt;h3 id=&#34;树的性质&#34;&gt;树的性质
&lt;/h3&gt;&lt;p&gt;let $T_m$ denote a tree with degree $m$.&lt;/p&gt;
&lt;p&gt;let $D(n)$ denote the out degree of the node $x$ in the tree $T_m$.&lt;/p&gt;
&lt;p&gt;let $n_i$ denote the number of notes with degree $i$.&lt;/p&gt;
&lt;p&gt;let $H$ denote the depth/height of the tree $T_m$.&lt;/p&gt;
&lt;p&gt;let $N$ denote the total number of nodes in tree.$N=\sum\limits_{i=0}^mn_i$.&lt;/p&gt;
&lt;p&gt;let $N_i$ denote the number of nodes at layer $i\in \mathcal{N^*}$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$N=1 + \sum\limits_{i=1}^mi\cdot n_i$.&lt;/li&gt;
&lt;li&gt;$n_0 =1 + \sum\limits_{i=2}^m(i-1)\cdot n_i$&lt;/li&gt;
&lt;li&gt;$N_i\leq m^{i-1}$ if not an &lt;strong&gt;empty tree&lt;/strong&gt; with degree m.&lt;/li&gt;
&lt;li&gt;$N\leq \frac{m^H-1}{m-1}$&lt;/li&gt;
&lt;li&gt;$H\geq \lceil\log_{m}\left((N(m-1))+1\right)\rceil$&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二叉树&#34;&gt;二叉树
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;二叉树的性质
&lt;ol&gt;
&lt;li&gt;$N_i\leq 2^{i-1}$ if not an &lt;strong&gt;empty tree&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;$N\leq 2^H-1$&lt;/li&gt;
&lt;li&gt;$n_0 =1 + n_2$&lt;/li&gt;
&lt;li&gt;$H\geq \lceil\log_{2}(N+1)\rceil$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;完全二叉树&lt;/li&gt;
&lt;li&gt;满二叉树&lt;/li&gt;
&lt;li&gt;二叉树的构造
&lt;ol&gt;
&lt;li&gt;前序加中序&lt;/li&gt;
&lt;li&gt;后序加中序&lt;/li&gt;
&lt;li&gt;层次加中序&lt;/li&gt;
&lt;li&gt;前序加树形结构&lt;/li&gt;
&lt;li&gt;中序加树形结构&lt;/li&gt;
&lt;li&gt;后序加树形结构&lt;/li&gt;
&lt;li&gt;层次加树形结构&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;二叉树的遍历
&lt;ol&gt;
&lt;li&gt;前序&lt;/li&gt;
&lt;li&gt;中序&lt;/li&gt;
&lt;li&gt;后序&lt;/li&gt;
&lt;li&gt;层次&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;操作系统-nice-of-linux&#34;&gt;操作系统-nice of linux
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Multi-Level Feedback Queue (cpu-sched-mlfq)
&lt;ol&gt;
&lt;li&gt;Basic Rules
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rule 1&lt;/strong&gt;:If Priority(A) $&amp;gt;$ Priority(B), A runs (B doesn’t).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rule 2&lt;/strong&gt;:If Priority(A) $=$ Priority(B), A &amp;amp; B run in RR(Round Robin).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;However&lt;/strong&gt;: Those with low Priority will get starved!&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Therefore&lt;/strong&gt;: We need to change the Priority over time.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;To change Priority
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rule 3&lt;/strong&gt;: When a job enters the system, it is placed at the highest priority (the topmost queue).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rule 4a&lt;/strong&gt;: If a job uses up its allotment while running, its priority is reduced (i.e., it moves down one queue).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rule 4b&lt;/strong&gt;: If a job gives up the CPU (for example, by performing an I/O operation) before the allotment is up, it stays at the same priority level (i.e., its allotment is reset).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;However&lt;/strong&gt;:
&lt;ol&gt;
&lt;li&gt;Those with long cpu-time will get starved as them move down to the lowest!&lt;/li&gt;
&lt;li&gt;Those with smart heart will game the scheduler as they I/O at the last ms of the allotment.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Therefore&lt;/strong&gt;: We need to change &lt;strong&gt;rule4a,b&lt;/strong&gt; and boost periodically.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The Priority Boost
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rule 5&lt;/strong&gt;: After some time period S, move all the jobs in the system to the topmost queue.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Better Accounting
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rule 4&lt;/strong&gt;: Once a job uses up its time allotment at a given level (re gardless of how many times it has given up the CPU), its priority is reduced (i.e., it moves down one queue).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Proportional share(cpu-sched-lottery)
&lt;ol&gt;
&lt;li&gt;Basic Concept: Tickets Represent Your Share&lt;/li&gt;
&lt;li&gt;Stride Scheduling&lt;/li&gt;
&lt;li&gt;The Linux Completely Fair Scheduler (CFS)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0717学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0717/</link>
        <pubDate>Thu, 17 Jul 2025 22:04:43 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0717/</guid>
        <description>&lt;h2 id=&#34;数学-纸上得来终觉浅&#34;&gt;数学-纸上得来终觉浅
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;函数极限的定义($\epsilon,\delta$语言)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数极限的性质&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;唯一性&lt;/li&gt;
&lt;li&gt;局部有界性&lt;/li&gt;
&lt;li&gt;局部保号性&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无穷小(let $\alpha$ be infinitesimal)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;性质
&lt;ul&gt;
&lt;li&gt;$\sum\limits_{k}^{N}{\alpha_k}=\alpha,(N \text{ is finite})$&lt;/li&gt;
&lt;li&gt;$\alpha&amp;rsquo;\cdot f(x)=\alpha $,where $f(x)$ is limited at the interval&lt;/li&gt;
&lt;li&gt;$\prod\limits_{k}^{N}{\alpha_k}=\alpha,(N \text{ is finite})$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;比阶($\lim\alpha(x)=0$,$\lim\beta(x)=0$,$\beta(x)\neq0$)
&lt;ul&gt;
&lt;li&gt;$\alpha(x)$是$\beta(x)$的高阶无穷小$\Leftrightarrow\lim{\frac{\alpha(x)}{\beta(x)}}=0$&lt;/li&gt;
&lt;li&gt;$\alpha(x)$是$\beta(x)$的低阶无穷小$\Leftrightarrow\lim{\frac{\alpha(x)}{\beta(x)}}=\infty$&lt;/li&gt;
&lt;li&gt;$\alpha(x)$是$\beta(x)$的同阶无穷小$\Leftrightarrow\lim{\frac{\alpha(x)}{\beta(x)}}=c,(\text{constant }c\neq 0)$&lt;/li&gt;
&lt;li&gt;$\alpha(x)$是$\beta(x)$的等价无穷小$\Leftrightarrow\lim{\frac{\alpha(x)}{\beta(x)}}=1$&lt;/li&gt;
&lt;li&gt;$\alpha(x)$是$\beta(x)$的$k$阶无穷小$\Leftrightarrow\lim{\frac{\alpha(x)}{\beta^k(x)}}=0$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;极限的运算&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;四则运算&lt;/li&gt;
&lt;li&gt;洛必达法则&lt;/li&gt;
&lt;li&gt;泰勒展开&lt;/li&gt;
&lt;li&gt;夹逼准则&lt;/li&gt;
&lt;li&gt;七种未定式：$\frac{0}{0},\frac{\infty}{\infty},0\cdot\infty,\infty-\infty,\infty^0,0^0,1^{\infty}$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数的连续和两类间断点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;超实数(&lt;a class=&#34;link&#34; href=&#34;https://people.math.wisc.edu/~hkeisler/keislercalc-06-18-25.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;hyperreal number&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;操作系统-three-easy-piece&#34;&gt;操作系统-&lt;a class=&#34;link&#34; href=&#34;https://pages.cs.wisc.edu/~remzi/OSTEP/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;three easy piece&lt;/a&gt;
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;cpu-intro
&lt;ul&gt;
&lt;li&gt;the Process&lt;/li&gt;
&lt;li&gt;Process API
&lt;ol&gt;
&lt;li&gt;create&lt;/li&gt;
&lt;li&gt;Destory&lt;/li&gt;
&lt;li&gt;Wait&lt;/li&gt;
&lt;li&gt;Miscellaneous Control&lt;/li&gt;
&lt;li&gt;Status&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Process status&lt;/li&gt;
&lt;li&gt;Proc data structure:(PCB)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;cpu-api
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;fork()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;spawn()&lt;/code&gt;*&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;cpu-mechanisms
&lt;ol&gt;
&lt;li&gt;from Directed Execution to Limited Directed Execution:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;user mode and kernel mode&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;system call&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;switch between Processes,Os need to retain CPU from process
&lt;ul&gt;
&lt;li&gt;A Cooperative Approach: Wait For System Calls&lt;/li&gt;
&lt;li&gt;A Non-Cooperative Approach: The OS Takes Control&lt;/li&gt;
&lt;li&gt;reboot (x&lt;/li&gt;
&lt;li&gt;timer interrupt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Saving and Restoring Context&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;cpu-sched(reading)&lt;/li&gt;
&lt;li&gt;cpu-sched-mlfq(reading)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据结构-排好队一个一个fifo&#34;&gt;数据结构-排好队一个一个FIFO
&lt;/h2&gt;&lt;h3 id=&#34;队列&#34;&gt;队列
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;顺序队列的性质和操作&lt;/li&gt;
&lt;li&gt;循环队列的性质和操作&lt;/li&gt;
&lt;li&gt;链式队列的性质和操作&lt;/li&gt;
&lt;li&gt;双端队列&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号018-027&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0715学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0715/</link>
        <pubDate>Tue, 15 Jul 2025 21:43:17 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0715/</guid>
        <description>&lt;h2 id=&#34;操作系统-jyy的map永远的噩梦&#34;&gt;操作系统-jyy的map永远的噩梦
&lt;/h2&gt;&lt;h3 id=&#34;死锁&#34;&gt;死锁
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;死锁的必要条件
&lt;ul&gt;
&lt;li&gt;互斥条件&lt;/li&gt;
&lt;li&gt;请求和保持条件&lt;/li&gt;
&lt;li&gt;不可剥夺条件&lt;/li&gt;
&lt;li&gt;循环等待条件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;预防死锁的方法
&lt;ul&gt;
&lt;li&gt;破坏互斥：非但不能破坏还要保护&lt;/li&gt;
&lt;li&gt;破坏不可剥夺条件&lt;/li&gt;
&lt;li&gt;破坏请求和保持条件&lt;/li&gt;
&lt;li&gt;破坏循环等待条件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;死锁避免
&lt;ol&gt;
&lt;li&gt;安全状态&lt;/li&gt;
&lt;li&gt;银行家算法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;死锁检测和解除
&lt;ul&gt;
&lt;li&gt;资源分配图&lt;/li&gt;
&lt;li&gt;死锁定理&lt;/li&gt;
&lt;li&gt;死锁的解除
&lt;ul&gt;
&lt;li&gt;剥夺资源&lt;/li&gt;
&lt;li&gt;撤销进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;内存管理&#34;&gt;内存管理
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;基本概念
&lt;ol&gt;
&lt;li&gt;逻辑地址&lt;/li&gt;
&lt;li&gt;物理地址&lt;/li&gt;
&lt;li&gt;外部碎片&lt;/li&gt;
&lt;li&gt;内部碎片&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;内存连续分配管理方式
&lt;ol&gt;
&lt;li&gt;单一连续分配&lt;/li&gt;
&lt;li&gt;固定分区分配&lt;/li&gt;
&lt;li&gt;动态分区分配
&lt;ol&gt;
&lt;li&gt;首次适应FF&lt;/li&gt;
&lt;li&gt;循环首次适应NF&lt;/li&gt;
&lt;li&gt;最佳适应BF&lt;/li&gt;
&lt;li&gt;最坏适应WF&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号016-018&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;数学-什么超实数&#34;&gt;数学-什么？！超实数？
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;函数极限的概念与性质&lt;/li&gt;
&lt;li&gt;超实数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号第一讲&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0714学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0714/</link>
        <pubDate>Mon, 14 Jul 2025 21:15:02 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0714/</guid>
        <description>&lt;h2 id=&#34;操作系统-这什么查一下这什么查一下&#34;&gt;操作系统-这什么查一下这什么查一下
&lt;/h2&gt;&lt;h3 id=&#34;经典同步问题&#34;&gt;经典同步问题
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;生产者消费者问题&lt;/li&gt;
&lt;li&gt;哲学家进餐问题&lt;/li&gt;
&lt;li&gt;读者-写者问题&lt;/li&gt;
&lt;li&gt;理发师问题&lt;/li&gt;
&lt;li&gt;抽烟者问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;处理机调度&#34;&gt;处理机调度
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;处理及调度的层次&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;高级调度（作业调度、长程调度）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作业选择&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从**后备队列（外存中等待的作业）**中选择作业&lt;/li&gt;
&lt;li&gt;判断系统资源（内存、CPU、I/O）是否充足&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;资源分配&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为选中的作业分配内存、I/O、文件等资源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进程创建&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将作业转化为一个或多个&lt;strong&gt;进程&lt;/strong&gt;，放入就绪队列&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中级调度（内存调度、中程调度）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;选择部分进程挂起（移出内存到外存）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;选择挂起的进程恢复（从外存调回内存）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;低级调度（进程调度、线程调度、短程调度）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从&lt;strong&gt;就绪队列&lt;/strong&gt;中选择一个进程&lt;/li&gt;
&lt;li&gt;把 CPU 分配给选中的进程&lt;/li&gt;
&lt;li&gt;保存和恢复进程的上下文（&lt;strong&gt;进程切换 Context Switch&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;控制 CPU 的执行顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理机的调度方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非抢占式&lt;/li&gt;
&lt;li&gt;抢占式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择调度算法的若干准则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CPU利用率&lt;/p&gt;
$$
     \frac{\text{worktime of CPU}}{\text{total time}}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统吞吐量&lt;/p&gt;
$$
     \frac{\text{number of tasks}}{\text{total time}}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;周转时间(Turnaround Time)&lt;/p&gt;
$$
     \text{Completion Time - Arrival Time}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均周转时间&lt;/p&gt;
$$
     \frac{\sum\limits_{N}\text{Turnaround Time of all processes}}{N}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;带权周转时间&lt;/p&gt;
$$
     \frac{\text{Turnaround Time}}{\text{Service Time}}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均带权周转时间&lt;/p&gt;
$$
     \frac{\sum\limits_{N}\text{Weighted Turnaround Time of all processes}}{N}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待时间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;调度算法&#34;&gt;调度算法
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;FCFS（先来先服务）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SJF（最短作业优先）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抢占&lt;/li&gt;
&lt;li&gt;非抢占&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SRTF（最短剩余时间优先）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Priority Scheduling（高优先权优先调度）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抢占&lt;/li&gt;
&lt;li&gt;非抢占&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Highest Response Ratio Next (HRRN)（高响应比有点调度算法）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Round Robin（时间片轮转）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Multilevel Feedback Queue（多级反馈队列调度）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上下文切换&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CPU上下文切换&lt;/li&gt;
&lt;li&gt;系统调用上下文切换&lt;/li&gt;
&lt;li&gt;进程上下文切换
&lt;ul&gt;
&lt;li&gt;用户级&lt;/li&gt;
&lt;li&gt;系统级&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程上下文切换&lt;/li&gt;
&lt;li&gt;中断上下文切换&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号:012-015&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;数据结构-致敬传奇栈帧pc程序计数器&#34;&gt;数据结构-致敬传奇栈帧PC程序计数器
&lt;/h2&gt;&lt;h3 id=&#34;栈&#34;&gt;栈
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;静态顺序栈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判空&lt;/li&gt;
&lt;li&gt;判满&lt;/li&gt;
&lt;li&gt;进栈&lt;/li&gt;
&lt;li&gt;出栈&lt;/li&gt;
&lt;li&gt;获取栈顶元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态顺序栈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判空&lt;/li&gt;
&lt;li&gt;判满&lt;/li&gt;
&lt;li&gt;进栈&lt;/li&gt;
&lt;li&gt;出栈&lt;/li&gt;
&lt;li&gt;获取栈顶元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链栈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判空&lt;/li&gt;
&lt;li&gt;判满&lt;/li&gt;
&lt;li&gt;进栈&lt;/li&gt;
&lt;li&gt;出栈&lt;/li&gt;
&lt;li&gt;获取栈顶元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;栈的应用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;括号匹配&lt;/li&gt;
&lt;li&gt;进制转换（辗转相除）&lt;/li&gt;
&lt;li&gt;函数递归调用&lt;/li&gt;
&lt;li&gt;表达式求值
&lt;ul&gt;
&lt;li&gt;前缀&lt;/li&gt;
&lt;li&gt;中缀（重要）&lt;/li&gt;
&lt;li&gt;后缀&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号：014-017&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;数学-太好了是张宇老师我们有救了&#34;&gt;数学-太好了是张宇老师我们有救了！
&lt;/h2&gt;&lt;h3 id=&#34;函数的概念与特性&#34;&gt;函数的概念与特性
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;函数&lt;/li&gt;
&lt;li&gt;反函数&lt;/li&gt;
&lt;li&gt;复合函数&lt;/li&gt;
&lt;li&gt;隐函数&lt;/li&gt;
&lt;li&gt;函数的四种特性
&lt;ul&gt;
&lt;li&gt;有界性&lt;/li&gt;
&lt;li&gt;单调性&lt;/li&gt;
&lt;li&gt;奇偶性&lt;/li&gt;
&lt;li&gt;周期性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基本初等函数与初等函数
&lt;ul&gt;
&lt;li&gt;常函数&lt;/li&gt;
&lt;li&gt;幂函数&lt;/li&gt;
&lt;li&gt;指数函数&lt;/li&gt;
&lt;li&gt;对数函数&lt;/li&gt;
&lt;li&gt;三角函数
&lt;ol&gt;
&lt;li&gt;sin x  cos x&lt;/li&gt;
&lt;li&gt;csc x sec x&lt;/li&gt;
&lt;li&gt;tan x cot x&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;反三角函数
&lt;ol&gt;
&lt;li&gt;arcsin x arccos x&lt;/li&gt;
&lt;li&gt;arctanx arccot x&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分段函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;高数第一讲&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0713学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0713/</link>
        <pubDate>Sun, 13 Jul 2025 23:27:16 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0713/</guid>
        <description>&lt;h2 id=&#34;数据结构-喜欢在头指针存数据的扣1&#34;&gt;数据结构-喜欢在头指针存数据的扣1
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;线性表的链式存储&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单链表&lt;/li&gt;
&lt;li&gt;静态链表&lt;/li&gt;
&lt;li&gt;其他链表
&lt;ul&gt;
&lt;li&gt;单向循环链表&lt;/li&gt;
&lt;li&gt;双向链表&lt;/li&gt;
&lt;li&gt;双向循环链表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程代码010-013&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;操作系统-谦让是美德&#34;&gt;操作系统-谦让是美德
&lt;/h2&gt;&lt;h3 id=&#34;进程与线程&#34;&gt;进程与线程
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;进程的特点：
&lt;ul&gt;
&lt;li&gt;动态性&lt;/li&gt;
&lt;li&gt;并发性&lt;/li&gt;
&lt;li&gt;独立性&lt;/li&gt;
&lt;li&gt;异步性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程的基本状态及管理切换
&lt;ul&gt;
&lt;li&gt;运行&lt;/li&gt;
&lt;li&gt;阻塞&lt;/li&gt;
&lt;li&gt;就绪&lt;/li&gt;
&lt;li&gt;创建&lt;/li&gt;
&lt;li&gt;终止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;线程的特性&lt;/li&gt;
&lt;li&gt;线程的状态&lt;/li&gt;
&lt;li&gt;线程与进程的联系和不同&lt;/li&gt;
&lt;li&gt;用户级线程与内核级线程的映射关系&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;互斥与同步&#34;&gt;互斥与同步
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;临界区实现互斥的原则&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;空闲让进&lt;/li&gt;
&lt;li&gt;忙则等待&lt;/li&gt;
&lt;li&gt;有限等待&lt;/li&gt;
&lt;li&gt;让权等待（非必须）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;临界区实现互斥的基本方法&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;软件实现方法
&lt;ol&gt;
&lt;li&gt;单标志法&lt;/li&gt;
&lt;li&gt;双标志法
&lt;ul&gt;
&lt;li&gt;先检查法&lt;/li&gt;
&lt;li&gt;后检查法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Peterson算法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;硬件实现方法
&lt;ol&gt;
&lt;li&gt;中断屏蔽&lt;/li&gt;
&lt;li&gt;TestAndSet指令&lt;/li&gt;
&lt;li&gt;Swap指令&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;互斥锁（mutex lock）&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;LockOne类&lt;/li&gt;
&lt;li&gt;LockTwo类&lt;/li&gt;
&lt;li&gt;Peterson锁&lt;/li&gt;
&lt;li&gt;Barkley锁&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;信号量&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;整型信号量&lt;/li&gt;
&lt;li&gt;记录型信号量&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;管程&#34;&gt;管程
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;管程的定义&lt;/li&gt;
&lt;li&gt;管程的组成&lt;/li&gt;
&lt;li&gt;管程的特性&lt;/li&gt;
&lt;li&gt;管程与进程的异同&lt;/li&gt;
&lt;li&gt;条件变量&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;进程通信&#34;&gt;进程通信
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;管道通信&lt;/li&gt;
&lt;li&gt;消息传递系统&lt;/li&gt;
&lt;li&gt;共享存储器系统&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号005-011&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0712学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0712/</link>
        <pubDate>Sat, 12 Jul 2025 22:05:39 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0712/</guid>
        <description>&lt;h2 id=&#34;操作系统-int-0x80&#34;&gt;操作系统-int 0x80
&lt;/h2&gt;&lt;p&gt;操作系统的运行环境&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内核程序
&lt;ul&gt;
&lt;li&gt;特权指令&lt;/li&gt;
&lt;li&gt;核心态，管态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用程序
&lt;ul&gt;
&lt;li&gt;非特权指令&lt;/li&gt;
&lt;li&gt;用户态，目态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;操作系统的内核&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;时钟管理&lt;/li&gt;
&lt;li&gt;中断机制
&lt;ol&gt;
&lt;li&gt;内部异常
&lt;ol&gt;
&lt;li&gt;故障（Fault）（软件中断）&lt;/li&gt;
&lt;li&gt;自陷（Trap）（软件中断）&lt;/li&gt;
&lt;li&gt;终止（Abort）（硬件中断）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;外部中断（硬件）
&lt;ol&gt;
&lt;li&gt;可屏蔽中断 INTR&lt;/li&gt;
&lt;li&gt;不可屏蔽中断 NMI&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号 ：003-004&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;英语-英语构词法&#34;&gt;英语-英语构词法
&lt;/h2&gt;&lt;p&gt;前缀包含两种作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;方向&lt;/li&gt;
&lt;li&gt;性质&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;后缀一般表示词性，例外：able,&amp;hellip;.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0711学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0711/</link>
        <pubDate>Fri, 11 Jul 2025 20:29:14 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0711/</guid>
        <description>&lt;h2 id=&#34;数据结构-太好了是死记硬背&#34;&gt;数据结构-太好了是死记硬背
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数据的逻辑和物理结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/npee_learning_log.github.io/posts/0711/QQ20250711-202720.png&#34;
	width=&#34;1702&#34;
	height=&#34;743&#34;
	srcset=&#34;http://localhost:1313/npee_learning_log.github.io/posts/0711/QQ20250711-202720_hu_ab8a865d16a46851.png 480w, http://localhost:1313/npee_learning_log.github.io/posts/0711/QQ20250711-202720_hu_5cae573c8a98f94d.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;229&#34;
		data-flex-basis=&#34;549px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算法的时间空间复杂度&lt;/li&gt;
&lt;li&gt;线性表的顺序表以及相关算法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;课程编号001-009&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;操作系统-想念jyy的第n天&#34;&gt;操作系统-想念jyy的第n天
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;操作系统概述
&lt;ul&gt;
&lt;li&gt;并发&lt;/li&gt;
&lt;li&gt;共享&lt;/li&gt;
&lt;li&gt;虚拟&lt;/li&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统的发展历程
&lt;ul&gt;
&lt;li&gt;批处理器
&lt;ul&gt;
&lt;li&gt;单道&lt;/li&gt;
&lt;li&gt;多道&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分时操作系统&lt;/li&gt;
&lt;li&gt;实时操作系统&lt;/li&gt;
&lt;li&gt;网络操作系统&lt;/li&gt;
&lt;li&gt;分布式操作系统&lt;/li&gt;
&lt;li&gt;&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;课程编号001-002&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
