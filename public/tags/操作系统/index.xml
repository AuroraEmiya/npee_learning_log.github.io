<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>操作系统 on shyの考研日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
        <description>Recent content in 操作系统 on shyの考研日志</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 31 Jul 2025 20:04:32 +0800</lastBuildDate><atom:link href="http://localhost:1313/npee_learning_log.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>0731学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0731/</link>
        <pubDate>Thu, 31 Jul 2025 20:04:32 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0731/</guid>
        <description>&lt;h2 id=&#34;操作系统&#34;&gt;操作系统
&lt;/h2&gt;&lt;h3 id=&#34;设备独立性软件&#34;&gt;设备独立性软件
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;高速缓存与缓冲区&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;磁盘高速缓存&lt;/li&gt;
&lt;li&gt;缓冲区
&lt;ol&gt;
&lt;li&gt;缓冲CPU与I/O设备间速度不匹配的矛盾&lt;/li&gt;
&lt;li&gt;减少对CPU的中断频率，放宽对CPU中断响应时间的限制&lt;/li&gt;
&lt;li&gt;解决基本数据单元大小（数据粒度）不匹配的问题&lt;/li&gt;
&lt;li&gt;提高CPU和IO设备之间的并行性&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;单缓冲&lt;/li&gt;
&lt;li&gt;双缓冲&lt;/li&gt;
&lt;li&gt;循环缓冲&lt;/li&gt;
&lt;li&gt;缓冲池&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设备分配与回收&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设备分配的数据结构
&lt;ol&gt;
&lt;li&gt;设备控制表（DCT）
&lt;ol&gt;
&lt;li&gt;设备控制表&lt;/li&gt;
&lt;li&gt;设备类型&lt;/li&gt;
&lt;li&gt;设备标识符&lt;/li&gt;
&lt;li&gt;设备状态&lt;/li&gt;
&lt;li&gt;指向控制器表的指针&lt;/li&gt;
&lt;li&gt;重复执行次数或时间&lt;/li&gt;
&lt;li&gt;设备队列的队首指针&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;控制器控制表（COCT）&lt;/li&gt;
&lt;li&gt;通道控制表（CHCT）&lt;/li&gt;
&lt;li&gt;系统设备表（SDT）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设备分配时应考虑的因素&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设备的固有属性
&lt;ol&gt;
&lt;li&gt;独占设备&lt;/li&gt;
&lt;li&gt;共享设备&lt;/li&gt;
&lt;li&gt;虚拟设备&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;设备分配算法
&lt;ol&gt;
&lt;li&gt;FCFS&lt;/li&gt;
&lt;li&gt;最高优先级优先算法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;设备分配中的安全性
&lt;ol&gt;
&lt;li&gt;安全分配方式&lt;/li&gt;
&lt;li&gt;不安全分配方式&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;设备分配步骤
&lt;ol&gt;
&lt;li&gt;分配设备&lt;/li&gt;
&lt;li&gt;分配控制器&lt;/li&gt;
&lt;li&gt;分配通道&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SPOOLing （假脱机技术）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入井和输出井&lt;/li&gt;
&lt;li&gt;输入缓冲区和输出缓冲区&lt;/li&gt;
&lt;li&gt;输入进程和输出进程&lt;/li&gt;
&lt;li&gt;井管理程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/npee_learning_log.github.io/posts/0731/SPOOLing.png&#34;
	width=&#34;1531&#34;
	height=&#34;734&#34;
	srcset=&#34;http://localhost:1313/npee_learning_log.github.io/posts/0731/SPOOLing_hu_402004d5932a64c9.png 480w, http://localhost:1313/npee_learning_log.github.io/posts/0731/SPOOLing_hu_3336df8fbee31f45.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;SPOOLing &amp; Buffering&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;208&#34;
		data-flex-basis=&#34;500px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;磁盘和固态硬盘&#34;&gt;磁盘和固态硬盘
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;磁盘&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁头&lt;/li&gt;
&lt;li&gt;磁道&lt;/li&gt;
&lt;li&gt;扇区&lt;/li&gt;
&lt;li&gt;盘块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;磁盘是一种主要的计算机辅助存储设备，它利用磁性记录来存储和检索数字信息。为了有效地组织和访问这些数据，磁盘被划分成多个层级的结构。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;物理结构：硬件层面&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;物理结构是磁盘驱动器本身的硬件构造，决定了数据是如何被物理存储的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;盘片 (Platter)&lt;/strong&gt;
盘片是构成硬盘的核心部件，它是一个或多个坚硬的、通常由铝、玻璃或陶瓷制成的圆形盘片。盘片的双面都涂有磁性材料，用于存储数据。一个硬盘驱动器通常包含多个堆叠在一起的盘片。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主轴 (Spindle)&lt;/strong&gt;
主轴是一个马达，所有的盘片都围绕它以恒定且极高的速度旋转（例如，每分钟7200转）。主轴的稳定性和转速对硬盘的性能至关重要。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;磁头 (Read/Write Head)&lt;/strong&gt;
每个盘片的每个磁性表面都有一个对应的磁头。磁头负责读取盘片上的磁性信息（转换为数据）或向盘片写入磁性信息（存储数据）。在工作时，磁头在一个微小的气垫上“飞行”，与盘片表面保持极近但又不接触的距离。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;磁道 (Track)&lt;/strong&gt;
当盘片旋转时，磁头保持在某个固定位置，就会在盘片上划出一个看不见的同心圆，这个圆形的路径就是&lt;strong&gt;磁道&lt;/strong&gt;。数据就是沿着这些磁道存储的。每个盘面都有数千个磁道。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;柱面 (Cylinder)&lt;/strong&gt;
在一个多盘片的硬盘中，所有盘片上半径相同的磁道共同构成了一个&lt;strong&gt;柱面&lt;/strong&gt;。想象一下，从上到下穿过所有盘片，将所有相同编号的磁道连接起来，就形成了一个空心的圆柱体。当磁头臂不移动时，它可以在同一个柱面上访问所有盘面上的数据，这比移动磁头臂去访问不同磁道要快得多。因此，相关的数据通常会存储在同一个柱面内以提高访问速度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扇区 (Sector)&lt;/strong&gt;
为了进一步管理数据，每个磁道被划分为若干个小的弧段，这些弧段被称为&lt;strong&gt;扇区&lt;/strong&gt;。扇区是磁盘上进行数据读写的最小物理单位，传统上每个扇区的大小为512字节。在进行读写操作时，磁盘控制器一次至少会读取或写入一个扇区的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结一下物理结构的层级关系：
&lt;strong&gt;硬盘驱动器 &amp;gt; 盘片 &amp;gt; 磁道 &amp;gt; 扇区&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;逻辑结构：操作系统层面&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;操作系统为了更方便、更高效地管理磁盘空间，引入了逻辑结构的概念。它在物理结构的基础上进行了抽象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;盘块 (Block) / 块&lt;/strong&gt;
操作系统与磁盘进行I/O操作时，并不会直接以物理扇区为单位。因为如果每次只读写512字节，对于今天的大文件来说效率太低，会产生大量的I/O请求。因此，操作系统将一个或多个连续的扇区组合在一起，形成一个&lt;strong&gt;盘块&lt;/strong&gt;或&lt;strong&gt;块&lt;/strong&gt;。盘块是操作系统进行文件I/O的基本（逻辑）单位。例如，一个盘块可能由8个扇区组成，那么它的大小就是 4KB (8 * 512B)。当程序请求读取文件时，操作系统会一次性读取至少一个盘块的数据到内存中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;簇 (Cluster)&lt;/strong&gt;
簇是文件系统（如FAT32、NTFS）中用于分配磁盘空间的单位。它也是由一个或多个连续的盘块组成的。当你创建一个文件并写入数据时，文件系统会为这个文件分配一个或多个簇。即使一个文件非常小，比如只有1个字节，它也至少会占用一个完整的簇。这就导致了所谓的“空间浪费”，因为簇内未使用的空间无法被其他文件使用。簇的大小会影响磁盘空间的利用率和文件系统的性能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;大簇&lt;/strong&gt;：对于存储大文件的磁盘，使用较大的簇可以减少文件碎片，提高读写性能（因为文件占用的簇是连续的），但会增加小文件的空间浪费。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;小簇&lt;/strong&gt;：可以更有效地利用磁盘空间来存储小文件，但对于大文件，可能会导致其被分割成更多的簇，增加寻址开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;总结与类比&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了更好地理解这些概念，我们可以用一个“图书馆”来类比：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;硬盘驱动器&lt;/strong&gt; 就像整个 &lt;strong&gt;图书馆大楼&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;盘片&lt;/strong&gt; 就像楼里的 &lt;strong&gt;某一层&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;磁道&lt;/strong&gt; 就像这一层书架上的 &lt;strong&gt;一排书架&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扇区&lt;/strong&gt; 就像书架上的 &lt;strong&gt;一本书&lt;/strong&gt;（这是最小的物理单位）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;盘块 (Block)&lt;/strong&gt; 就像图书馆规定，你借书时不能只借一本，必须借走 &lt;strong&gt;一摞书&lt;/strong&gt;（比如5本）。这是操作系统I/O的最小单位。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;簇 (Cluster)&lt;/strong&gt; 就像图书管理员为了方便管理，把书架划分成很多个 &lt;strong&gt;隔间&lt;/strong&gt;，每个隔间放一摞或多摞书。当你要存放你的资料时，管理员会给你分配一个或多个隔间。这是文件分配的最小单位。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这种分层结构，磁盘既能通过物理设计实现高密度存储，又能通过操作系统和文件系统的逻辑抽象，实现对数据高效、便捷的管理和访问。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;磁盘的管理&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;磁盘的初始化&lt;/p&gt;
&lt;p&gt;低级格式化（物理格式化）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分区&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;磁盘分区&lt;/li&gt;
&lt;li&gt;逻辑格式化（高级格式化）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引导块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;坏块&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;磁盘调度算法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;磁盘的存取时间&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;寻道时间$T_S$：寻道时间是指将磁头臂（Read/Write Head）从当前所在的磁道移动到目标数据所在的磁道所需要的时间。这个时间除跨越$n$条磁道的时间外，还包括启动磁头臂的时间$s$&lt;/p&gt;
$$
            T_s = m\times n+ s
            $$&lt;p&gt;其中$m$是与磁盘驱动器速度有关的常熟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;旋转延迟时间$T_r$。当磁头已经成功定位到目标磁道后，等待盘片旋转，直到目标数据的起始扇区（Sector）转到磁头正下方所需要的时间。设磁盘的旋转速度为$r$&lt;/p&gt;
$$
            T_r = \frac{1}{2r}
            $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传输时间$T_t$。当目标扇区已经到达磁头下方后，实际从盘片上读取数据或向盘片写入数据所花费的时间。这个时间取决于每次所读/写的字节数$b$和磁盘的旋转速度$r$&lt;/p&gt;
$$
            T_t = \frac{b}{rN}
            $$&lt;p&gt;式中，$r$为磁盘每秒的转数，$N$为一个磁道上的字节数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;磁盘调度算法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先来先服务算法：这是最简单的调度算法。它完全按照请求到达队列的先后顺序来处理请求。不考虑磁头当前的位置和请求磁道的远近。&lt;/li&gt;
&lt;li&gt;最短寻道时间优先(SSTF)：SSTF算法选择与磁头当前位置最近的那个请求作为下一个服务对象。这是一种贪心算法，其目标是每次都执行寻道成本最小的操作。&lt;/li&gt;
&lt;li&gt;扫描算法(SCAN)：SCAN算法模仿了电梯的运行方式。磁头在一个方向上移动，沿途服务所有该方向上的请求，直到到达磁盘的最后一个磁道，然后调转方向，继续服务反向的请求。&lt;/li&gt;
&lt;li&gt;循环扫描(C-SCAN)：C-SCAN是SCAN算法的改进版，旨在解决SCAN算法对两端磁道不公平的问题。它规定磁头只在一个方向上扫描并服务请求（例如从0到199）。当到达一端后，它会立即返回到起始端，然后重新开始下一次扫描，返回途中不服务任何请求。
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;算法名称&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;优点 (Advantages)&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;缺点 (Disadvantages)&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;先来先服务 (FCFS)&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;绝对公平&lt;/strong&gt;：所有请求按到达顺序处理，不会有请求被无限期推迟（无饥饿现象）。&lt;strong&gt;实现简单&lt;/strong&gt;：算法逻辑是所有调度算法中最简单的。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;效率低下&lt;/strong&gt;：磁头移动路径完全随机，平均寻道时间很长，导致磁盘整体性能差。`&lt;strong&gt;性能不稳定&lt;/strong&gt;：性能好坏完全取决于请求序列。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;最短寻道时间优先 (SSTF)&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;性能好&lt;/strong&gt;：平均寻道时间显著短于FCFS，系统吞吐量高。&lt;strong&gt;效率高&lt;/strong&gt;：总是选择代价最小的移动，局部性能最优。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;可能产生“饥饿”现象&lt;/strong&gt;：如果新请求总是在磁头当前位置附近产生，那么远离磁头的请求可能会长时间得不到服务。&lt;strong&gt;响应时间不均&lt;/strong&gt;：对不同位置请求的响应机会不均等。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;扫描算法 (SCAN) / 电梯算法&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;性能较好&lt;/strong&gt;：是SSTF和FCFS的一种折中，兼顾了性能和公平性。&lt;strong&gt;无饥饿问题&lt;/strong&gt;：磁头会规律地来回移动，确保所有位置的请求最终都能被处理。``&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;对两端磁道不公平&lt;/strong&gt;：位于磁盘中间区域的磁道比两端磁道的服务频率更高，响应更快。&lt;strong&gt;等待时间不均&lt;/strong&gt;：磁头刚经过的位置需要等待近一个来回周期才能再次被服务。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;循环扫描 (C-SCAN)&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;等待时间更均匀&lt;/strong&gt;：通过单向服务和快速返回，使得所有请求的等待时间更加公平和可预测。&lt;strong&gt;解决了SCAN的不公平问题&lt;/strong&gt;：对所有磁道位置的请求都一视同仁，响应时间方差小。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;额外的寻道开销&lt;/strong&gt;：磁头每次扫描到末端后，都需要一次长距离的“空载”返回（从一端直接跳到另一端），这部分移动不处理任何请求，增加了总的寻道距离。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;减少延迟时间的方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;盘面扇区的交替编号&lt;/li&gt;
&lt;li&gt;磁盘盘面的错位命名&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提高磁盘IO速度的方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;采用磁盘高速缓存&lt;/li&gt;
&lt;li&gt;调整磁盘请求顺序&lt;/li&gt;
&lt;li&gt;提前读&lt;/li&gt;
&lt;li&gt;延迟写&lt;/li&gt;
&lt;li&gt;优化物理块的分布&lt;/li&gt;
&lt;li&gt;虚拟盘&lt;/li&gt;
&lt;li&gt;采用磁盘阵列RAID&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;固态硬盘&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;固态硬盘的特性&lt;/li&gt;
&lt;li&gt;磨损均衡
&lt;ol&gt;
&lt;li&gt;动态磨损均衡&lt;/li&gt;
&lt;li&gt;静态磨损均衡&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0729学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0729/</link>
        <pubDate>Tue, 29 Jul 2025 23:17:02 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0729/</guid>
        <description>&lt;h2 id=&#34;操作系统-mkdir&#34;&gt;操作系统-mkdir
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;文件的物理结构
&lt;ol&gt;
&lt;li&gt;连续分配&lt;/li&gt;
&lt;li&gt;链接分配
&lt;ul&gt;
&lt;li&gt;隐式链接&lt;/li&gt;
&lt;li&gt;显式链接(FAT,file allocation table)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;索引分配
&lt;ol&gt;
&lt;li&gt;单级索引分配&lt;/li&gt;
&lt;li&gt;多级索引分配&lt;/li&gt;
&lt;li&gt;混合索引分配&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;磁盘的管理和组织
&lt;ol&gt;
&lt;li&gt;磁盘结构
&lt;ul&gt;
&lt;li&gt;surface&lt;/li&gt;
&lt;li&gt;track&lt;/li&gt;
&lt;li&gt;gap&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;磁盘访问时间&lt;/li&gt;
&lt;li&gt;文件存储空间管理
&lt;ol&gt;
&lt;li&gt;空闲表法&lt;/li&gt;
&lt;li&gt;空闲链表法
&lt;ol&gt;
&lt;li&gt;空闲盘块链&lt;/li&gt;
&lt;li&gt;空闲盘区链&lt;/li&gt;
&lt;li&gt;位示图&lt;/li&gt;
&lt;li&gt;成组链表法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;磁盘格式化
&lt;ol&gt;
&lt;li&gt;低级格式化&lt;/li&gt;
&lt;li&gt;高级格式化&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;附系统调用openreadclose使用代码示例&#34;&gt;附：系统调用&lt;code&gt;open(),read(),close()使用代码示例&lt;/code&gt;
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;time.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdbool.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define MAX_BUFFER_SIZE 128
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;do_the_same_thing&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;filename, &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; sleep_enabled);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;argv[])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; sleep_enabled &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; false;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Open a file in read-only mode
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (argc &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;fprintf&lt;/span&gt;(stderr, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Usage: %s &amp;lt;filename&amp;gt; --sleep&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (argc &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;strcmp&lt;/span&gt;(argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;], &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;--sleep&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sleep_enabled &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; true;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;filename &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;pid_t&lt;/span&gt; pid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fork&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// Get the current process ID
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (pid &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;perror&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Failed to fork&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;  (pid &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// Child process
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;do_the_same_thing&lt;/span&gt;(filename, sleep_enabled);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;exit&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (pid &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;do_the_same_thing&lt;/span&gt;(filename, sleep_enabled);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;perror&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Failed to fork&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;do_the_same_thing&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;filename,&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; sleep_enabled)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; fd &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;open&lt;/span&gt;(filename, O_RDONLY); &lt;span style=&#34;color:#75715e&#34;&gt;// O_RDONLY means read-only
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (fd &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;perror&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Failed to open file&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ... use fd ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;ssize_t&lt;/span&gt; bytes_read;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; buffer[MAX_BUFFER_SIZE];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        bytes_read &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;read&lt;/span&gt;(fd, buffer, MAX_BUFFER_SIZE &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// Read up to MAX_BUFFER_SIZE - 1 bytes
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (bytes_read &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// Exit loop on error or EOF
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        buffer[bytes_read] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// Null-terminate the string
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, buffer);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (sleep_enabled)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// Sleep for 1 second to simulate processing time
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;(fd);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// This function is intentionally left empty.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// It serves as a placeholder to demonstrate that the code can be extended.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;课程编号:25-28&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0726学习笔记</title>
        <link>http://localhost:1313/npee_learning_log.github.io/memo/0726/</link>
        <pubDate>Sat, 26 Jul 2025 11:19:57 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/memo/0726/</guid>
        <description>&lt;h2 id=&#34;操作系统-一些易错知识点&#34;&gt;操作系统-一些易错知识点
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在计算平均访存时间时要注意快表TLB和页表的访问是&lt;strong&gt;串行&lt;/strong&gt;还是并行的，也要注意页表是&lt;strong&gt;单级&lt;/strong&gt;还是多级的&lt;/li&gt;
&lt;li&gt;虚拟存储器的&lt;strong&gt;最大容量&lt;/strong&gt;只和计算机的地址结构决定，&lt;strong&gt;实际容量&lt;/strong&gt;和内存和外存有关&lt;/li&gt;
&lt;li&gt;工作集不是驻留集的子集，只是数量要小于（不大于）驻留集的大小&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一些你需要搞明白的概念：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;链接，包括静态和动态&lt;/p&gt;
&lt;p&gt;链接是将不同编译单元及其依赖库整合到一个统一逻辑地址空间的过程。根据发生时间不同，链接分为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;静态链接&lt;/strong&gt;：在编译阶段将所有代码打包进可执行文件中；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态链接&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;加载时链接（Load-Time Linking）&lt;/strong&gt;：程序加载时操作系统自动加载依赖库；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行时链接（Run-Time Linking）&lt;/strong&gt;：程序运行过程中手动加载库，例如通过 &lt;code&gt;dlopen()&lt;/code&gt; 等函数调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;类别&lt;/th&gt;
          &lt;th&gt;链接时间&lt;/th&gt;
          &lt;th&gt;控制方式&lt;/th&gt;
          &lt;th&gt;示例函数&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;静态链接&lt;/td&gt;
          &lt;td&gt;编译/链接阶段&lt;/td&gt;
          &lt;td&gt;编译器自动处理&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;动态链接（加载时）&lt;/td&gt;
          &lt;td&gt;程序加载阶段&lt;/td&gt;
          &lt;td&gt;操作系统自动处理&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;动态链接（运行时）&lt;/td&gt;
          &lt;td&gt;程序运行阶段&lt;/td&gt;
          &lt;td&gt;程序员手动调用&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;dlopen&lt;/code&gt;, &lt;code&gt;dlsym&lt;/code&gt; 等&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;$&amp;gt;dive into the procedure of linking of a C code program(Gemini 2.5 pro)&lt;/p&gt;
&lt;h3 id=&#34;the-final-step-unraveling-the-linking-process-of-a-c-program&#34;&gt;The Final Step: Unraveling the Linking Process of a C Program
&lt;/h3&gt;&lt;p&gt;The journey from human-readable C code to an executable program culminates in a crucial, often-overlooked stage: linking. This final step in the compilation process is where all the disparate pieces of your program are brought together to create a single, functional executable file. The linker, a key component of the C toolchain, orchestrates this assembly, resolving references between different parts of your code and incorporating necessary library functions.&lt;/p&gt;
&lt;p&gt;The compilation of a C program is a multi-stage process. First, the preprocessor handles directives like &lt;code&gt;#include&lt;/code&gt; and &lt;code&gt;#define&lt;/code&gt;. The preprocessed code is then compiled into assembly language, which is subsequently converted into machine-readable object files. These object files, however, are not yet ready to run. They are incomplete pieces of a larger puzzle, and it is the linker&amp;rsquo;s job to put them together.&lt;/p&gt;
&lt;p&gt;The primary role of the linker is to take one or more object files, along with any necessary libraries, and combine them into a single executable file. A key function of the linker is &lt;strong&gt;symbol resolution&lt;/strong&gt;. When you call a function in one C file that is defined in another, the compiler leaves a placeholder, or a reference, in the object file. The linker&amp;rsquo;s job is to find the actual memory address of that function in the other object file and replace the placeholder with this address. This ensures that when the program runs, the function call correctly jumps to the right location in memory.&lt;/p&gt;
&lt;h3 id=&#34;static-vs-dynamic-linking-two-approaches-to-integration&#34;&gt;Static vs. Dynamic Linking: Two Approaches to Integration
&lt;/h3&gt;&lt;p&gt;There are two fundamental ways a linker can incorporate external code into your program: static linking and dynamic linking.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Static Linking:&lt;/strong&gt; In this approach, all the required library code is copied directly into the final executable file. This creates a self-contained program that does not rely on external libraries to be present on the system where it is run.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Advantages of Static Linking:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Portability:&lt;/strong&gt; The executable can be run on systems that do not have the required libraries installed.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Potentially Faster Execution:&lt;/strong&gt; Since all the code is in one place, it can sometimes lead to faster execution as there is no need to load external libraries at runtime.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Disadvantages of Static Linking:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Larger Executable Size:&lt;/strong&gt; Because all library code is included, the resulting executable file is larger.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Inefficient Memory and Disk Space Usage:&lt;/strong&gt; If multiple programs on a system use the same statically linked library, each will have its own copy, leading to redundant use of disk space and memory.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Difficult to Update:&lt;/strong&gt; To update a library, every program that uses it must be re-linked.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Dynamic Linking:&lt;/strong&gt; In contrast, dynamic linking does not copy the library code into the executable. Instead, it only includes the names of the shared libraries that the program needs. The actual linking of the library code happens at runtime when the program is loaded into memory.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Advantages of Dynamic Linking:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Smaller Executable Size:&lt;/strong&gt; The executables are smaller as they only contain references to the shared libraries.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Efficient Memory and Disk Space Usage:&lt;/strong&gt; A single copy of a shared library in memory can be used by multiple programs.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Easier Updates:&lt;/strong&gt; To update a library, you only need to replace the shared library file; all programs that use it will automatically benefit from the update without needing to be re-linked.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Disadvantages of Dynamic Linking:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Dependencies:&lt;/strong&gt; The program will not run if the required shared libraries are not present on the system or if the version is incompatible.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Slightly Slower Startup:&lt;/strong&gt; There can be a minor performance overhead at startup as the dynamic linker needs to find and load the necessary shared libraries.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;the-linking-process-in-action-with-gcc&#34;&gt;The Linking Process in Action with GCC
&lt;/h3&gt;&lt;p&gt;The GNU Compiler Collection (GCC) is a popular toolchain for compiling and linking C programs. The linking process can be performed as a separate step or combined with compilation.&lt;/p&gt;
&lt;p&gt;To compile a C source file (&lt;code&gt;.c&lt;/code&gt;) into an object file (&lt;code&gt;.o&lt;/code&gt;), you can use the &lt;code&gt;-c&lt;/code&gt; flag with &lt;code&gt;gcc&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;gcc -c my_program.c
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will create an object file named &lt;code&gt;my_program.o&lt;/code&gt;. If your program is split across multiple source files, you would compile each one into an object file.&lt;/p&gt;
&lt;p&gt;Once you have all the necessary object files, you can link them together to create an executable file using the &lt;code&gt;-o&lt;/code&gt; flag to specify the output file name:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;gcc -o my_executable my_program.o another_file.o
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This command tells &lt;code&gt;gcc&lt;/code&gt; to link &lt;code&gt;my_program.o&lt;/code&gt; and &lt;code&gt;another_file.o&lt;/code&gt; and create an executable file named &lt;code&gt;my_executable&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;common-linker-errors&#34;&gt;Common Linker Errors
&lt;/h3&gt;&lt;p&gt;Errors that occur during the linking phase are known as linker errors. Some of the most common linker errors include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Undefined Symbol/Undefined Reference:&lt;/strong&gt; This is the most frequent linker error. It occurs when the linker cannot find the definition for a function or variable that has been declared and used in the code. This often happens when you forget to link an object file that contains the definition or mistype a function name.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Multiple Definitions:&lt;/strong&gt; This error arises when the linker finds more than one definition for the same function or variable. This can happen if you define a function in a header file that gets included in multiple source files or if you link the same object file multiple times.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In conclusion, the linking process is the essential final act in the creation of a C program. By understanding how the linker works, the differences between static and dynamic linking, and how to use tools like &lt;code&gt;gcc&lt;/code&gt; to control the linking process, developers can gain a deeper insight into how their code is transformed into a runnable application and more effectively troubleshoot common errors.&lt;/p&gt;
&lt;p&gt;$&amp;gt;are there different categories of dynamic linking technique?(Gemini 2.5 pro)&lt;/p&gt;
&lt;p&gt;Yes, there are different categories of dynamic linking techniques, each with its own timing and mechanism for connecting a program to the shared libraries it needs. The main distinctions lie in &lt;em&gt;when&lt;/em&gt; the linking happens and &lt;em&gt;who&lt;/em&gt; initiates it.&lt;/p&gt;
&lt;p&gt;Here&amp;rsquo;s a breakdown of the primary categories of dynamic linking:&lt;/p&gt;
&lt;h3 id=&#34;1-load-time-dynamic-linking-implicit-linking&#34;&gt;1. Load-Time Dynamic Linking (Implicit Linking)
&lt;/h3&gt;&lt;p&gt;This is the most common form of dynamic linking. When you compile and link your program against a shared library, the linker embeds references to that library directly into the executable file.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How it works:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;At compile time:&lt;/strong&gt; The linker records the names of the shared libraries the program depends on and the symbols (functions and variables) it uses from them.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;At load time:&lt;/strong&gt; When you run the executable, the operating system&amp;rsquo;s program loader (also known as the dynamic linker or runtime linker) reads this dependency information. It then locates the necessary shared libraries on the system, loads them into the process&amp;rsquo;s address space, and resolves all the symbol references before the program&amp;rsquo;s main function begins to execute.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Key Characteristics:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Automatic:&lt;/strong&gt; The entire process is handled automatically by the operating system.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dependencies are required at startup:&lt;/strong&gt; If any of the required shared libraries are missing or incompatible, the program will fail to start.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Slight startup overhead:&lt;/strong&gt; There is a small performance cost at program launch while the dynamic linker does its work.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-run-time-dynamic-linking-explicit-linking-or-dynamic-loading&#34;&gt;2. Run-Time Dynamic Linking (Explicit Linking or Dynamic Loading)
&lt;/h3&gt;&lt;p&gt;This technique gives the programmer more control over the linking process. Instead of the operating system automatically loading libraries at startup, the program itself can explicitly load and unload libraries at any point during its execution.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How it works:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Programmatic Control:&lt;/strong&gt; The program uses specific API calls (like &lt;code&gt;dlopen()&lt;/code&gt;, &lt;code&gt;dlsym()&lt;/code&gt;, and &lt;code&gt;dlclose()&lt;/code&gt; on POSIX systems, or &lt;code&gt;LoadLibrary()&lt;/code&gt;, &lt;code&gt;GetProcAddress()&lt;/code&gt;, and &lt;code&gt;FreeLibrary()&lt;/code&gt; on Windows) to manage shared libraries.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dlopen()&lt;/code&gt; or &lt;code&gt;LoadLibrary()&lt;/code&gt;: Loads a specified library into memory.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dlsym()&lt;/code&gt; or &lt;code&gt;GetProcAddress()&lt;/code&gt;: Retrieves the address of a specific function or variable within the loaded library.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dlclose()&lt;/code&gt; or &lt;code&gt;FreeLibrary()&lt;/code&gt;: Unloads the library from memory.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Key Characteristics:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Flexibility:&lt;/strong&gt; Programs can decide which libraries to load based on runtime conditions. This is the foundation for a &amp;ldquo;plugin&amp;rdquo; architecture, where new functionality can be added to a running application by loading new shared libraries.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No startup dependency:&lt;/strong&gt; The program can start even if the optional libraries are not present. It can then check for their availability and load them if needed.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;More complex to implement:&lt;/strong&gt; The programmer is responsible for managing the loading, symbol lookup, and unloading of libraries, which requires more code and error handling.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;a-special-case-lazy-linking&#34;&gt;A Special Case: Lazy Linking
&lt;/h3&gt;&lt;p&gt;Lazy linking is an optimization often used with load-time dynamic linking to improve program startup time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How it works:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Instead of resolving all function addresses when the program is first loaded, the dynamic linker defers the resolution of each function until it is actually called for the first time.&lt;/li&gt;
&lt;li&gt;The first time a function in a shared library is called, a small piece of code (a &amp;ldquo;trampoline&amp;rdquo; or &amp;ldquo;stub&amp;rdquo;) in the program&amp;rsquo;s Procedure Linkage Table (PLT) transfers control to the dynamic linker. The dynamic linker then looks up the real address of the function, patches the PLT entry to point directly to it, and then calls the function.&lt;/li&gt;
&lt;li&gt;Subsequent calls to that same function will then go directly to the function&amp;rsquo;s address without involving the dynamic linker, resulting in minimal overhead.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Key Characteristics:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Faster startup:&lt;/strong&gt; By avoiding the upfront cost of resolving every single function, the program can start executing more quickly.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Minimal overhead on first call:&lt;/strong&gt; There is a small performance penalty the very first time each dynamically linked function is called.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Transparent to the developer:&lt;/strong&gt; This is typically a default behavior of the dynamic linker and doesn&amp;rsquo;t require any special coding by the programmer.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In essence, while &lt;strong&gt;load-time&lt;/strong&gt; and &lt;strong&gt;run-time&lt;/strong&gt; dynamic linking are the two main strategies, &lt;strong&gt;lazy linking&lt;/strong&gt; is a common optimization that fine-tunes the performance of load-time linking. The choice between these techniques depends on the specific needs of the application, balancing ease of use, startup performance, and the flexibility to load code on demand.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;卡特兰数，用于计算给定输入栈序列，所有可能的输出排列
&lt;/p&gt;
$$
   \frac{1}{n+1}\binom{2n}{n}=\frac{2n!}{(n+1)!n!}
   $$&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;英语-单词词根词缀分开&#34;&gt;英语-单词（词根词缀分开）
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;a vail&lt;/li&gt;
&lt;li&gt;mock&lt;/li&gt;
&lt;li&gt;gigantic&lt;/li&gt;
&lt;li&gt;zoom&lt;/li&gt;
&lt;li&gt;speci fication&lt;/li&gt;
&lt;li&gt;pa nel&lt;/li&gt;
&lt;li&gt;pre mise&lt;/li&gt;
&lt;li&gt;sovereign&lt;/li&gt;
&lt;li&gt;utter&lt;/li&gt;
&lt;li&gt;deem&lt;/li&gt;
&lt;li&gt;mono poly&lt;/li&gt;
&lt;li&gt;spec ulate&lt;/li&gt;
&lt;li&gt;con form&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0722学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0722/</link>
        <pubDate>Tue, 22 Jul 2025 23:31:50 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0722/</guid>
        <description>&lt;h2 id=&#34;操作系统--la-pa-ca&#34;&gt;操作系统- (LA-PA-CA)
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;带快表的两级系统的地址翻译过程
&lt;ol&gt;
&lt;li&gt;从逻辑地址映射到物理地址（虚拟存储器）&lt;/li&gt;
&lt;li&gt;从物理地址映射到Cache地址（主存-Cache系统）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;文件和文件系统
&lt;ol&gt;
&lt;li&gt;构成文件的基本单位&lt;/li&gt;
&lt;li&gt;文件的定义&lt;/li&gt;
&lt;li&gt;文件属性&lt;/li&gt;
&lt;li&gt;文件的基本操作&lt;/li&gt;
&lt;li&gt;文件的打开和关闭的操作&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;文件的逻辑结构&lt;/li&gt;
&lt;li&gt;目录管理
&lt;ol&gt;
&lt;li&gt;目录的概念&lt;/li&gt;
&lt;li&gt;文件控制块和索引节点&lt;/li&gt;
&lt;li&gt;目录结构&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;英语-vocabularybuilder&#34;&gt;英语-VocabularyBuilder
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;CRIM,comes from the Latin words for &amp;ldquo;fault or crime&amp;rdquo; or &amp;ldquo;accusation.&amp;rdquo;
&lt;ol&gt;
&lt;li&gt;criminology&lt;/li&gt;
&lt;li&gt;decriminalize&lt;/li&gt;
&lt;li&gt;incriminate&lt;/li&gt;
&lt;li&gt;recrimination&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;PROB,comes from the Latin words for  &amp;ldquo;prove or proof &amp;ldquo;and &amp;ldquo;honesy or integrity.&amp;rdquo;
&lt;ol&gt;
&lt;li&gt;approbation&lt;/li&gt;
&lt;li&gt;probate&lt;/li&gt;
&lt;li&gt;probity&lt;/li&gt;
&lt;li&gt;reprobate&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;GRAV, comes from the Latin word meaning &amp;ldquo;heavy ,weighty ,serious&amp;rdquo;
&lt;ol&gt;
&lt;li&gt;grave&lt;/li&gt;
&lt;li&gt;gravitas&lt;/li&gt;
&lt;li&gt;gravitate&lt;/li&gt;
&lt;li&gt;aggravate&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;LEV,comes from the Latin adjective $levis$,meaning &amp;ldquo;light&amp;rdquo;,and the verb $levare$,meaning &amp;ldquo;to raise or lighten.&amp;rdquo;
&lt;ol&gt;
&lt;li&gt;alleviate&lt;/li&gt;
&lt;li&gt;elevation&lt;/li&gt;
&lt;li&gt;contilever&lt;/li&gt;
&lt;li&gt;levity&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数学-行列式&#34;&gt;数学-行列式
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;行列式的本质定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行列式的性质&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h6 id=&#34;aat&#34;&gt;$|A|=|A^T|$
&lt;/h6&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若行列式中某行(列)元素全为零，则行列式为零&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若行列式中某行(列) 元素有公因子$k\neq0$，则$k$可提到行列式外面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行列式中某行(列)元素均是两个数之和，则可拆成两个行列式之和&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行列式中两行(列)互换，行列式变号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行列式中的两行(列)元素相等或对应成比例，则行列式为零&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行列式的逆序法定义
&lt;/p&gt;
$$
   \begin{vmatrix}
   a_{11} &amp; a_{12} &amp; \cdots&amp;a_{1n}\\
   a_{21} &amp; a_{22} &amp; \cdots&amp;a_{2n}\\
   \vdots &amp; \vdots &amp; &amp;\vdots\\
   a_{n1} &amp; a_{n2} &amp; \cdots&amp;a_{nn}\\
   \end{vmatrix}=\sum\limits_{j_1j_2\cdots j_n}{(-1)^{\tau(j_1j_2\cdots j_n)}}a_{j_1}a_{j_2}\cdots a_{j_n}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行列式的展开定理
&lt;/p&gt;
$$
   |A| = \sum\limits_{j=1}^na_{ij}A_{ij}
   $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;几个重要的行列式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;主对角线行列式(上(下)三角形行列式)
&lt;/p&gt;
$$
      \begin{vmatrix}
      a_{11} &amp; a_{12} &amp; \cdots&amp;a_{1n}\\
      0 &amp; a_{22} &amp; \cdots&amp;a_{2n}\\
      \vdots &amp; \vdots &amp; &amp;\vdots\\
      0 &amp; 0 &amp; \cdots&amp;a_{nn}\\
      \end{vmatrix}=\begin{vmatrix}
      a_{11} &amp; 0 &amp; \cdots&amp;0\\
      a_{21} &amp; a_{22} &amp; \cdots&amp;0\\
      \vdots &amp; \vdots &amp; &amp;\vdots\\
      a_{n1} &amp; a_{n2} &amp; \cdots&amp;a_{nn}\\
      \end{vmatrix}=\begin{vmatrix}
      a_{11} &amp; 0 &amp; \cdots&amp;0\\
      0 &amp; a_{22} &amp; \cdots&amp;0\\
      \vdots &amp; \vdots &amp; &amp;\vdots\\
      0 &amp; 0 &amp; \cdots&amp;a_{nn}\\
      \end{vmatrix}=\prod\limits_{i=1}^n a_{ii}
      $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;副对角线行列式
&lt;/p&gt;
$$
      \begin{vmatrix}
      a_{11} &amp; \cdots &amp; a_{1,n-1}&amp;a_{1n}\\
      a_{21} &amp; \cdots &amp; a_{2,n-1}&amp;0\\
      \vdots &amp;  &amp;\vdots &amp;\vdots\\
      a_{n1} &amp;\cdots&amp;0 &amp;0\\
      \end{vmatrix}=\begin{vmatrix}
      0 &amp; \cdots &amp; 0&amp;a_{1n}\\
      0 &amp;\cdots &amp; a_{2,n-1}&amp;a_{2n}\\
      \vdots &amp; &amp; \vdots &amp;\vdots\\
      a_{n1} &amp;\cdots &amp; a_{n,n-1}&amp;a_{nn}\\
      \end{vmatrix}=\begin{vmatrix}
      0 &amp; \cdots &amp; 0&amp;a_{1n}\\
      0 &amp; \cdots &amp; a_{2,n-1}&amp;0\\
      \vdots &amp; &amp;  \vdots&amp;\vdots\\
      a_{n1} &amp; \cdots &amp; 0&amp;0\\
      \end{vmatrix}=(-1)^{\frac{n(n-1)}{2}}\prod\limits_{i=1}^n a_{i(n+1-i)}
      $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拉普拉斯展开式($A\in R^{m\times m},B\in R^{n\times n}$)
&lt;/p&gt;
$$
      \begin{vmatrix}
      A&amp;O\\
      O&amp;B
      \end{vmatrix}=\begin{vmatrix}
      A&amp;C\\
      O&amp;B
      \end{vmatrix}=\begin{vmatrix}
      A&amp;O\\
      C&amp;B
      \end{vmatrix}=|A||B|
      $$$$
      \begin{vmatrix}
      O&amp;A\\
      B&amp;O
      \end{vmatrix}=\begin{vmatrix}
      C&amp;A\\
      B&amp;O
      \end{vmatrix}=\begin{vmatrix}
      O&amp;A\\
      B&amp;C
      \end{vmatrix}=(-1)^{mn}|A||B|
      $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;范德蒙德行列式,$(1\leq i &amp;lt;j\leq n)$
&lt;/p&gt;
$$
      \begin{vmatrix}
      1&amp;1&amp;\cdots&amp;1\\
      x_1&amp;x_2&amp;\cdots&amp;x_n\\
      x_1^2&amp;x_2^2&amp;\cdots&amp;x_n^2\\
      \vdots&amp;\vdots&amp;&amp;\vdots\\
      x_1^n&amp;x_2^n&amp;\cdots&amp;x_n^n
      \end{vmatrix}=\prod\limits_{i,j}{(x_i-x_j)}
      $$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0721学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0721/</link>
        <pubDate>Mon, 21 Jul 2025 17:53:02 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0721/</guid>
        <description>&lt;h2 id=&#34;英语-vocabulary-builder&#34;&gt;英语-vocabulary builder
&lt;/h2&gt;&lt;p&gt;使用 &lt;code&gt;The Merriam-Webster Vocabulary Builder&lt;/code&gt;作为词根法扩充词汇量的工具书(由网友canon提供)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BENE , latin for &lt;code&gt;well&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;benediction&lt;/li&gt;
&lt;li&gt;benefactor&lt;/li&gt;
&lt;li&gt;benefaciary&lt;/li&gt;
&lt;li&gt;benevolence&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AM, comes form the latin &lt;code&gt;admare&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;amicable&lt;/li&gt;
&lt;li&gt;enamored&lt;/li&gt;
&lt;li&gt;amorous&lt;/li&gt;
&lt;li&gt;paramour&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BELL,comes from the latin word meaning &lt;code&gt;war&lt;/code&gt;.Bellona was the little-known goddess of war .
&lt;ul&gt;
&lt;li&gt;antebellum&lt;/li&gt;
&lt;li&gt;belligerence&lt;/li&gt;
&lt;li&gt;bellicose&lt;/li&gt;
&lt;li&gt;rebellion&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PAC,is related to the Latin words for &amp;ldquo;agree&amp;rdquo; and &amp;ldquo;peace&amp;rdquo;
&lt;ul&gt;
&lt;li&gt;pacify&lt;/li&gt;
&lt;li&gt;pacifist&lt;/li&gt;
&lt;li&gt;pact&lt;/li&gt;
&lt;li&gt;pace&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;操作系统-page--segment&#34;&gt;操作系统-page &amp;amp; segment
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本分页内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;page&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;page frame&lt;/li&gt;
&lt;li&gt;page table&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;页号&lt;/th&gt;
          &lt;th&gt;页内偏移量&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;虚拟地址 = 页号 + 页内偏移&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;LRU（最近最少使用）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FIFO（先进先出）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CLOCK（近似LRU）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TLB（Translation Lookaside Buffer）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两级以及多级页表&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本分段内存管理&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本结构&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;段号&lt;/th&gt;
          &lt;th&gt;段内地址&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;段表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地址变换机制&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚拟存储器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页表机制&lt;/li&gt;
&lt;li&gt;缺页中断机制&lt;/li&gt;
&lt;li&gt;地址变换机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号：019-021&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;数据结构-二叉树&#34;&gt;数据结构-二叉树
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;线索二叉树&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;li&gt;构造&lt;/li&gt;
&lt;li&gt;遍历&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;树、森林与二叉树&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;相互转换&lt;/li&gt;
&lt;li&gt;遍历&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哈夫曼树&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;WPL&lt;/li&gt;
&lt;li&gt;构造&lt;/li&gt;
&lt;li&gt;哈夫曼编码&lt;/li&gt;
&lt;li&gt;哈夫曼树的特点&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并查集&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;li&gt;操作&lt;/li&gt;
&lt;li&gt;实现&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号：033-037&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0719学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0719/</link>
        <pubDate>Sat, 19 Jul 2025 22:41:19 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0719/</guid>
        <description>&lt;h2 id=&#34;数学-是不动点的味道&#34;&gt;数学-是不动点的味道
&lt;/h2&gt;&lt;h3 id=&#34;数列的极限&#34;&gt;数列的极限
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;概念&lt;/li&gt;
&lt;li&gt;数列极限的定义&lt;/li&gt;
&lt;li&gt;数列收敛的性质
&lt;ul&gt;
&lt;li&gt;唯一性&lt;/li&gt;
&lt;li&gt;有界性&lt;/li&gt;
&lt;li&gt;保号性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;海涅定理（归结原则）&lt;/li&gt;
&lt;li&gt;夹逼准则&lt;/li&gt;
&lt;li&gt;单调有界准则&lt;/li&gt;
&lt;li&gt;${x_n}$收敛于$a$的速度问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据结构-前序中序后序blablabla&#34;&gt;数据结构-前序中序后序blablabla
&lt;/h2&gt;&lt;h3 id=&#34;树的性质&#34;&gt;树的性质
&lt;/h3&gt;&lt;p&gt;let $T_m$ denote a tree with degree $m$.&lt;/p&gt;
&lt;p&gt;let $D(n)$ denote the out degree of the node $x$ in the tree $T_m$.&lt;/p&gt;
&lt;p&gt;let $n_i$ denote the number of notes with degree $i$.&lt;/p&gt;
&lt;p&gt;let $H$ denote the depth/height of the tree $T_m$.&lt;/p&gt;
&lt;p&gt;let $N$ denote the total number of nodes in tree.$N=\sum\limits_{i=0}^mn_i$.&lt;/p&gt;
&lt;p&gt;let $N_i$ denote the number of nodes at layer $i\in \mathcal{N^*}$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$N=1 + \sum\limits_{i=1}^mi\cdot n_i$.&lt;/li&gt;
&lt;li&gt;$n_0 =1 + \sum\limits_{i=2}^m(i-1)\cdot n_i$&lt;/li&gt;
&lt;li&gt;$N_i\leq m^{i-1}$ if not an &lt;strong&gt;empty tree&lt;/strong&gt; with degree m.&lt;/li&gt;
&lt;li&gt;$N\leq \frac{m^H-1}{m-1}$&lt;/li&gt;
&lt;li&gt;$H\geq \lceil\log_{m}\left((N(m-1))+1\right)\rceil$&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二叉树&#34;&gt;二叉树
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;二叉树的性质
&lt;ol&gt;
&lt;li&gt;$N_i\leq 2^{i-1}$ if not an &lt;strong&gt;empty tree&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;$N\leq 2^H-1$&lt;/li&gt;
&lt;li&gt;$n_0 =1 + n_2$&lt;/li&gt;
&lt;li&gt;$H\geq \lceil\log_{2}(N+1)\rceil$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;完全二叉树&lt;/li&gt;
&lt;li&gt;满二叉树&lt;/li&gt;
&lt;li&gt;二叉树的构造
&lt;ol&gt;
&lt;li&gt;前序加中序&lt;/li&gt;
&lt;li&gt;后序加中序&lt;/li&gt;
&lt;li&gt;层次加中序&lt;/li&gt;
&lt;li&gt;前序加树形结构&lt;/li&gt;
&lt;li&gt;中序加树形结构&lt;/li&gt;
&lt;li&gt;后序加树形结构&lt;/li&gt;
&lt;li&gt;层次加树形结构&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;二叉树的遍历
&lt;ol&gt;
&lt;li&gt;前序&lt;/li&gt;
&lt;li&gt;中序&lt;/li&gt;
&lt;li&gt;后序&lt;/li&gt;
&lt;li&gt;层次&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;操作系统-nice-of-linux&#34;&gt;操作系统-nice of linux
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Multi-Level Feedback Queue (cpu-sched-mlfq)
&lt;ol&gt;
&lt;li&gt;Basic Rules
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rule 1&lt;/strong&gt;:If Priority(A) $&amp;gt;$ Priority(B), A runs (B doesn’t).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rule 2&lt;/strong&gt;:If Priority(A) $=$ Priority(B), A &amp;amp; B run in RR(Round Robin).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;However&lt;/strong&gt;: Those with low Priority will get starved!&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Therefore&lt;/strong&gt;: We need to change the Priority over time.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;To change Priority
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rule 3&lt;/strong&gt;: When a job enters the system, it is placed at the highest priority (the topmost queue).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rule 4a&lt;/strong&gt;: If a job uses up its allotment while running, its priority is reduced (i.e., it moves down one queue).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rule 4b&lt;/strong&gt;: If a job gives up the CPU (for example, by performing an I/O operation) before the allotment is up, it stays at the same priority level (i.e., its allotment is reset).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;However&lt;/strong&gt;:
&lt;ol&gt;
&lt;li&gt;Those with long cpu-time will get starved as them move down to the lowest!&lt;/li&gt;
&lt;li&gt;Those with smart heart will game the scheduler as they I/O at the last ms of the allotment.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Therefore&lt;/strong&gt;: We need to change &lt;strong&gt;rule4a,b&lt;/strong&gt; and boost periodically.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The Priority Boost
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rule 5&lt;/strong&gt;: After some time period S, move all the jobs in the system to the topmost queue.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Better Accounting
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rule 4&lt;/strong&gt;: Once a job uses up its time allotment at a given level (re gardless of how many times it has given up the CPU), its priority is reduced (i.e., it moves down one queue).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Proportional share(cpu-sched-lottery)
&lt;ol&gt;
&lt;li&gt;Basic Concept: Tickets Represent Your Share&lt;/li&gt;
&lt;li&gt;Stride Scheduling&lt;/li&gt;
&lt;li&gt;The Linux Completely Fair Scheduler (CFS)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0715学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0715/</link>
        <pubDate>Tue, 15 Jul 2025 21:43:17 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0715/</guid>
        <description>&lt;h2 id=&#34;操作系统-jyy的map永远的噩梦&#34;&gt;操作系统-jyy的map永远的噩梦
&lt;/h2&gt;&lt;h3 id=&#34;死锁&#34;&gt;死锁
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;死锁的必要条件
&lt;ul&gt;
&lt;li&gt;互斥条件&lt;/li&gt;
&lt;li&gt;请求和保持条件&lt;/li&gt;
&lt;li&gt;不可剥夺条件&lt;/li&gt;
&lt;li&gt;循环等待条件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;预防死锁的方法
&lt;ul&gt;
&lt;li&gt;破坏互斥：非但不能破坏还要保护&lt;/li&gt;
&lt;li&gt;破坏不可剥夺条件&lt;/li&gt;
&lt;li&gt;破坏请求和保持条件&lt;/li&gt;
&lt;li&gt;破坏循环等待条件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;死锁避免
&lt;ol&gt;
&lt;li&gt;安全状态&lt;/li&gt;
&lt;li&gt;银行家算法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;死锁检测和解除
&lt;ul&gt;
&lt;li&gt;资源分配图&lt;/li&gt;
&lt;li&gt;死锁定理&lt;/li&gt;
&lt;li&gt;死锁的解除
&lt;ul&gt;
&lt;li&gt;剥夺资源&lt;/li&gt;
&lt;li&gt;撤销进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;内存管理&#34;&gt;内存管理
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;基本概念
&lt;ol&gt;
&lt;li&gt;逻辑地址&lt;/li&gt;
&lt;li&gt;物理地址&lt;/li&gt;
&lt;li&gt;外部碎片&lt;/li&gt;
&lt;li&gt;内部碎片&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;内存连续分配管理方式
&lt;ol&gt;
&lt;li&gt;单一连续分配&lt;/li&gt;
&lt;li&gt;固定分区分配&lt;/li&gt;
&lt;li&gt;动态分区分配
&lt;ol&gt;
&lt;li&gt;首次适应FF&lt;/li&gt;
&lt;li&gt;循环首次适应NF&lt;/li&gt;
&lt;li&gt;最佳适应BF&lt;/li&gt;
&lt;li&gt;最坏适应WF&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号016-018&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;数学-什么超实数&#34;&gt;数学-什么？！超实数？
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;函数极限的概念与性质&lt;/li&gt;
&lt;li&gt;超实数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号第一讲&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0714学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0714/</link>
        <pubDate>Mon, 14 Jul 2025 21:15:02 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0714/</guid>
        <description>&lt;h2 id=&#34;操作系统-这什么查一下这什么查一下&#34;&gt;操作系统-这什么查一下这什么查一下
&lt;/h2&gt;&lt;h3 id=&#34;经典同步问题&#34;&gt;经典同步问题
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;生产者消费者问题&lt;/li&gt;
&lt;li&gt;哲学家进餐问题&lt;/li&gt;
&lt;li&gt;读者-写者问题&lt;/li&gt;
&lt;li&gt;理发师问题&lt;/li&gt;
&lt;li&gt;抽烟者问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;处理机调度&#34;&gt;处理机调度
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;处理及调度的层次&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;高级调度（作业调度、长程调度）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作业选择&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从**后备队列（外存中等待的作业）**中选择作业&lt;/li&gt;
&lt;li&gt;判断系统资源（内存、CPU、I/O）是否充足&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;资源分配&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为选中的作业分配内存、I/O、文件等资源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进程创建&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将作业转化为一个或多个&lt;strong&gt;进程&lt;/strong&gt;，放入就绪队列&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中级调度（内存调度、中程调度）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;选择部分进程挂起（移出内存到外存）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;选择挂起的进程恢复（从外存调回内存）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;低级调度（进程调度、线程调度、短程调度）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从&lt;strong&gt;就绪队列&lt;/strong&gt;中选择一个进程&lt;/li&gt;
&lt;li&gt;把 CPU 分配给选中的进程&lt;/li&gt;
&lt;li&gt;保存和恢复进程的上下文（&lt;strong&gt;进程切换 Context Switch&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;控制 CPU 的执行顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理机的调度方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非抢占式&lt;/li&gt;
&lt;li&gt;抢占式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择调度算法的若干准则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CPU利用率&lt;/p&gt;
$$
     \frac{\text{worktime of CPU}}{\text{total time}}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统吞吐量&lt;/p&gt;
$$
     \frac{\text{number of tasks}}{\text{total time}}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;周转时间(Turnaround Time)&lt;/p&gt;
$$
     \text{Completion Time - Arrival Time}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均周转时间&lt;/p&gt;
$$
     \frac{\sum\limits_{N}\text{Turnaround Time of all processes}}{N}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;带权周转时间&lt;/p&gt;
$$
     \frac{\text{Turnaround Time}}{\text{Service Time}}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均带权周转时间&lt;/p&gt;
$$
     \frac{\sum\limits_{N}\text{Weighted Turnaround Time of all processes}}{N}
     $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待时间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;调度算法&#34;&gt;调度算法
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;FCFS（先来先服务）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SJF（最短作业优先）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抢占&lt;/li&gt;
&lt;li&gt;非抢占&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SRTF（最短剩余时间优先）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Priority Scheduling（高优先权优先调度）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抢占&lt;/li&gt;
&lt;li&gt;非抢占&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Highest Response Ratio Next (HRRN)（高响应比有点调度算法）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Round Robin（时间片轮转）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Multilevel Feedback Queue（多级反馈队列调度）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上下文切换&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CPU上下文切换&lt;/li&gt;
&lt;li&gt;系统调用上下文切换&lt;/li&gt;
&lt;li&gt;进程上下文切换
&lt;ul&gt;
&lt;li&gt;用户级&lt;/li&gt;
&lt;li&gt;系统级&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程上下文切换&lt;/li&gt;
&lt;li&gt;中断上下文切换&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号:012-015&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;数据结构-致敬传奇栈帧pc程序计数器&#34;&gt;数据结构-致敬传奇栈帧PC程序计数器
&lt;/h2&gt;&lt;h3 id=&#34;栈&#34;&gt;栈
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;静态顺序栈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判空&lt;/li&gt;
&lt;li&gt;判满&lt;/li&gt;
&lt;li&gt;进栈&lt;/li&gt;
&lt;li&gt;出栈&lt;/li&gt;
&lt;li&gt;获取栈顶元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态顺序栈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判空&lt;/li&gt;
&lt;li&gt;判满&lt;/li&gt;
&lt;li&gt;进栈&lt;/li&gt;
&lt;li&gt;出栈&lt;/li&gt;
&lt;li&gt;获取栈顶元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链栈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判空&lt;/li&gt;
&lt;li&gt;判满&lt;/li&gt;
&lt;li&gt;进栈&lt;/li&gt;
&lt;li&gt;出栈&lt;/li&gt;
&lt;li&gt;获取栈顶元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;栈的应用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;括号匹配&lt;/li&gt;
&lt;li&gt;进制转换（辗转相除）&lt;/li&gt;
&lt;li&gt;函数递归调用&lt;/li&gt;
&lt;li&gt;表达式求值
&lt;ul&gt;
&lt;li&gt;前缀&lt;/li&gt;
&lt;li&gt;中缀（重要）&lt;/li&gt;
&lt;li&gt;后缀&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号：014-017&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;数学-太好了是张宇老师我们有救了&#34;&gt;数学-太好了是张宇老师我们有救了！
&lt;/h2&gt;&lt;h3 id=&#34;函数的概念与特性&#34;&gt;函数的概念与特性
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;函数&lt;/li&gt;
&lt;li&gt;反函数&lt;/li&gt;
&lt;li&gt;复合函数&lt;/li&gt;
&lt;li&gt;隐函数&lt;/li&gt;
&lt;li&gt;函数的四种特性
&lt;ul&gt;
&lt;li&gt;有界性&lt;/li&gt;
&lt;li&gt;单调性&lt;/li&gt;
&lt;li&gt;奇偶性&lt;/li&gt;
&lt;li&gt;周期性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基本初等函数与初等函数
&lt;ul&gt;
&lt;li&gt;常函数&lt;/li&gt;
&lt;li&gt;幂函数&lt;/li&gt;
&lt;li&gt;指数函数&lt;/li&gt;
&lt;li&gt;对数函数&lt;/li&gt;
&lt;li&gt;三角函数
&lt;ol&gt;
&lt;li&gt;sin x  cos x&lt;/li&gt;
&lt;li&gt;csc x sec x&lt;/li&gt;
&lt;li&gt;tan x cot x&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;反三角函数
&lt;ol&gt;
&lt;li&gt;arcsin x arccos x&lt;/li&gt;
&lt;li&gt;arctanx arccot x&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分段函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;高数第一讲&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0713学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0713/</link>
        <pubDate>Sun, 13 Jul 2025 23:27:16 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0713/</guid>
        <description>&lt;h2 id=&#34;数据结构-喜欢在头指针存数据的扣1&#34;&gt;数据结构-喜欢在头指针存数据的扣1
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;线性表的链式存储&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单链表&lt;/li&gt;
&lt;li&gt;静态链表&lt;/li&gt;
&lt;li&gt;其他链表
&lt;ul&gt;
&lt;li&gt;单向循环链表&lt;/li&gt;
&lt;li&gt;双向链表&lt;/li&gt;
&lt;li&gt;双向循环链表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程代码010-013&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;操作系统-谦让是美德&#34;&gt;操作系统-谦让是美德
&lt;/h2&gt;&lt;h3 id=&#34;进程与线程&#34;&gt;进程与线程
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;进程的特点：
&lt;ul&gt;
&lt;li&gt;动态性&lt;/li&gt;
&lt;li&gt;并发性&lt;/li&gt;
&lt;li&gt;独立性&lt;/li&gt;
&lt;li&gt;异步性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程的基本状态及管理切换
&lt;ul&gt;
&lt;li&gt;运行&lt;/li&gt;
&lt;li&gt;阻塞&lt;/li&gt;
&lt;li&gt;就绪&lt;/li&gt;
&lt;li&gt;创建&lt;/li&gt;
&lt;li&gt;终止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;线程的特性&lt;/li&gt;
&lt;li&gt;线程的状态&lt;/li&gt;
&lt;li&gt;线程与进程的联系和不同&lt;/li&gt;
&lt;li&gt;用户级线程与内核级线程的映射关系&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;互斥与同步&#34;&gt;互斥与同步
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;临界区实现互斥的原则&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;空闲让进&lt;/li&gt;
&lt;li&gt;忙则等待&lt;/li&gt;
&lt;li&gt;有限等待&lt;/li&gt;
&lt;li&gt;让权等待（非必须）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;临界区实现互斥的基本方法&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;软件实现方法
&lt;ol&gt;
&lt;li&gt;单标志法&lt;/li&gt;
&lt;li&gt;双标志法
&lt;ul&gt;
&lt;li&gt;先检查法&lt;/li&gt;
&lt;li&gt;后检查法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Peterson算法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;硬件实现方法
&lt;ol&gt;
&lt;li&gt;中断屏蔽&lt;/li&gt;
&lt;li&gt;TestAndSet指令&lt;/li&gt;
&lt;li&gt;Swap指令&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;互斥锁（mutex lock）&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;LockOne类&lt;/li&gt;
&lt;li&gt;LockTwo类&lt;/li&gt;
&lt;li&gt;Peterson锁&lt;/li&gt;
&lt;li&gt;Barkley锁&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;信号量&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;整型信号量&lt;/li&gt;
&lt;li&gt;记录型信号量&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;管程&#34;&gt;管程
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;管程的定义&lt;/li&gt;
&lt;li&gt;管程的组成&lt;/li&gt;
&lt;li&gt;管程的特性&lt;/li&gt;
&lt;li&gt;管程与进程的异同&lt;/li&gt;
&lt;li&gt;条件变量&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;进程通信&#34;&gt;进程通信
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;管道通信&lt;/li&gt;
&lt;li&gt;消息传递系统&lt;/li&gt;
&lt;li&gt;共享存储器系统&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号005-011&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0713学习笔记</title>
        <link>http://localhost:1313/npee_learning_log.github.io/memo/0713/</link>
        <pubDate>Sun, 13 Jul 2025 23:27:16 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/memo/0713/</guid>
        <description>&lt;p&gt;今天看来是无法解决所有当下的疑问了，故先列出清单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是用户级线程和内核级线程？&lt;/li&gt;
&lt;li&gt;PCB都包含什么？&lt;/li&gt;
&lt;li&gt;访管中断和自陷指令有和关系？&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0712学习笔记</title>
        <link>http://localhost:1313/npee_learning_log.github.io/memo/0712/</link>
        <pubDate>Sat, 12 Jul 2025 23:17:40 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/memo/0712/</guid>
        <description>&lt;h2 id=&#34;操作系统&#34;&gt;操作系统
&lt;/h2&gt;&lt;h3 id=&#34;系统调用&#34;&gt;系统调用
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;功能
&lt;ul&gt;
&lt;li&gt;设备管理：设备的启动、请求和释放等。&lt;/li&gt;
&lt;li&gt;文件管理：文件的读写、创建和删除等。&lt;/li&gt;
&lt;li&gt;进程管理：进程的创建、撤销、阻塞和唤醒等。&lt;/li&gt;
&lt;li&gt;进程通信：进程之间的消息或信号的传递等。&lt;/li&gt;
&lt;li&gt;内存管理：内存的分配、回收以及获取作业占用内存区大小和起始地址等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理过程
&lt;ol&gt;
&lt;li&gt;用户程序将系统调用号和所需的参数压入堆栈；接着，调用实际的调用指令，然后执行一个陷入指令，将CPU从用户态转为核心态；再由硬件和操作系统内核程序保护被中断进程的现场。将程序计数器PC、程序状态字PSW及通用寄存器内容压入堆栈。&lt;/li&gt;
&lt;li&gt;分析系统调用类型，转入相应的系统调用处理子程序。在系统中配置了一张系统调用入口表，表中的每个表项都对应一个系统调用，根据系统调用号找到该系统调用处理子程序的入口地址。&lt;/li&gt;
&lt;li&gt;在系统调用处理子程序执行结束后，恢复被中断的或设置新进程的CPU现场，然后返回被中断进程或新进程，继续往下执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0712学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0712/</link>
        <pubDate>Sat, 12 Jul 2025 22:05:39 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0712/</guid>
        <description>&lt;h2 id=&#34;操作系统-int-0x80&#34;&gt;操作系统-int 0x80
&lt;/h2&gt;&lt;p&gt;操作系统的运行环境&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内核程序
&lt;ul&gt;
&lt;li&gt;特权指令&lt;/li&gt;
&lt;li&gt;核心态，管态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用程序
&lt;ul&gt;
&lt;li&gt;非特权指令&lt;/li&gt;
&lt;li&gt;用户态，目态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;操作系统的内核&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;时钟管理&lt;/li&gt;
&lt;li&gt;中断机制
&lt;ol&gt;
&lt;li&gt;内部异常
&lt;ol&gt;
&lt;li&gt;故障（Fault）（软件中断）&lt;/li&gt;
&lt;li&gt;自陷（Trap）（软件中断）&lt;/li&gt;
&lt;li&gt;终止（Abort）（硬件中断）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;外部中断（硬件）
&lt;ol&gt;
&lt;li&gt;可屏蔽中断 INTR&lt;/li&gt;
&lt;li&gt;不可屏蔽中断 NMI&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;课程编号 ：003-004&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;英语-英语构词法&#34;&gt;英语-英语构词法
&lt;/h2&gt;&lt;p&gt;前缀包含两种作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;方向&lt;/li&gt;
&lt;li&gt;性质&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;后缀一般表示词性，例外：able,&amp;hellip;.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>0711学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0711/</link>
        <pubDate>Fri, 11 Jul 2025 20:29:14 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0711/</guid>
        <description>&lt;h2 id=&#34;数据结构-太好了是死记硬背&#34;&gt;数据结构-太好了是死记硬背
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数据的逻辑和物理结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/npee_learning_log.github.io/posts/0711/QQ20250711-202720.png&#34;
	width=&#34;1702&#34;
	height=&#34;743&#34;
	srcset=&#34;http://localhost:1313/npee_learning_log.github.io/posts/0711/QQ20250711-202720_hu_ab8a865d16a46851.png 480w, http://localhost:1313/npee_learning_log.github.io/posts/0711/QQ20250711-202720_hu_5cae573c8a98f94d.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;229&#34;
		data-flex-basis=&#34;549px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算法的时间空间复杂度&lt;/li&gt;
&lt;li&gt;线性表的顺序表以及相关算法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;课程编号001-009&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;操作系统-想念jyy的第n天&#34;&gt;操作系统-想念jyy的第n天
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;操作系统概述
&lt;ul&gt;
&lt;li&gt;并发&lt;/li&gt;
&lt;li&gt;共享&lt;/li&gt;
&lt;li&gt;虚拟&lt;/li&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统的发展历程
&lt;ul&gt;
&lt;li&gt;批处理器
&lt;ul&gt;
&lt;li&gt;单道&lt;/li&gt;
&lt;li&gt;多道&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分时操作系统&lt;/li&gt;
&lt;li&gt;实时操作系统&lt;/li&gt;
&lt;li&gt;网络操作系统&lt;/li&gt;
&lt;li&gt;分布式操作系统&lt;/li&gt;
&lt;li&gt;&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;课程编号001-002&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
