<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>查找 on shyの考研日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/tags/%E6%9F%A5%E6%89%BE/</link>
        <description>Recent content in 查找 on shyの考研日志</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 13 Aug 2025 09:45:30 +0800</lastBuildDate><atom:link href="http://localhost:1313/npee_learning_log.github.io/tags/%E6%9F%A5%E6%89%BE/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>0813错题笔记</title>
        <link>http://localhost:1313/npee_learning_log.github.io/memo/0813/</link>
        <pubDate>Wed, 13 Aug 2025 09:45:30 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/memo/0813/</guid>
        <description>&lt;h2 id=&#34;数据结构&#34;&gt;数据结构
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;采用开放定址法解决冲突的散列查找中，发生聚集的主要原因是：&lt;strong&gt;解决冲突的办法选择不当&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对于任意n个关键字排序的比较次数至少为$\lceil \log_2{(n!)}\rceil$。&lt;/li&gt;
&lt;li&gt;折半插入虽然改进了搜索时间，但是移动次数相较于直接插入排序没有变化，其时间复杂度仍然是$O(n^2)$&lt;/li&gt;
&lt;li&gt;快速排序的空间复杂度平均为$O(\log_2 n)$，最坏情况为$O(n)$，这是递归的形式。但似乎考试默认是递归栈的空间？&lt;/li&gt;
&lt;li&gt;倘若要对某个进制的整数进行基数排序，那么队列的个数等于进制数，即十进制有10个队列，八进制有8个队列。&lt;/li&gt;
&lt;li&gt;对于同等大小的不同初始序列，&lt;strong&gt;折半插入排序、简单选择排序&lt;/strong&gt;总比较次数一定，特别是&lt;strong&gt;折半插入排序&lt;/strong&gt;，需要特别注意。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>0809学习日志</title>
        <link>http://localhost:1313/npee_learning_log.github.io/posts/0809/</link>
        <pubDate>Sat, 09 Aug 2025 23:52:51 +0800</pubDate>
        
        <guid>http://localhost:1313/npee_learning_log.github.io/posts/0809/</guid>
        <description>&lt;h2 id=&#34;数据结构-查找&#34;&gt;数据结构-查找
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;顺序查找法&lt;/li&gt;
&lt;li&gt;分块查找法（索引顺序查找）&lt;/li&gt;
&lt;li&gt;折半查找法
&lt;ul&gt;
&lt;li&gt;判定树&lt;/li&gt;
&lt;li&gt;ASL（平均查找长度）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二叉搜索树
&lt;ol&gt;
&lt;li&gt;查找&lt;/li&gt;
&lt;li&gt;插入&lt;/li&gt;
&lt;li&gt;构造&lt;/li&gt;
&lt;li&gt;删除（中序）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;平衡二叉树（AVL）
&lt;ol&gt;
&lt;li&gt;插入
&lt;ul&gt;
&lt;li&gt;LL平衡旋转&lt;/li&gt;
&lt;li&gt;LR平衡旋转&lt;/li&gt;
&lt;li&gt;RR平衡旋转&lt;/li&gt;
&lt;li&gt;RL平衡旋转&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;构造&lt;/li&gt;
&lt;li&gt;删除&lt;/li&gt;
&lt;li&gt;查找&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;红黑树
&lt;ol&gt;
&lt;li&gt;定义
&lt;ul&gt;
&lt;li&gt;每个结点或是黑色或是红色&lt;/li&gt;
&lt;li&gt;根节点是黑色的&lt;/li&gt;
&lt;li&gt;叶节点（虚构的外部节点、NULL节点）都是黑色&lt;/li&gt;
&lt;li&gt;不存在两个相邻的红节点&lt;/li&gt;
&lt;li&gt;对于每个结点，从该结点到任意一个叶节点的简单路径上，所含黑节点的数量相同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结论
&lt;ol&gt;
&lt;li&gt;从根到叶结点的最长路径不大于最短路径的2倍&lt;/li&gt;
&lt;li&gt;有n个内部结点的红黑树的高度$h\leq 2\log_2{(n+1)}$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;插入
&lt;ul&gt;
&lt;li&gt;新插入红黑树的结点初始着为红色&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除*&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
    </channel>
</rss>
