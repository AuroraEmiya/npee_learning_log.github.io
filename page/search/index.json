[{"content":"操作系统-一些易错知识点 在计算平均访存时间时要注意快表TLB和页表的访问是串行还是并行的，也要注意页表是单级还是多级的 虚拟存储器的最大容量只和计算机的地址结构决定，实际容量和内存和外存有关 工作集不是驻留集的子集，只是数量要小于（不大于）驻留集的大小 一些你需要搞明白的概念：\n链接，包括静态和动态\n链接是将不同编译单元及其依赖库整合到一个统一逻辑地址空间的过程。根据发生时间不同，链接分为：\n静态链接：在编译阶段将所有代码打包进可执行文件中； 动态链接： 加载时链接（Load-Time Linking）：程序加载时操作系统自动加载依赖库； 运行时链接（Run-Time Linking）：程序运行过程中手动加载库，例如通过 dlopen() 等函数调用。 类别 链接时间 控制方式 示例函数 静态链接 编译/链接阶段 编译器自动处理 - 动态链接（加载时） 程序加载阶段 操作系统自动处理 - 动态链接（运行时） 程序运行阶段 程序员手动调用 dlopen, dlsym 等 $\u0026gt;dive into the procedure of linking of a C code program(Gemini 2.5 pro)\nThe Final Step: Unraveling the Linking Process of a C Program The journey from human-readable C code to an executable program culminates in a crucial, often-overlooked stage: linking. This final step in the compilation process is where all the disparate pieces of your program are brought together to create a single, functional executable file. The linker, a key component of the C toolchain, orchestrates this assembly, resolving references between different parts of your code and incorporating necessary library functions.\nThe compilation of a C program is a multi-stage process. First, the preprocessor handles directives like #include and #define. The preprocessed code is then compiled into assembly language, which is subsequently converted into machine-readable object files. These object files, however, are not yet ready to run. They are incomplete pieces of a larger puzzle, and it is the linker\u0026rsquo;s job to put them together.\nThe primary role of the linker is to take one or more object files, along with any necessary libraries, and combine them into a single executable file. A key function of the linker is symbol resolution. When you call a function in one C file that is defined in another, the compiler leaves a placeholder, or a reference, in the object file. The linker\u0026rsquo;s job is to find the actual memory address of that function in the other object file and replace the placeholder with this address. This ensures that when the program runs, the function call correctly jumps to the right location in memory.\nStatic vs. Dynamic Linking: Two Approaches to Integration There are two fundamental ways a linker can incorporate external code into your program: static linking and dynamic linking.\nStatic Linking: In this approach, all the required library code is copied directly into the final executable file. This creates a self-contained program that does not rely on external libraries to be present on the system where it is run.\nAdvantages of Static Linking:\nPortability: The executable can be run on systems that do not have the required libraries installed. Potentially Faster Execution: Since all the code is in one place, it can sometimes lead to faster execution as there is no need to load external libraries at runtime. Disadvantages of Static Linking:\nLarger Executable Size: Because all library code is included, the resulting executable file is larger. Inefficient Memory and Disk Space Usage: If multiple programs on a system use the same statically linked library, each will have its own copy, leading to redundant use of disk space and memory. Difficult to Update: To update a library, every program that uses it must be re-linked. Dynamic Linking: In contrast, dynamic linking does not copy the library code into the executable. Instead, it only includes the names of the shared libraries that the program needs. The actual linking of the library code happens at runtime when the program is loaded into memory.\nAdvantages of Dynamic Linking:\nSmaller Executable Size: The executables are smaller as they only contain references to the shared libraries. Efficient Memory and Disk Space Usage: A single copy of a shared library in memory can be used by multiple programs. Easier Updates: To update a library, you only need to replace the shared library file; all programs that use it will automatically benefit from the update without needing to be re-linked. Disadvantages of Dynamic Linking:\nDependencies: The program will not run if the required shared libraries are not present on the system or if the version is incompatible. Slightly Slower Startup: There can be a minor performance overhead at startup as the dynamic linker needs to find and load the necessary shared libraries. The Linking Process in Action with GCC The GNU Compiler Collection (GCC) is a popular toolchain for compiling and linking C programs. The linking process can be performed as a separate step or combined with compilation.\nTo compile a C source file (.c) into an object file (.o), you can use the -c flag with gcc:\ngcc -c my_program.c This will create an object file named my_program.o. If your program is split across multiple source files, you would compile each one into an object file.\nOnce you have all the necessary object files, you can link them together to create an executable file using the -o flag to specify the output file name:\ngcc -o my_executable my_program.o another_file.o This command tells gcc to link my_program.o and another_file.o and create an executable file named my_executable.\nCommon Linker Errors Errors that occur during the linking phase are known as linker errors. Some of the most common linker errors include:\nUndefined Symbol/Undefined Reference: This is the most frequent linker error. It occurs when the linker cannot find the definition for a function or variable that has been declared and used in the code. This often happens when you forget to link an object file that contains the definition or mistype a function name. Multiple Definitions: This error arises when the linker finds more than one definition for the same function or variable. This can happen if you define a function in a header file that gets included in multiple source files or if you link the same object file multiple times. In conclusion, the linking process is the essential final act in the creation of a C program. By understanding how the linker works, the differences between static and dynamic linking, and how to use tools like gcc to control the linking process, developers can gain a deeper insight into how their code is transformed into a runnable application and more effectively troubleshoot common errors.\n$\u0026gt;are there different categories of dynamic linking technique?(Gemini 2.5 pro)\nYes, there are different categories of dynamic linking techniques, each with its own timing and mechanism for connecting a program to the shared libraries it needs. The main distinctions lie in when the linking happens and who initiates it.\nHere\u0026rsquo;s a breakdown of the primary categories of dynamic linking:\n1. Load-Time Dynamic Linking (Implicit Linking) This is the most common form of dynamic linking. When you compile and link your program against a shared library, the linker embeds references to that library directly into the executable file.\nHow it works:\nAt compile time: The linker records the names of the shared libraries the program depends on and the symbols (functions and variables) it uses from them. At load time: When you run the executable, the operating system\u0026rsquo;s program loader (also known as the dynamic linker or runtime linker) reads this dependency information. It then locates the necessary shared libraries on the system, loads them into the process\u0026rsquo;s address space, and resolves all the symbol references before the program\u0026rsquo;s main function begins to execute. Key Characteristics:\nAutomatic: The entire process is handled automatically by the operating system. Dependencies are required at startup: If any of the required shared libraries are missing or incompatible, the program will fail to start. Slight startup overhead: There is a small performance cost at program launch while the dynamic linker does its work. 2. Run-Time Dynamic Linking (Explicit Linking or Dynamic Loading) This technique gives the programmer more control over the linking process. Instead of the operating system automatically loading libraries at startup, the program itself can explicitly load and unload libraries at any point during its execution.\nHow it works:\nProgrammatic Control: The program uses specific API calls (like dlopen(), dlsym(), and dlclose() on POSIX systems, or LoadLibrary(), GetProcAddress(), and FreeLibrary() on Windows) to manage shared libraries. dlopen() or LoadLibrary(): Loads a specified library into memory. dlsym() or GetProcAddress(): Retrieves the address of a specific function or variable within the loaded library. dlclose() or FreeLibrary(): Unloads the library from memory. Key Characteristics:\nFlexibility: Programs can decide which libraries to load based on runtime conditions. This is the foundation for a \u0026ldquo;plugin\u0026rdquo; architecture, where new functionality can be added to a running application by loading new shared libraries. No startup dependency: The program can start even if the optional libraries are not present. It can then check for their availability and load them if needed. More complex to implement: The programmer is responsible for managing the loading, symbol lookup, and unloading of libraries, which requires more code and error handling. A Special Case: Lazy Linking Lazy linking is an optimization often used with load-time dynamic linking to improve program startup time.\nHow it works:\nInstead of resolving all function addresses when the program is first loaded, the dynamic linker defers the resolution of each function until it is actually called for the first time. The first time a function in a shared library is called, a small piece of code (a \u0026ldquo;trampoline\u0026rdquo; or \u0026ldquo;stub\u0026rdquo;) in the program\u0026rsquo;s Procedure Linkage Table (PLT) transfers control to the dynamic linker. The dynamic linker then looks up the real address of the function, patches the PLT entry to point directly to it, and then calls the function. Subsequent calls to that same function will then go directly to the function\u0026rsquo;s address without involving the dynamic linker, resulting in minimal overhead. Key Characteristics:\nFaster startup: By avoiding the upfront cost of resolving every single function, the program can start executing more quickly. Minimal overhead on first call: There is a small performance penalty the very first time each dynamically linked function is called. Transparent to the developer: This is typically a default behavior of the dynamic linker and doesn\u0026rsquo;t require any special coding by the programmer. In essence, while load-time and run-time dynamic linking are the two main strategies, lazy linking is a common optimization that fine-tunes the performance of load-time linking. The choice between these techniques depends on the specific needs of the application, balancing ease of use, startup performance, and the flexibility to load code on demand.\n卡特兰数，用于计算给定输入栈序列，所有可能的输出排列 $$ \\frac{1}{n+1}\\binom{2n}{n}=\\frac{2n!}{(n+1)!n!} $$ 英语-单词（词根词缀分开） a vail mock gigantic zoom speci fication pa nel pre mise sovereign utter deem mono poly spec ulate con form ","date":"2025-07-26T11:19:57+08:00","permalink":"https://auroraemiya.github.io/npee_learning_log.github.io/memo/0726/","title":"0726学习笔记"},{"content":"操作系统-易错小知识 在多个进程并发执行时，所有进程的页表大多数驻留在内存中，在系统中只设置一个页表寄存器（PTR），它存放页表在内存中的始址和长度 分段方式对低级语言程序员和编译器是可见的，对高级语言程序员是透明的 在这四种动态分区分配算法中，（首次适应，最坏适应，最佳适应，循环首次适应），最佳适应由于其总是会选择和待分配空间“最接近”的空闲区，因此总是会产生难以利用的小的内存块。 [tips]页表项的数量最好刚好填满一整个页 数学-数列极限 一个积分小技巧,似乎跟傅里叶级数有关系，但是我没看出来（插个眼） $$ \\begin{align*} \\int_{0}^{\\frac{\\pi}{2}}{\\sin^{n+1} t \\text{d} t} \u0026= \\left.(-\\sin^nt\\cdot \\cos t)\\right|_{0}^{\\frac{\\pi}{2}} - \\int_{0}^{\\frac{\\pi}{2}}{-\\cos t \\text{d} \\sin^n t}\\\\ \u0026=n\\int_{0}^{\\frac{\\pi}{2}}{\\cos^2 t \\sin^{n-1} \\text{d} t}\\\\ \u0026=n\\int_{0}^{\\frac{\\pi}{2}}{(1-\\sin^2t) \\sin^{n-1} \\text{d} t}\\\\ \\\\ \\int_{0}^{\\frac{\\pi}{2}}{\\sin^{n+1} t \\text{d} t}\u0026=\\frac{n}{n+1}\\int_{0}^{\\frac{\\pi}{2}}{\\sin^{n-1} t \\text{d} t} \\end{align*} $$ 英语-即使是认识的单词也有不认识的词根词缀 ac company mono poly di lute trans action re sent con temporary spec u late in cur im plement pro ce dure ","date":"2025-07-25T20:24:54+08:00","permalink":"https://auroraemiya.github.io/npee_learning_log.github.io/memo/0725/","title":"0725学习笔记"},{"content":"数学-1000题 对于$x_{n+1}=f(x_n)$的数列极限的判定的过程 单调有界 拉格朗日中值定理 放缩 对于行列式的计算的方法 上下三角行列式 反三角行列式 范德蒙德行列式 递推 归纳 英语-不背单词 twist\nultimate\nstrike\ncrucial\nsubordinate\nanguish\nsubtle\nconstitute\nsuffice\neminent\nprudent\ncourtesy\nharsh\nindispensable\n","date":"2025-07-23T23:53:15+08:00","permalink":"https://auroraemiya.github.io/npee_learning_log.github.io/posts/0723/","title":"0723学习日志"},{"content":"操作系统- (LA-PA-CA) 带快表的两级系统的地址翻译过程 从逻辑地址映射到物理地址（虚拟存储器） 从物理地址映射到Cache地址（主存-Cache系统） 文件和文件系统 构成文件的基本单位 文件的定义 文件属性 文件的基本操作 文件的打开和关闭的操作 文件的逻辑结构 目录管理 目录的概念 文件控制块和索引节点 目录结构 英语-VocabularyBuilder CRIM,comes from the Latin words for \u0026ldquo;fault or crime\u0026rdquo; or \u0026ldquo;accusation.\u0026rdquo; criminology decriminalize incriminate recrimination PROB,comes from the Latin words for \u0026ldquo;prove or proof \u0026ldquo;and \u0026ldquo;honesy or integrity.\u0026rdquo; approbation probate probity reprobate GRAV, comes from the Latin word meaning \u0026ldquo;heavy ,weighty ,serious\u0026rdquo; grave gravitas gravitate aggravate LEV,comes from the Latin adjective $levis$,meaning \u0026ldquo;light\u0026rdquo;,and the verb $levare$,meaning \u0026ldquo;to raise or lighten.\u0026rdquo; alleviate elevation contilever levity 数学-行列式 行列式的本质定义\n行列式的性质\n$|A|=|A^T|$ 若行列式中某行(列)元素全为零，则行列式为零\n若行列式中某行(列) 元素有公因子$k\\neq0$，则$k$可提到行列式外面\n行列式中某行(列)元素均是两个数之和，则可拆成两个行列式之和\n行列式中两行(列)互换，行列式变号\n行列式中的两行(列)元素相等或对应成比例，则行列式为零\n行列式的逆序法定义 $$ \\begin{vmatrix} a_{11} \u0026 a_{12} \u0026 \\cdots\u0026a_{1n}\\\\ a_{21} \u0026 a_{22} \u0026 \\cdots\u0026a_{2n}\\\\ \\vdots \u0026 \\vdots \u0026 \u0026\\vdots\\\\ a_{n1} \u0026 a_{n2} \u0026 \\cdots\u0026a_{nn}\\\\ \\end{vmatrix}=\\sum\\limits_{j_1j_2\\cdots j_n}{(-1)^{\\tau(j_1j_2\\cdots j_n)}}a_{j_1}a_{j_2}\\cdots a_{j_n} $$ 行列式的展开定理 $$ |A| = \\sum\\limits_{j=1}^na_{ij}A_{ij} $$ 几个重要的行列式\n主对角线行列式(上(下)三角形行列式) $$ \\begin{vmatrix} a_{11} \u0026 a_{12} \u0026 \\cdots\u0026a_{1n}\\\\ 0 \u0026 a_{22} \u0026 \\cdots\u0026a_{2n}\\\\ \\vdots \u0026 \\vdots \u0026 \u0026\\vdots\\\\ 0 \u0026 0 \u0026 \\cdots\u0026a_{nn}\\\\ \\end{vmatrix}=\\begin{vmatrix} a_{11} \u0026 0 \u0026 \\cdots\u00260\\\\ a_{21} \u0026 a_{22} \u0026 \\cdots\u00260\\\\ \\vdots \u0026 \\vdots \u0026 \u0026\\vdots\\\\ a_{n1} \u0026 a_{n2} \u0026 \\cdots\u0026a_{nn}\\\\ \\end{vmatrix}=\\begin{vmatrix} a_{11} \u0026 0 \u0026 \\cdots\u00260\\\\ 0 \u0026 a_{22} \u0026 \\cdots\u00260\\\\ \\vdots \u0026 \\vdots \u0026 \u0026\\vdots\\\\ 0 \u0026 0 \u0026 \\cdots\u0026a_{nn}\\\\ \\end{vmatrix}=\\prod\\limits_{i=1}^n a_{ii} $$ 副对角线行列式 $$ \\begin{vmatrix} a_{11} \u0026 \\cdots \u0026 a_{1,n-1}\u0026a_{1n}\\\\ a_{21} \u0026 \\cdots \u0026 a_{2,n-1}\u00260\\\\ \\vdots \u0026 \u0026\\vdots \u0026\\vdots\\\\ a_{n1} \u0026\\cdots\u00260 \u00260\\\\ \\end{vmatrix}=\\begin{vmatrix} 0 \u0026 \\cdots \u0026 0\u0026a_{1n}\\\\ 0 \u0026\\cdots \u0026 a_{2,n-1}\u0026a_{2n}\\\\ \\vdots \u0026 \u0026 \\vdots \u0026\\vdots\\\\ a_{n1} \u0026\\cdots \u0026 a_{n,n-1}\u0026a_{nn}\\\\ \\end{vmatrix}=\\begin{vmatrix} 0 \u0026 \\cdots \u0026 0\u0026a_{1n}\\\\ 0 \u0026 \\cdots \u0026 a_{2,n-1}\u00260\\\\ \\vdots \u0026 \u0026 \\vdots\u0026\\vdots\\\\ a_{n1} \u0026 \\cdots \u0026 0\u00260\\\\ \\end{vmatrix}=(-1)^{\\frac{n(n-1)}{2}}\\prod\\limits_{i=1}^n a_{i(n+1-i)} $$ 拉普拉斯展开式($A\\in R^{m\\times m},B\\in R^{n\\times n}$) $$ \\begin{vmatrix} A\u0026O\\\\ O\u0026B \\end{vmatrix}=\\begin{vmatrix} A\u0026C\\\\ O\u0026B \\end{vmatrix}=\\begin{vmatrix} A\u0026O\\\\ C\u0026B \\end{vmatrix}=|A||B| $$$$ \\begin{vmatrix} O\u0026A\\\\ B\u0026O \\end{vmatrix}=\\begin{vmatrix} C\u0026A\\\\ B\u0026O \\end{vmatrix}=\\begin{vmatrix} O\u0026A\\\\ B\u0026C \\end{vmatrix}=(-1)^{mn}|A||B| $$ 范德蒙德行列式,$(1\\leq i \u0026lt;j\\leq n)$ $$ \\begin{vmatrix} 1\u00261\u0026\\cdots\u00261\\\\ x_1\u0026x_2\u0026\\cdots\u0026x_n\\\\ x_1^2\u0026x_2^2\u0026\\cdots\u0026x_n^2\\\\ \\vdots\u0026\\vdots\u0026\u0026\\vdots\\\\ x_1^n\u0026x_2^n\u0026\\cdots\u0026x_n^n \\end{vmatrix}=\\prod\\limits_{i,j}{(x_i-x_j)} $$ ","date":"2025-07-22T23:31:50+08:00","permalink":"https://auroraemiya.github.io/npee_learning_log.github.io/posts/0722/","title":"0722学习日志"},{"content":"数据结构-代码(待完善) 栈的定义\nstack.h #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #define STATIC_STACK #define DYNAMIC_STACK #define DATATYPE void * #ifdef STATIC_STACK #define STACK_H 100 typedef struct StaticStack { DATATYPE stack[STACK_H]; int max_depth; int top; } StaticStack; bool initialize_static_stack(StaticStack * s); bool static_stack_push(StaticStack *s, DATATYPE value); bool static_stack_pop(StaticStack *s, DATATYPE *value); bool static_stack_top(StaticStack *s, DATATYPE *value); #endif #ifdef DYNAMIC_STACK typedef struct DynamicStack { DATATYPE data; DynamicStack *next; } DynamicStack; //returns a top-pointer to a new dynamic stack DynamicStack *initialize_dynamic_stack(); bool dynamic_stack_push(DynamicStack *top, DATATYPE value); bool dynamic_stack_pop(DynamicStack *top, DATATYPE *value); bool dynamic_stack_top(DynamicStack *top, DATATYPE *value); #endif stack.c #include \u0026#34;stack.h\u0026#34; #ifdef STATIC_STACK bool initialize_static_stack(StaticStack * s) { s-\u0026gt;top = -1; s-\u0026gt;max_depth = STACK_H; // Initialize depth to 0 return true; } bool static_stack_push(StaticStack *s, DATATYPE value) { if (s-\u0026gt;top \u0026gt;= s-\u0026gt;max_depth - 1) { printf(\u0026#34;Static stack overflow\\n\u0026#34;); return false; // Stack is full } s-\u0026gt;stack[++(s-\u0026gt;top)] = value; return true; } bool static_stack_pop(StaticStack *s, DATATYPE *value) { if (s-\u0026gt;top \u0026lt; 0) { printf(\u0026#34;Static stack underflow\\n\u0026#34;); return false; // Stack is empty } *value = s-\u0026gt;stack[(s-\u0026gt;top)--]; return true; } bool static_stack_top(StaticStack *s, DATATYPE *value) { if (s-\u0026gt;top \u0026lt; 0) { printf(\u0026#34;Static stack is empty\\n\u0026#34;); return false; // Stack is empty } *value = s-\u0026gt;stack[s-\u0026gt;top]; // Get the top value return true; // Successfully retrieved the top value } #endif #ifdef DYNAMIC_STACK DynamicStack *initialize_dynamic_stack() { DynamicStack *new_stack = (DynamicStack *)malloc(sizeof(DynamicStack)); if(new_stack == NULL) { return NULL; // Memory allocation failed }else { new_stack-\u0026gt;next = NULL; return new_stack; } } bool dynamic_stack_push(DynamicStack *top, DATATYPE value) { DynamicStack *new_item = (DynamicStack *)malloc(sizeof(DynamicStack)); if(!new_item) { printf(\u0026#34;Failed to push %d onto dynamic stack\\n\u0026#34;, value); return false; // Memory allocation failed } new_item-\u0026gt;data = value; new_item-\u0026gt;next = top-\u0026gt;next; top-\u0026gt;next = new_item; return true; } bool dynamic_stack_pop(DynamicStack *top, DATATYPE *value) { if(top-\u0026gt;next == NULL) { printf(\u0026#34;Dynamic stack is empty\\n\u0026#34;); return false; // Stack is empty } DynamicStack *temp = top-\u0026gt;next; *value = temp-\u0026gt;data; top-\u0026gt;next = temp-\u0026gt;next; free(temp); return true; } bool dynamic_stack_top(DynamicStack *top, DATATYPE *value) { if(top-\u0026gt;next == NULL) { printf(\u0026#34;Dynamic stack is empty\\n\u0026#34;); return false; // Stack is empty } *value = top-\u0026gt;next-\u0026gt;data; // Get the data from the top item return true; // Successfully retrieved the top value } #endif ","date":"2025-07-21T22:59:30+08:00","permalink":"https://auroraemiya.github.io/npee_learning_log.github.io/memo/0721/","title":"0721学习笔记"},{"content":"英语-vocabulary builder 使用 The Merriam-Webster Vocabulary Builder作为词根法扩充词汇量的工具书(由网友canon提供)\nBENE , latin for well benediction benefactor benefaciary benevolence AM, comes form the latin admare amicable enamored amorous paramour BELL,comes from the latin word meaning war.Bellona was the little-known goddess of war . antebellum belligerence bellicose rebellion PAC,is related to the Latin words for \u0026ldquo;agree\u0026rdquo; and \u0026ldquo;peace\u0026rdquo; pacify pacifist pact pace 操作系统-page \u0026amp; segment 基本分页内存\npage\npage frame page table 页号 页内偏移量 虚拟地址 = 页号 + 页内偏移\nLRU（最近最少使用）\nFIFO（先进先出）\nCLOCK（近似LRU）\nTLB（Translation Lookaside Buffer）\n两级以及多级页表\n基本分段内存管理\n基本原理\n基本结构\n段号 段内地址 段表\n地址变换机制\n虚拟存储器\n页表机制 缺页中断机制 地址变换机制 课程编号：019-021\n数据结构-二叉树 线索二叉树\n定义 构造 遍历 树、森林与二叉树\n相互转换 遍历 哈夫曼树\nWPL 构造 哈夫曼编码 哈夫曼树的特点 并查集\n定义 操作 实现 课程编号：033-037\n","date":"2025-07-21T17:53:02+08:00","permalink":"https://auroraemiya.github.io/npee_learning_log.github.io/posts/0721/","title":"0721学习日志"},{"content":"数学-是不动点的味道 数列的极限 概念 数列极限的定义 数列收敛的性质 唯一性 有界性 保号性 海涅定理（归结原则） 夹逼准则 单调有界准则 ${x_n}$收敛于$a$的速度问题 数据结构-前序中序后序blablabla 树的性质 let $T_m$ denote a tree with degree $m$.\nlet $D(n)$ denote the out degree of the node $x$ in the tree $T_m$.\nlet $n_i$ denote the number of notes with degree $i$.\nlet $H$ denote the depth/height of the tree $T_m$.\nlet $N$ denote the total number of nodes in tree.$N=\\sum\\limits_{i=0}^mn_i$.\nlet $N_i$ denote the number of nodes at layer $i\\in \\mathcal{N^*}$\n$N=1 + \\sum\\limits_{i=1}^mi\\cdot n_i$. $n_0 =1 + \\sum\\limits_{i=2}^m(i-1)\\cdot n_i$ $N_i\\leq m^{i-1}$ if not an empty tree with degree m. $N\\leq \\frac{m^H-1}{m-1}$ $H\\geq \\lceil\\log_{m}\\left((N(m-1))+1\\right)\\rceil$ 二叉树 二叉树的性质 $N_i\\leq 2^{i-1}$ if not an empty tree. $N\\leq 2^H-1$ $n_0 =1 + n_2$ $H\\geq \\lceil\\log_{2}(N+1)\\rceil$ 完全二叉树 满二叉树 二叉树的构造 前序加中序 后序加中序 层次加中序 前序加树形结构 中序加树形结构 后序加树形结构 层次加树形结构 二叉树的遍历 前序 中序 后序 层次 操作系统-nice of linux Multi-Level Feedback Queue (cpu-sched-mlfq) Basic Rules Rule 1:If Priority(A) $\u0026gt;$ Priority(B), A runs (B doesn’t). Rule 2:If Priority(A) $=$ Priority(B), A \u0026amp; B run in RR(Round Robin). However: Those with low Priority will get starved! Therefore: We need to change the Priority over time. To change Priority Rule 3: When a job enters the system, it is placed at the highest priority (the topmost queue). Rule 4a: If a job uses up its allotment while running, its priority is reduced (i.e., it moves down one queue). Rule 4b: If a job gives up the CPU (for example, by performing an I/O operation) before the allotment is up, it stays at the same priority level (i.e., its allotment is reset). However: Those with long cpu-time will get starved as them move down to the lowest! Those with smart heart will game the scheduler as they I/O at the last ms of the allotment. Therefore: We need to change rule4a,b and boost periodically. The Priority Boost Rule 5: After some time period S, move all the jobs in the system to the topmost queue. Better Accounting Rule 4: Once a job uses up its time allotment at a given level (re gardless of how many times it has given up the CPU), its priority is reduced (i.e., it moves down one queue). Proportional share(cpu-sched-lottery) Basic Concept: Tickets Represent Your Share Stride Scheduling The Linux Completely Fair Scheduler (CFS) ","date":"2025-07-19T22:41:19+08:00","permalink":"https://auroraemiya.github.io/npee_learning_log.github.io/posts/0719/","title":"0719学习日志"},{"content":"数学 若$\\lim\\limits_{x\\to0}f(x) = A\\neq0,\\lim\\limits_{x\\to0}h(x)=0$,且在$x\\to 0$时，$h(x)\\neq 0$,则 $$ \\int^{h(x)}_0f(t)dt\\sim Ah(x),(x\\to0) $$ 当$x\\to 0$时，$f(x) \\sim ax^m,g(x)\\sim bx^n,ab\\neq0,m,n\\in N^*$,则 $$ \\int^{g(x)}_0f(t)dt\\sim \\int^{bx^n}_0at^mdt,(x\\to0) $$ 以$\\frac{x}{\\cos x} $为例计算分式的泰勒展开： $$ \\cos x = 1 - \\frac{1}{2!}x^2 + \\frac{1}{4!}x^4 + ... $$ 随着对分子和分母进行多项式除法，取需要的项即可\n时不时看看这道题： $$ \\lim\\limits_{x\\to0}\\frac{\\int_{0}^{x}{[e^{{(t-x)}^2}-1]\\sin t}\\text{d} t}{x ^2(e^{x^2}-1)} $$ ","date":"2025-07-18T19:23:00+08:00","permalink":"https://auroraemiya.github.io/npee_learning_log.github.io/memo/0718/","title":"0718学习笔记"},{"content":"关于数学，cool stuff 首先，泰勒吧\n设$f(x)$在点$x=0$处$n$阶可导，则存在$x=0$的一个领域，对于该领域内的任一点$x$，有\n$$ f(x) = f(0) + f{'}(0)x + \\frac{f^{''}(0)}{2!}x^2 + \\frac{f^{'''}(0)}{3!}x^3 + ...+ \\frac{f^{(n)}(0)}{n!}x^n + o(x^n) $$ 其次，记住吧\n一些食品级的等价无穷小\n$x-\\sin{x}\\sim\\frac{1}{6}x^3,(x\\to 0)$ $\\text{arcsin}x-x\\sim\\frac{1}{6}x^3,(x\\to 0)$ $x-\\text{arctan}x\\sim\\frac{1}{3}x^3,(x\\to 0)$ $\\tan{x}-x\\sim\\frac{1}{3}x^3,(x\\to 0)$ 一些重要的泰勒展开\n$\\sin x = x - \\frac{1}{3!}x^3 + o(x^3)$ $\\text{arcsin} x = x + \\frac{1}{3!}x^3 + o(x^3)$ $\\cos x = 1 - \\frac{1}{2!}x^2 + \\frac{1}{4!}x^4 + o(x^4)$ $\\tan x = x + \\frac{1}{3}x^3 + o(x^3)$ $\\text{arctan} x = x - \\frac{1}{3}x^3 + o(x^3)$ $\\ln (x+1) = x - \\frac{1}{2}x^2 + \\frac{1}{3}x^3 + o(x^3)$ $e^x =1 + x + \\frac{1}{2!}x^2 + \\frac{1}{3!}x^3 + o(x^3)$ ${(1+a)}^{\\alpha} = 1 + \\alpha x - \\frac{\\alpha(\\alpha-1)}{2!}x^2 +o(x^2)$ 易错栏目-时不时更新一些易错的知识点 临界区和临界资源，以及进程处于临界区是否可以进行调度 $\\lim\\limits_{x\\to\\infty}e^x$,$\\lim\\limits_{x\\to-\\infty}e^x$,$\\lim\\limits_{x\\to+\\infty}e^x$ 系统调用的过程，谁保存了什么上下文信息（操作系统，硬件）。 安全状态，不安全状态，死锁发生的时间的关系 ","date":"2025-07-17T23:07:05+08:00","permalink":"https://auroraemiya.github.io/npee_learning_log.github.io/memo/0717/","title":"0717学习笔记"},{"content":"数学-纸上得来终觉浅 函数极限的定义($\\epsilon,\\delta$语言)\n函数极限的性质\n唯一性 局部有界性 局部保号性 无穷小(let $\\alpha$ be infinitesimal)\n性质 $\\sum\\limits_{k}^{N}{\\alpha_k}=\\alpha,(N \\text{ is finite})$ $\\alpha\u0026rsquo;\\cdot f(x)=\\alpha $,where $f(x)$ is limited at the interval $\\prod\\limits_{k}^{N}{\\alpha_k}=\\alpha,(N \\text{ is finite})$ 比阶($\\lim\\alpha(x)=0$,$\\lim\\beta(x)=0$,$\\beta(x)\\neq0$) $\\alpha(x)$是$\\beta(x)$的高阶无穷小$\\Leftrightarrow\\lim{\\frac{\\alpha(x)}{\\beta(x)}}=0$ $\\alpha(x)$是$\\beta(x)$的低阶无穷小$\\Leftrightarrow\\lim{\\frac{\\alpha(x)}{\\beta(x)}}=\\infty$ $\\alpha(x)$是$\\beta(x)$的同阶无穷小$\\Leftrightarrow\\lim{\\frac{\\alpha(x)}{\\beta(x)}}=c,(\\text{constant }c\\neq 0)$ $\\alpha(x)$是$\\beta(x)$的等价无穷小$\\Leftrightarrow\\lim{\\frac{\\alpha(x)}{\\beta(x)}}=1$ $\\alpha(x)$是$\\beta(x)$的$k$阶无穷小$\\Leftrightarrow\\lim{\\frac{\\alpha(x)}{\\beta^k(x)}}=0$ 极限的运算\n四则运算 洛必达法则 泰勒展开 夹逼准则 七种未定式：$\\frac{0}{0},\\frac{\\infty}{\\infty},0\\cdot\\infty,\\infty-\\infty,\\infty^0,0^0,1^{\\infty}$ 函数的连续和两类间断点\n超实数(hyperreal number)\n操作系统-three easy piece cpu-intro the Process Process API create Destory Wait Miscellaneous Control Status Process status Proc data structure:(PCB) cpu-api fork() wait() exec() spawn()* cpu-mechanisms from Directed Execution to Limited Directed Execution: user mode and kernel mode system call switch between Processes,Os need to retain CPU from process A Cooperative Approach: Wait For System Calls A Non-Cooperative Approach: The OS Takes Control reboot (x timer interrupt Saving and Restoring Context cpu-sched(reading) cpu-sched-mlfq(reading) 数据结构-排好队一个一个FIFO 队列 顺序队列的性质和操作 循环队列的性质和操作 链式队列的性质和操作 双端队列 课程编号018-027\n","date":"2025-07-17T22:04:43+08:00","permalink":"https://auroraemiya.github.io/npee_learning_log.github.io/posts/0717/","title":"0717学习日志"},{"content":"操作系统-jyy的map永远的噩梦 死锁 死锁的必要条件 互斥条件 请求和保持条件 不可剥夺条件 循环等待条件 预防死锁的方法 破坏互斥：非但不能破坏还要保护 破坏不可剥夺条件 破坏请求和保持条件 破坏循环等待条件 死锁避免 安全状态 银行家算法 死锁检测和解除 资源分配图 死锁定理 死锁的解除 剥夺资源 撤销进程 内存管理 基本概念 逻辑地址 物理地址 外部碎片 内部碎片 内存连续分配管理方式 单一连续分配 固定分区分配 动态分区分配 首次适应FF 循环首次适应NF 最佳适应BF 最坏适应WF 课程编号016-018\n数学-什么？！超实数？ 函数极限的概念与性质 超实数 课程编号第一讲\n","date":"2025-07-15T21:43:17+08:00","permalink":"https://auroraemiya.github.io/npee_learning_log.github.io/posts/0715/","title":"0715学习日志"},{"content":"朝花夕拾 先回答一下昨天的疑问：\n什么是用户级线程和内核级线程？\n以下是chatgpt编写的ULT和KLT的示例c代码\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;ucontext.h\u0026gt; #define STACK_SIZE 1024*64 ucontext_t ctx_main, ctx_thread1, ctx_thread2; void thread_func1() { for (int i = 0; i \u0026lt; 5; i++) { printf(\u0026#34;Thread 1: %d\\n\u0026#34;, i); swapcontext(\u0026amp;ctx_thread1, \u0026amp;ctx_thread2); // 切换到线程2 } printf(\u0026#34;Thread 1 finished\\n\u0026#34;); setcontext(\u0026amp;ctx_main); // 结束返回主程序 } void thread_func2() { for (int i = 0; i \u0026lt; 5; i++) { printf(\u0026#34;Thread 2: %d\\n\u0026#34;, i); swapcontext(\u0026amp;ctx_thread2, \u0026amp;ctx_thread1); // 切换到线程1 } printf(\u0026#34;Thread 2 finished\\n\u0026#34;); setcontext(\u0026amp;ctx_main); } int main() { char stack1[STACK_SIZE]; char stack2[STACK_SIZE]; // 初始化线程1上下文 getcontext(\u0026amp;ctx_thread1); ctx_thread1.uc_stack.ss_sp = stack1; ctx_thread1.uc_stack.ss_size = sizeof(stack1); ctx_thread1.uc_link = \u0026amp;ctx_main; // 线程结束返回主上下文 makecontext(\u0026amp;ctx_thread1, thread_func1, 0); // 初始化线程2上下文 getcontext(\u0026amp;ctx_thread2); ctx_thread2.uc_stack.ss_sp = stack2; ctx_thread2.uc_stack.ss_size = sizeof(stack2); ctx_thread2.uc_link = \u0026amp;ctx_main; makecontext(\u0026amp;ctx_thread2, thread_func2, 0); // 从主线程切换到线程1开始执行 swapcontext(\u0026amp;ctx_main, \u0026amp;ctx_thread1); printf(\u0026#34;Main finished\\n\u0026#34;); return 0; } #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void* func1(void* arg) { for (int i = 0; i \u0026lt; 5; i++) { printf(\u0026#34;pthread func1: %d\\n\u0026#34;, i); sleep(1); // 模拟阻塞 } return NULL; } void* func2(void* arg) { for (int i = 0; i \u0026lt; 5; i++) { printf(\u0026#34;pthread func2: %d\\n\u0026#34;, i); sleep(1); } return NULL; } int main() { pthread_t t1, t2; pthread_create(\u0026amp;t1, NULL, func1, NULL); pthread_create(\u0026amp;t2, NULL, func2, NULL); pthread_join(t1, NULL); pthread_join(t2, NULL); printf(\u0026#34;All pthreads finished\\n\u0026#34;); return 0; 可以看出，实际上ULT是在模拟KLT的实现思想，其调度和上下文切换都是用户程序自己显式实现的，但对于系统来说这仅仅是一个进程而已。那看来多对多的模型就是先申请多个内核，再在每个内核内使用ULT编程。\nPCB都包含什么？\n类别 信息 进程标识信息 PID（进程ID）、PPID（父进程ID）、UID（用户ID）、GID（组ID） 进程状态 就绪、运行、等待、终止等 寄存器现场 程序计数器（PC）、栈指针（SP）、通用寄存器等 内存管理信息 代码段、数据段、堆、栈、页表指针 调度信息 优先级、时间片、调度队列信息、调度策略（如 SCHED_NORMAL） 文件系统信息 文件描述符表、当前工作目录、打开文件列表 会计信息 CPU时间、用户时间、系统时间、起始时间 信号处理信息 信号屏蔽字、信号处理函数 其他资源信息 IPC 资源（消息队列、共享内存）、网络信息等 等配一个linux docker 用命令行敲一下。\n访管中断和自陷指令有和关系？\n自陷指令 访管中断 CPU 支持的汇编指令，用于产生陷入 操作系统级的概念，指的是进程通过自陷调用系统服务 比如：int 0x80（x86）、svc（ARM）、ecall（RISC-V） 访管中断就是自陷指令触发的中断，用来“访问管态（内核态）”服务 本质是硬件机制 本质是软件设计 “访管中断”是\n“用自陷指令引发的，主动请求操作系统服务的中断”。\n数学 三角函数大家族 一些恒等式 $$ \\sin^2{\\theta} + \\cos^2{\\theta} = 1 $$ $$ 1 + \\tan^2{\\theta} = \\sec^2{\\theta} $$ $$ 1 + \\cot^2{\\theta} = \\csc^2{\\theta} $$ $$ \\sin(\\arcsin{x}) = x(x\\in[-1,1]) $$ $$ \\sin(\\arccos{x}) = \\sqrt{1-x^2}(x\\in[-1,1]) $$ $$ \\cos(\\arccos{x}) = x(x\\in[-1,1]) $$ $$ \\cos(\\arcsin{x}) = \\sqrt{1-x^2}(x\\in[-1,1]) $$双曲正弦/余弦函数 双曲正弦函数 $$ \\sinh{x} = \\frac{e^x-e^{-x}}{2} $$ 反双曲正弦函数 $$ \\text{arcsinh}\\ {x} = \\ln(x+\\sqrt{1+x^2}) $$ $$ \\text{arcsinh}'\\ {x} = \\frac{1}{\\sqrt{1+x^2}} $$ 双曲余弦函数 $$ \\cosh{x} = \\frac{e^x+e^{-x}}{2} $$ 反双曲余弦函数 $$ \\text{arccosh}\\ {x} = \\ln(x+\\sqrt{x^2-1}),\\ x\\geq 1\\\\ $$$$ \\text{arccosh}'\\ {x} = \\frac{1}{\\sqrt{x^2-1}},\\ x\u003e1 $$双曲正切函数 $$ \\tanh{x} = \\frac{\\sinh{x}}{\\cosh{x}}=\\frac{e^x-e^{-x}}{e^x+e^{-x}} $$ 反双曲正切函数 $$ \\text{arctanh}\\ {x} = \\frac{1}{2}\\ln(\\frac{1+x}{1-x}),\\ x\\in(-1,1) $$$$ \\text{arctanh}'\\ {x} = \\frac{1}{1-x^2} $$","date":"2025-07-14T21:15:16+08:00","permalink":"https://auroraemiya.github.io/npee_learning_log.github.io/memo/0714/","title":"0714学习笔记"},{"content":"操作系统-这什么查一下这什么查一下 经典同步问题 生产者消费者问题 哲学家进餐问题 读者-写者问题 理发师问题 抽烟者问题 处理机调度 处理及调度的层次\n高级调度（作业调度、长程调度）\n作业选择\n从**后备队列（外存中等待的作业）**中选择作业 判断系统资源（内存、CPU、I/O）是否充足 资源分配\n为选中的作业分配内存、I/O、文件等资源 进程创建\n将作业转化为一个或多个进程，放入就绪队列 中级调度（内存调度、中程调度）\n选择部分进程挂起（移出内存到外存） 选择挂起的进程恢复（从外存调回内存） 低级调度（进程调度、线程调度、短程调度）\n从就绪队列中选择一个进程 把 CPU 分配给选中的进程 保存和恢复进程的上下文（进程切换 Context Switch） 控制 CPU 的执行顺序 处理机的调度方式\n非抢占式 抢占式 选择调度算法的若干准则\nCPU利用率\n$$ \\frac{\\text{worktime of CPU}}{\\text{total time}} $$ 系统吞吐量\n$$ \\frac{\\text{number of tasks}}{\\text{total time}} $$ 周转时间(Turnaround Time)\n$$ \\text{Completion Time - Arrival Time} $$ 平均周转时间\n$$ \\frac{\\sum\\limits_{N}\\text{Turnaround Time of all processes}}{N} $$ 带权周转时间\n$$ \\frac{\\text{Turnaround Time}}{\\text{Service Time}} $$ 平均带权周转时间\n$$ \\frac{\\sum\\limits_{N}\\text{Weighted Turnaround Time of all processes}}{N} $$ 等待时间\n调度算法 FCFS（先来先服务）\nSJF（最短作业优先）\n抢占 非抢占 SRTF（最短剩余时间优先）\nPriority Scheduling（高优先权优先调度）\n抢占 非抢占 Highest Response Ratio Next (HRRN)（高响应比有点调度算法）\nRound Robin（时间片轮转）\nMultilevel Feedback Queue（多级反馈队列调度）\n上下文切换\nCPU上下文切换 系统调用上下文切换 进程上下文切换 用户级 系统级 线程上下文切换 中断上下文切换 课程编号:012-015\n数据结构-致敬传奇栈帧PC程序计数器 栈 静态顺序栈\n判空 判满 进栈 出栈 获取栈顶元素 动态顺序栈\n判空 判满 进栈 出栈 获取栈顶元素 链栈\n判空 判满 进栈 出栈 获取栈顶元素 栈的应用\n括号匹配 进制转换（辗转相除） 函数递归调用 表达式求值 前缀 中缀（重要） 后缀 课程编号：014-017\n数学-太好了是张宇老师我们有救了！ 函数的概念与特性 函数 反函数 复合函数 隐函数 函数的四种特性 有界性 单调性 奇偶性 周期性 基本初等函数与初等函数 常函数 幂函数 指数函数 对数函数 三角函数 sin x cos x csc x sec x tan x cot x 反三角函数 arcsin x arccos x arctanx arccot x 分段函数 高数第一讲\n","date":"2025-07-14T21:15:02+08:00","permalink":"https://auroraemiya.github.io/npee_learning_log.github.io/posts/0714/","title":"0714学习日志"},{"content":"数据结构-喜欢在头指针存数据的扣1 线性表的链式存储\n单链表 静态链表 其他链表 单向循环链表 双向链表 双向循环链表 课程代码010-013\n操作系统-谦让是美德 进程与线程 进程\nPCB 进程的特点： 动态性 并发性 独立性 异步性 进程的基本状态及管理切换 运行 阻塞 就绪 创建 终止 线程\n线程的特性 线程的状态 线程与进程的联系和不同 用户级线程与内核级线程的映射关系 互斥与同步 临界区实现互斥的原则\n空闲让进 忙则等待 有限等待 让权等待（非必须） 临界区实现互斥的基本方法\n软件实现方法 单标志法 双标志法 先检查法 后检查法 Peterson算法 硬件实现方法 中断屏蔽 TestAndSet指令 Swap指令 互斥锁（mutex lock）\nLockOne类 LockTwo类 Peterson锁 Barkley锁 信号量\n整型信号量 记录型信号量 管程 管程的定义 管程的组成 管程的特性 管程与进程的异同 条件变量 进程通信 管道通信 消息传递系统 共享存储器系统 课程编号005-011\n","date":"2025-07-13T23:27:16+08:00","permalink":"https://auroraemiya.github.io/npee_learning_log.github.io/posts/0713/","title":"0713学习日志"},{"content":"今天看来是无法解决所有当下的疑问了，故先列出清单：\n什么是用户级线程和内核级线程？ PCB都包含什么？ 访管中断和自陷指令有和关系？ ","date":"2025-07-13T23:27:16+08:00","permalink":"https://auroraemiya.github.io/npee_learning_log.github.io/memo/0713/","title":"0713学习笔记"},{"content":"操作系统 系统调用 功能 设备管理：设备的启动、请求和释放等。 文件管理：文件的读写、创建和删除等。 进程管理：进程的创建、撤销、阻塞和唤醒等。 进程通信：进程之间的消息或信号的传递等。 内存管理：内存的分配、回收以及获取作业占用内存区大小和起始地址等。 处理过程 用户程序将系统调用号和所需的参数压入堆栈；接着，调用实际的调用指令，然后执行一个陷入指令，将CPU从用户态转为核心态；再由硬件和操作系统内核程序保护被中断进程的现场。将程序计数器PC、程序状态字PSW及通用寄存器内容压入堆栈。 分析系统调用类型，转入相应的系统调用处理子程序。在系统中配置了一张系统调用入口表，表中的每个表项都对应一个系统调用，根据系统调用号找到该系统调用处理子程序的入口地址。 在系统调用处理子程序执行结束后，恢复被中断的或设置新进程的CPU现场，然后返回被中断进程或新进程，继续往下执行。 ","date":"2025-07-12T23:17:40+08:00","permalink":"https://auroraemiya.github.io/npee_learning_log.github.io/memo/0712/","title":"0712学习笔记"},{"content":"今天带刚来杭州的太阳(应当事人的要求使用该昵称)去西湖游玩。其实天气预报有雨，但东坡先生有诗为证：\n水光潋滟晴方好，山色空蒙雨亦奇。 欲把西湖比西子，淡妆浓抹总相宜。\n雨中西湖，让我陷入无穷大的浪漫遐想和无穷小的现实担忧。\n出了地铁站，人潮涌动；\n走到西湖畔，黑云从远处压来。\n走到白堤，下雨了。\n起先，觉得东坡先生诚不欺我，湖面落入无数雨珠，游船驶向远处，远处的山朦朦胧胧。\n我很兴奋，直到鞋被完全浸湿，直到暴雨驱散所有的游客。还没走完苏堤，到断桥，水已经漫过脚踝。\n最后不得已灰溜溜的挤进公交车，公交车在水中乘风破浪，我们像两株水草。\n虽然结局略微狼狈，不过也略微读懂了东坡先生的另一首诗：\n莫听穿林打叶声，何妨吟啸且徐行。竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。\n“因为在雨中，我们看着落下雨幕的远方，牵着手笑着前行。”\n","date":"2025-07-12T22:27:55+08:00","image":"https://auroraemiya.github.io/npee_learning_log.github.io/diary/westlake-with-haruko/westlake_in_strom_hu_10ad18bd7f5a9650.jpg","permalink":"https://auroraemiya.github.io/npee_learning_log.github.io/diary/westlake-with-haruko/","title":"暴雨西湖"},{"content":"操作系统-int 0x80 操作系统的运行环境\n内核程序 特权指令 核心态，管态 应用程序 非特权指令 用户态，目态 操作系统的内核\n时钟管理 中断机制 内部异常 故障（Fault）（软件中断） 自陷（Trap）（软件中断） 终止（Abort）（硬件中断） 外部中断（硬件） 可屏蔽中断 INTR 不可屏蔽中断 NMI 课程编号 ：003-004\n英语-英语构词法 前缀包含两种作用：\n方向 性质 后缀一般表示词性，例外：able,\u0026hellip;.\n","date":"2025-07-12T22:05:39+08:00","permalink":"https://auroraemiya.github.io/npee_learning_log.github.io/posts/0712/","title":"0712学习日志"},{"content":"数据结构-太好了是死记硬背 数据的逻辑和物理结构 算法的时间空间复杂度 线性表的顺序表以及相关算法 课程编号001-009\n操作系统-想念jyy的第n天 操作系统概述 并发 共享 虚拟 异步 操作系统的发展历程 批处理器 单道 多道 分时操作系统 实时操作系统 网络操作系统 分布式操作系统 \u0026hellip;\u0026hellip; 课程编号001-002\n","date":"2025-07-11T20:29:14+08:00","permalink":"https://auroraemiya.github.io/npee_learning_log.github.io/posts/0711/","title":"0711学习日志"},{"content":"写在一切的前面 欢迎来到我的博客，这是我 （笔者自称小shy)为了记录参加2026考研全过程而开始的新栏目。\n我准备参加今年年底的2026NPEE(The national entrance examination for postgraduate)，科目是11408。\n此后我将更新自己从7月初到12月底的备考全过程日志，具体包括三个栏目：\n日记：这个部分属于随便写点感想什么的（随缘更新）。 日志：这个部分属于日常更新自己的学习/复习进度，欢迎监督！ 笔记：这个部分用于记录自己的学习心得和一些易错知识点。 可能以后还会补充，但是目前就先这样。\n联系方式可能以后会留一个收信的邮箱，这里打一个(TODO)（笑\n","date":"2025-07-11T16:35:21+08:00","permalink":"https://auroraemiya.github.io/npee_learning_log.github.io/diary/intro/","title":"Intro-全部の始まり"}]