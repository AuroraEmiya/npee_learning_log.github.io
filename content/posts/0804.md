+++
date = '2025-08-04T20:51:06+08:00'
draft = false
title = '0804学习日志'

categories="log"

tags=["IO层次结构","DMA","计算机引导过程"]

+++

## 操作系统-IO管理

### IO层次结构

计算机的外部设备（I/O 设备）种类繁多，特性千差万别：

* **速度差异巨大：** CPU 的速度比键盘快上亿倍，但比高速的 NVMe SSD 又慢一些。
* **功能各异：** 打印机是输出设备，键盘是输入设备，硬盘既是输入也是输出设备。
* **控制方式复杂：** 每个设备都有自己独特的指令集、寄存器和工作协议。

如果让每个应用程序都去直接和这些具体的硬件打交道，那将是一场灾难。因此，操作系统设计了一个分层的结构来管理 I/O，其主要目标是：

1. **设备独立性（Device Independence）：** 应用程序的编写不应依赖于具体的物理设备。例如，一个程序向一个文件写入数据，它不应该关心这个文件是存在于机械硬盘、U盘还是网络存储上。
2. **统一接口（Uniform Interface）：** 为应用程序提供一个简洁、一致的访问接口。在类 Unix 系统中，这个思想的极致体现就是“一切皆文件”，无论是访问硬盘、键盘还是打印机，都可以使用类似 `read()` 和 `write()` 的函数。
3. **错误处理（Error Handling）：** 在尽可能低的层次处理设备错误，只将无法解决的严重错误向上层报告，简化上层软件的逻辑。
4. **效率与性能（Efficiency and Performance）：** 通过缓冲（Buffering）、缓存（Caching）和异步操作等技术，协调高速 CPU 与低速设备之间的矛盾，提高系统整体吞吐量。

I/O 软件通常被组织成一个四到五层的结构。一个 I/O 请求会从顶层逐级向下传递，直到硬件；而操作完成的信号和数据则会从底层逐级向上传递。

下面是从上到下（从用户到硬件）的层次结构：

---

#### **第 1 层：用户层 I/O 软件 (User-Level I/O Software)**

这是最靠近应用程序的一层，它不是操作系统内核的一部分。

* **功能：** 为应用程序员提供方便的接口库（Library），这些库函数最终会通过**系统调用（System Call）**请求内核的服务。
* **例子：**
  * C语言中的标准 I/O 库函数，如 `printf()`, `scanf()`, `fopen()`, `fread()`。
  * 各种编程语言提供的 I/O 库。
* **工作流程：** 比如，当你在程序中调用 `printf("Hello")` 时，`printf` 函数会格式化字符串，然后调用底层的 `write()` 系统调用，请求内核将数据输出到屏幕。

---

#### **第 2 层：设备无关的操作系统软件 (Device-Independent OS Software)**

这是 I/O 结构的核心，它实现了设备独立性的主要逻辑。

* **功能：** 提供一个对所有设备都统一的框架。它负责处理所有设备共有的功能。
  * **统一接口：** 向用户层提供统一的系统调用接口（如 `read`, `write`, `open`, `close`）。
  * **设备命名：** 将设备映射到文件系统中的名字（例如 Linux 中的 `/dev/sda1` 代表第一个硬盘的第一个分区）。
  * **设备保护：** 检查用户是否有权限访问某个设备。
  * **提供缓冲（Buffering）：** 在用户空间和设备之间提供数据缓冲区，以协调速度差异。
  * **分配与释放：** 管理设备的分配和释放，例如独占设备（如打印机）的使用。
* **例子：** Linux 中的虚拟文件系统（VFS）层就扮演了这个角色。

---

#### **第 3 层：设备驱动程序 (Device Drivers)**

这是操作系统内核中与特定设备直接相关的部分。

* **功能：** 充当“翻译官”的角色。它接收来自上层（设备无关层）的抽象命令（如“从这个设备读取 512 字节”），并将其翻译成设备控制器能够理解的具体指令（如向设备的某个寄存器写入特定的值）。
* **特点：**
  * **设备特定：** 每种类型的设备（或一个设备家族）都有一个专门的驱动程序。例如，NVIDIA 显卡有其驱动，Intel 的网卡有它的驱动。
  * **可加载模块：** 现代操作系统通常将驱动程序实现为内核模块，可以在系统运行时动态加载或卸载，而无需重新编译整个内核。
* **工作流程：** 驱动程序设置好设备寄存器，命令设备开始工作后，它通常会阻塞（等待）直到设备完成操作。

---

#### **第 4 层：中断处理程序 (Interrupt Handlers)**

这是处理硬件与软件交互最底层、最直接的部分。

* **功能：** 当 I/O 设备完成一项任务（例如，硬盘读完一个数据块）或者发生错误时，它会向 CPU 发送一个**中断信号（Interrupt）**。中断处理程序就是被这个信号触发而运行的一段代码。
* **工作流程：**
  1. CPU 暂停当前正在执行的任何任务。
  2. 保存当前任务的上下文（寄存器状态等）。
  3. 跳转到预设的中断处理程序地址并开始执行。
  4. 中断处理程序分析中断原因，进行相应处理（例如，将从设备读取的数据放入缓冲区，并唤醒正在等待这个数据的设备驱动程序）。
  5. 处理完毕后，恢复之前被暂停任务的上下文，让它继续运行。
* **核心作用：** 实现了真正的异步操作，让 CPU 在等待 I/O 时可以去做别的事情，而不是空闲等待。

---

#### **第 5 层：硬件 (Hardware)**

这是层次结构的最底层，包含了物理设备本身及其控制器。

* **组成：** 设备本身（如磁盘盘片、打印机喷头）和设备控制器（一块包含寄存器和逻辑电路的芯片，负责与 CPU 通信）。
* **功能：** 真正执行 I/O 操作的物理实体。

#### 一次 I/O 请求的完整流程（以读文件为例）

假设一个用户程序执行 `read(fd, buffer, nbytes)` 来读取文件：

1. **用户层：** `read()` 库函数打包参数，并发起一个**系统调用**陷入内核。
2. **设备无关层：**
   * 内核的设备无关软件接收到请求。
   * 它首先检查内核的**缓冲区缓存（Buffer Cache）**，看请求的数据是否已经存在。如果命中，则直接从缓存复制数据到用户 `buffer`，请求结束。
   * 如果未命中，它会计算出需要从哪个设备的哪个物理位置读取数据。
   * 然后调用该设备的**驱动程序**。
3. **设备驱动层：**
   * 设备驱动程序接收到请求（例如，“读取硬盘的第 12345 号逻辑块”）。
   * 它将这个抽象请求翻译成设备控制器能懂的命令，并把这些命令写入设备控制器的寄存器中。
   * 驱动程序随后**阻塞**当前进程（将其放入等待队列），并让出 CPU。
4. **硬件层：**
   * 设备控制器开始工作，驱动硬盘马达，移动磁头，读取数据到其内部缓冲区。
5. **中断处理层（返回过程）：**
   * 当硬件完成数据读取后，它向 CPU 发送一个**中断**。
   * CPU 捕获中断，并执行对应的**中断处理程序**。
   * 中断处理程序从设备控制器的缓冲区取出数据，放入内核的缓冲区缓存中。
   * 然后，它唤醒之前被阻塞的设备驱动进程。
6. **返回上层：**
   * 被唤醒的设备驱动程序得知操作已完成。
   * 设备无关层将数据从内核的缓冲区缓存复制到用户程序指定的 `buffer` 中。
   * 系统调用返回，用户程序从 `read()` 调用处继续执行。

| 层次                     | 主要功能                                               | 例子                                 |
| ------------------------ | ------------------------------------------------------ | ------------------------------------ |
| **用户层软件**     | 提供方便的编程接口，发起系统调用                       | `printf()`, `fopen()` 等库函数   |
| **设备无关OS软件** | 提供统一接口，设备命名，缓冲，错误报告，分配与释放     | 虚拟文件系统(VFS)，缓冲区缓存管理    |
| **设备驱动程序**   | 设置设备寄存器，检查设备状态，将抽象命令翻译为具体指令 | 显卡驱动，网卡驱动，磁盘驱动         |
| **中断处理程序**   | 响应硬件中断，保存CPU状态，唤醒驱动程序                | I/O 完成中断，时钟中断               |
| **硬件**           | 执行具体的I/O操作                                      | 磁盘控制器，键盘控制器，物理设备本身 |

`(Output by Gemini2.5pro)`

### DMA

（DMA工作流程）

DMA的出现就是为了将CPU从这种繁琐的搬运工作中解放出来。下面是DMA的工作流程，以及各层次扮演的角色：

| 步骤        | 动作                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | 负责的层次/组件                           |
| :---------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------- |
| **1** | 用户程序发起一个读操作（例如 `read()` 系统调用）。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | **用户层软件**                      |
| **2** | 系统调用陷入内核，请求被**设备无关的OS软件**接收。它可能会检查缓存，如果未命中，则确定需要调用哪个驱动。                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | **设备无关的OS软件**                |
| **3** | **设备驱动程序**被调用。这是最关键的一步，驱动程序开始**配置DMA**：`<br>`1. 在内存中分配一个缓冲区（Buffer）。`<br>`2. 告诉**DMA控制器**四件事：`<br>`   - **源地址**：要从哪个设备寄存器读取数据。`<br>`   - **目标地址**：数据要存放到内存的哪个位置（即缓冲区地址）。`<br>`   - **传输长度**：要传输多少字节的数据。`<br>`   - **传输方向**：是从设备读到内存，还是从内存写到设备。`<br>`3. 驱动程序向**设备控制器**发出“开始传输数据给DMA”的命令。`<br>`4. 驱动程序将当前进程**阻塞**，并让出CPU给其他进程使用。 | **设备驱动程序**                    |
| **4** | **DMA控制器**完全接管数据传输。它直接与**设备控制器**和**内存总线**交互，将数据块从设备搬运到内存缓冲区，整个过程**无需CPU干预**。                                                                                                                                                                                                                                                                                                                                                                                                                                   | **硬件层 (DMA控制器 & 设备控制器)** |
| **5** | 数据传输完成后，**DMA控制器**会向CPU发送一个**中断信号**，通知任务已完成。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | **硬件层 (DMA控制器)**              |
| **6** | CPU捕获中断，并跳转到**中断处理程序**执行。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | **中断处理程序**                    |
| **7** | 中断处理程序分析中断来源，发现是DMA完成中断。于是它**唤醒**之前被阻塞的**设备驱动程序**对应的进程。                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | **中断处理程序**                    |
| **8** | 驱动程序被唤醒后，知道数据已经安全地存放在内存缓冲区里了。它进行一些清理工作，并将结果报告给上层。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | **设备驱动程序**                    |
| **9** | **设备无关的OS软件**将数据从内核的缓冲区复制到用户程序的缓冲区，然后系统调用返回。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | **设备无关的OS软件**                |

### SPOOLing

### 引导过程

好的，我们来详细、系统地讲解一下计算机的**引导过程（Booting Process 或 Bootstrap）**。这个过程是指从按下电源按钮开始，到操作系统完全加载并准备好与用户交互为止的一系列复杂而有序的步骤。

“Bootstrap”这个词源于一个古老的说法“pull oneself up by one's bootstraps”（靠自己鞋带把自己拉起来），形象地比喻了计算机在没有任何外部帮助的情况下，如何一步步地“唤醒”自己。

计算机的引导过程主要可以分为两种主流方式：传统的 **BIOS-MBR** 方式和现代的 **UEFI-GPT** 方式。我们分别来介绍。

---

#### 1. 传统的 BIOS-MBR 引导过程

这是在2010年之前个人电脑最常见的引导方式。

##### **阶段一：BIOS 阶段 (固件执行)**

1. **上电 (Power On)：** 当你按下电源键，主板上的电源管理单元（PSU）向CPU发送一个“Power Good”信号。CPU接收到信号后，开始执行存储在主板上一个ROM芯片（通常是EEPROM或Flash）中的程序。这个程序就是 **BIOS (Basic Input/Output System)**。
2. **POST (Power-On Self-Test - 开机自检)：** BIOS 首先会运行开机自检程序。

   * **任务：** 检查计算机最核心的硬件是否工作正常，包括 CPU、内存（RAM）、显卡、键盘等。
   * **反馈：** 如果自检通过，通常会发出一声短促的“嘀”声。如果发现严重故障（如内存没插好），它会通过不同的蜂鸣声组合来报警。
3. **初始化硬件 (Initialization)：** BIOS 初始化一些关键的硬件设备，为后续加载操作系统做准备。
4. **选择引导设备 (Boot Device Selection)：**

   * BIOS会根据预设的启动顺序（Boot Order，可在BIOS设置中修改），依次检查可引导的存储设备，如硬盘、U盘、光驱、网络等。
   * 它会检查每个设备的**第一个扇区（512字节）**。
5. **加载 MBR (Master Boot Record - 主引导记录)：**

   * 当BIOS找到一个可引导的硬盘时，它会检查这个硬盘的第一个扇区（也称为0号扇区）的最后两个字节是否为 `0x55AA`（称为**引导签名**）。
   * 如果签名正确，BIOS就会将这整个512字节的**主引导记录（MBR）**加载到内存的一个固定地址（通常是 `0x7C00`）处，然后将CPU的控制权**转交**给这段刚刚加载的代码。
   * **到此，BIOS的任务彻底完成。**

##### **阶段二：MBR 与 Bootloader 阶段 (硬盘代码执行)**

1. **MBR 执行：** CPU 开始执行内存中 `0x7C00` 地址处的MBR代码。MBR非常小，只有不到446字节的代码空间。它的任务很简单：

   * 在MBR内部的分区表中，找到被标记为“**活动**”的那个分区（只有一个）。
   * 将该活动分区的**第一个扇区**——称为**分区引导记录（PBR - Partition Boot Record）**或卷引导记录（VBR）——加载到内存中。
   * 将CPU控制权转交给这段PBR代码。
2. **Bootloader 执行：** PBR中的代码通常是**操作系统加载器（Bootloader）**的第一部分。例如，Windows的 `bootmgr` 或 Linux 的 `GRUB (GRand Unified Bootloader)`。

   * 由于一个扇区太小，Bootloader通常会分为多个阶段。第一阶段的代码（在PBR中）非常简单，其唯一任务就是从文件系统中加载Bootloader的后续、更复杂的阶段代码。
   * Bootloader的功能要强大得多，它能够识别和解析文件系统（如NTFS, ext4），因为它需要找到并加载操作系统的核心文件。

##### **阶段三：操作系统内核加载**

1. **加载内核 (Kernel Loading)：** Bootloader（如GRUB）会根据其配置文件（如 `grub.cfg`）中的指令，找到操作系统内核文件（如Windows的 `ntoskrnl.exe` 或Linux的 `vmlinuz`）和初始内存盘（`initrd.img`）等，并将它们加载到内存中。
2. **启动内核 (Kernel Initialization)：**

   * Bootloader将CPU控制权最终交给加载到内存中的**操作系统内核**。
   * 内核开始执行，它会：
     * 初始化更高级的硬件驱动程序。
     * 启动核心的系统进程（如Windows的 `System`进程，Linux的 `systemd`或 `init`进程）。
     * 挂载根文件系统。
     * 启动用户界面的相关服务，最终显示登录界面或桌面。

**至此，整个引导过程完成。**

---

#### 2. 现代的 UEFI-GPT 引导过程

UEFI (Unified Extensible Firmware Interface) 是BIOS的现代替代品，它克服了BIOS的许多限制。GPT (GUID Partition Table) 是MBR的替代分区方案。

UEFI的引导过程更直接、更灵活、更安全。

##### **阶段一：UEFI 固件执行**

1. **上电与 SEC (Security) 阶段：** 与BIOS类似，系统上电，CPU开始执行UEFI固件代码。首先是安全验证阶段，为后续执行建立一个可信的环境。
2. **PEI (Pre-EFI Initialization) 阶段：** 类似于POST，进行核心硬件（CPU、芯片组、内存）的初始化。
3. **DXE (Driver Execution Environment) 阶段：** 这是UEFI的核心。UEFI固件会加载和执行大量的**UEFI驱动程序**。这使得UEFI在引导阶段就能识别复杂硬件，并能识别GPT分区表和FAT32等文件系统。**这是UEFI与BIOS最本质的区别**——BIOS不懂文件系统，而UEFI懂。
4. **BDS (Boot Device Select) 阶段：**

   * UEFI固件会读取存储在**NVRAM**（一种非易失性RAM）中的启动项配置。
   * 它不再是盲目地去读设备的第一个扇区。相反，它直接去访问硬盘上一个特殊的、必需的、格式为FAT32的小分区，称为 **EFI系统分区 (ESP - EFI System Partition)**。
   * UEFI会根据启动项配置，在ESP分区中查找并执行指定的**引导加载程序文件**。这个文件是一个标准的 `.efi` 可执行文件，例如 `\EFI\Microsoft\Boot\bootmgfw.efi` (Windows) 或 `\EFI\ubuntu\shimx64.efi` (Ubuntu)。

##### **阶段二：操作系统加载**

1. **执行EFI引导程序：** UEFI固件直接将CPU控制权交给从ESP分区加载的 `.efi` 文件。
2. **加载操作系统：** 这个 `.efi`引导程序（如Windows Boot Manager或GRUB2）接下来负责加载操作系统的内核和相关文件，并将控制权交给内核。
3. **内核初始化：** 后续步骤与BIOS-MBR方式基本相同，内核接管系统，完成初始化，并启动用户界面。

#### BIOS-MBR vs. UEFI-GPT 对比

| 特性               | BIOS-MBR                   | UEFI-GPT                             | 优势                                                         |
| ------------------ | -------------------------- | ------------------------------------ | ------------------------------------------------------------ |
| **分区方案** | MBR (Master Boot Record)   | GPT (GUID Partition Table)           | GPT支持超过2TB的硬盘和最多128个主分区，更可靠。              |
| **引导方式** | 读设备第一个扇区，链式加载 | 直接从ESP分区加载 `.efi` 文件      | UEFI更直接、更快速，因为它认识文件系统，无需链式跳转。       |
| **代码架构** | 16位汇编，实模式           | 32/64位C语言，保护模式               | UEFI像一个微型操作系统，功能强大，界面友好（支持鼠标）。     |
| **安全性**   | 无原生安全机制             | 支持**安全启动 (Secure Boot)** | Secure Boot可以防止未经签名的恶意引导程序（如Bootkit）加载。 |
| **兼容性**   | 兼容性好，但技术老旧       | 现代主流标准，但老旧系统可能不支持   | UEFI是未来趋势。                                             |

总而言之，计算机的引导过程是一个从固化在硬件中的最简单代码开始，一步步加载更复杂软件，最终将整个庞大的操作系统“唤醒”并交出控制权的接力过程。
