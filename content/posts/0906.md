+++
date = '2025-09-07T23:32:42+08:00'
draft = false
title = '0906学习日志'

categories="log"

tags=["计算机组成原理","指令系统","RISC","CISC","程序的机器级代码表示","汇编语言","常用指令"]

+++

## 计算机组成原理-死去的RISC-V突然攻击我

### 程序的机器级代码表示

1. 常用汇编指令介绍

   1. 相关寄存器

      | 16bit | 32bit | 说明                        |
      | ----- | ----- | --------------------------- |
      | AX    | EAX   | 累加器（Accumulator）       |
      | BX    | EBX   | 基地址寄存器(Base Register) |
      | CX    | ECX   | 计数寄存器(Count Register)  |
      | DX    | EDX   | 数据寄存器(Data Register)   |
      |       | ESI   | 变址寄存器(Index Register)  |
      |       | EDI   | 变址寄存器(Index Register)  |
      |       | EBP   | 堆栈基指针(Base Pointer)    |
      |       | ESP   | 堆栈顶指针(Stack Pointer)   |

   2. 汇编指令格式

      1. AT&T 格式简介

         - 主要用于 **GNU Assembler (GAS)**，即 `gcc` 默认输出。

         - 语法较“繁琐”，但严格、明确，容易让编译器处理。

         - 特点：寄存器有 `%` 前缀，立即数 `$` 前缀，操作数顺序是 `源, 目的`。

         示例：

          ```asm
          movl $5, %eax      # 把立即数 5 移动到 eax
          addl %eax, %ebx    # ebx = ebx + eax
          movl 8(%ebp), %ecx # 从 [ebp+8] 取数到 ecx
          ```

      2. Intel 格式简介

         - 常见于 **MASM / NASM / Windows 平台**。

         - 更接近高级语言风格，简洁直观，广泛用于手写汇编和逆向分析。

         - 特点：操作数顺序 `目的, 源`，寄存器无 `%`，立即数直接写，内存寻址用 `[]`。

         示例：
         
         ```asm
         mov eax, 5          ; 把立即数 5 移动到 eax
         add ebx, eax        ; ebx = ebx + eax
         mov ecx, [ebp+8]    ; 从 [ebp+8] 取数到 ecx
         ```
         
         

      3. 对比表：AT&T vs Intel 汇编格式

      | 特点           | **AT&T 格式**                                       | **Intel 格式**                                          |
      | -------------- | --------------------------------------------------- | ------------------------------------------------------- |
      | **操作数顺序** | 源, 目的                                            | 目的, 源                                                |
      | **寄存器**     | `%eax`、`%ebx`                                      | `eax`、`ebx`                                            |
      | **立即数**     | `$5`                                                | `5`                                                     |
      | **内存寻址**   | `disp(base, index, scale)` → `8(%ebp, %ecx, 4)`     | `[base + index*scale + disp]` → `[ebp + ecx*4 + 8]`     |
      | **操作数大小** | 指令后缀：`b`=8位, `w`=16位, `l`=32位, `q`=64位     | `byte ptr`, `word ptr`, `dword ptr`, `qword ptr`        |
      | **符号/变量**  | `movl $var, %eax` (取地址)  `movl var, %eax` (取值) | `mov eax, offset var` (取地址)  `mov eax, [var]` (取值) |
      | **汇编器**     | GNU Assembler (`gas`)                               | MASM, NASM, FASM 等                                     |
      | **常见平台**   | Linux/Unix 系统                                     | Windows、逆向工程                                       |

   3. 常用指令

      * <reg>
      * <mem>
      * <con>,<con32>

      1. 数据传送指令
         1. mov
         2. push
         3. pop
      2. 算术和逻辑运算指令
         1. add/sub
         2. inc/dec
         3. imul
         4. idiv
         5. and/or/xor
         6. not
         7. neg
         8. shl/shr
      3. 控制流指令
         1. jmp
         2. jcondition: je,jz,jne,jg,jge,jl,jle
         3. cmp/test
         4. call/ret

2. 选择语句的机器级表示

   ```pseudocode
   if(test_expr)
   	then_statement
   else
   	else_statement
   ```

   ```pseudocode
   t=test_expr
   if(!t)
   	goto false;
   then_statement
   goto done;
   false:
   else_statement
   done;
   ```

3. 循环语句的机器级表示

   1. do-while

      ```pseudocode
      do 
      	body_statement
      	while(test_expr);
      ```

      ```pseudocode
      loop:
      body_statement
      t=test_expr;
      if(t)
      	goto loop;
      ```

   2. while

      ```pseudocode
      while(test_expr)
      	body_statement
      ```

      ```pseudocode
      t=test_expr;
      if(!t)
      	goto done;
      loop:
      body_statement;
      t=test_expr;
      if(t)
      	goto loop;
      done:
      ```

   3. for

      ```pseudocode
      for(init_expr;test_expr;update_expr)
      	body_statement
      ```

      ```pseudocode
      init_expr;
      t=test_expr;
      if(!t)
      	goto done;
      loop:
      body_statement
      update_expr;
      t=test_expr;
      if(t)
      	goto loop;
      done:
      ```

4. 过程调用的机器级表示

------



### CISC和RISC的基本概念

1. 复杂指令系统计算机(CISC)

   - 特点：指令集复杂，每条指令可以完成较复杂的操作，指令长度不固定。
   - 设计理念：**软件简单化，把更多功能交给硬件来完成**。
   - 常见架构：x86、VAX、68000。

2. 精简指令系统计算机(RISC)

   - 特点：指令集简单，每条指令长度固定，执行时间大多相同。
   - 设计理念：**硬件简单化，指令执行快，依靠编译器优化来实现复杂功能**。
   - 常见架构：ARM、MIPS、RISC-V、SPARC。

3. CISC和RISC的比较

   | 特点             | **RISC**（精简指令集）     | **CISC**（复杂指令集）     |
   | ---------------- | -------------------------- | -------------------------- |
   | **指令数量**     | 少，指令集精简             | 多，指令功能复杂           |
   | **指令长度**     | 固定（常见 32 位）         | 不固定（8～120 字节不等）  |
   | **指令执行时间** | 大多数指令 1 个时钟周期    | 指令执行时间差别大         |
   | **寻址方式**     | 少（常 3～5 种）           | 多（十几种甚至几十种）     |
   | **硬件复杂度**   | 控制器一般为硬布线（简单） | 控制器常为微程序（复杂）   |
   | **编译器依赖性** | 高，复杂操作要由编译器分解 | 低，硬件可直接完成复杂操作 |
   | **性能优化方式** | 通过流水线、寄存器优化     | 通过复杂指令减少代码长度   |
   | **代表架构**     | ARM、MIPS、RISC-V          | x86、Intel 8086、VAX       |
   | **代码密度**     | 代码长（指令多）           | 代码短（指令少，但复杂）   |



